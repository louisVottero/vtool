# Copyright (C) 2022 Louis Vottero louis.vot@gmail.com    All rights reserved.

from __future__ import absolute_import

import random
import os
# import util
from . import api
import vtool.util

if vtool.util.is_in_maya():
    import maya.cmds as cmds
    import maya.api.OpenMaya as om

from . import core
from . import attr
from . import space
from . import anim
from . import curve
from . import geo
from . import deform
from . import rigs_util
from . import fx
from .. import util_math
from .. import util_file

# --- rigs


class Rig(object):
    """Base class for rigs."""

    side_left = 'L'
    side_right = 'R'
    side_center = 'C'

    def __init__(self, description, side=None):

        self._created = False

        self.side = side

        self.joints = []
        self.buffer_joints = []

        self.description = description

        self._control_inst = None

        self._set_sub_control_color_only = False

        self._handle_side_variations()

        self.control_group = None
        self.setup_group = None

        self.control_parent = None
        self.setup_parent = None

        self._create_default_groups()
        self._delete_setup = False

        self.control_shape = 'circle'
        self.sub_control_shape = None

        self.control_color = None
        self.sub_control_color = None

        self.control_size = 1
        self.sub_control_size = 0.8
        self.control_offset_axis = None

        self.controls = []
        self.sub_controls = []
        self._sub_controls_with_buffer = []
        self.control_dict = {}

        self.sub_visibility = False
        self._connect_sub_vis_attr = None

        self._connect_important = True
        self._connect_important_node = None

        self._control_number = True
        self._custom_sets = []

        self._switch_parent = None
        self._pick_walk_parent = None

        self.hue = None
        self.sub_hue = None
        self.saturation = None
        self.color_value = None

        self.hue_inc = None
        self.saturation_inc = None
        self.color_value_inc = None

    def _pre_create(self):
        vtool.util.show('\n')
        vtool.util.show(
            'Creating rig: %s, description: %s, side: %s' % (self.__class__.__name__, self.description, self.side))
        self._parent_default_groups()

        self._pre_create_sub_visibility_attribute()

    def _pre_create_sub_visibility_attribute(self):

        if not self._connect_sub_vis_attr:
            return

        node = core.get_basename(self._connect_sub_vis_attr, remove_attribute=True)

        if not cmds.objExists(node):
            return

        attribute = attr.get_attribute_name(self._connect_sub_vis_attr)

        if not attribute:
            attribute = 'subVisibility'
            self._connect_sub_vis_attr = '%s.%s' % (node, attribute)

        if not cmds.objExists(self._connect_sub_vis_attr):
            cmds.addAttr(node, ln=attribute, at='bool', k=True, dv=self.sub_visibility)

    def _post_create(self):

        self._created = True

        cmds.addAttr(self.control_group, ln='className', dt='string')

        cmds.setAttr('%s.className' % self.control_group, str(self.__class__.__name__), type='string')

        try:
            self._post_create_rotate_order()
        except:
            vtool.util.warning('Could add rotate order to channel box')

        if self._connect_important:

            vtool.util.show('Connect Important!')

            self._post_create_connect('controls', 'control')
            self._post_create_connect('_sub_controls_with_buffer', 'subControl')
            self._post_create_connect('joints', 'joint')
            self._post_create_connect('ik_handle', 'ikHandle')

            if self.joints:
                attr.connect_message(self.control_group, self.joints[0], 'rig1')

        self._post_add_shape_switch()

        self._post_store_orig_matrix('controls')
        self._post_store_orig_matrix('_sub_controls_with_buffer')
        self._post_store_orig_matrix('joints')

        self._post_add_to_control_set()
        self._post_connect_controller()
        self._post_connect_controls_to_switch_parent()

        self._post_connect_sub_control_visibility()

        if self._delete_setup:
            self.delete_setup()

        if cmds.objExists(self.setup_group):

            if core.is_empty(self.setup_group):
                parent = cmds.listRelatives(self.setup_group, p=True)

                if not parent:
                    class_name = self.__class__.__name__

                    vtool.util.warning('Empty setup group in class: %s with description %s %s.' % (
                        class_name, self.description, self.side))

        vtool.util.show('Finished rig.\n')

    def _post_add_shape_switch(self):

        if hasattr(self, 'create_buffer_joints'):

            if not self.create_buffer_joints:
                return
        else:
            return

        if not hasattr(self, '_switch_shape_attribute_name'):
            return

        if not self._switch_shape_attribute_name:
            return

        shapes = core.get_shapes(self.joints[0], shape_type='locator', no_intermediate=True)

        name = self._switch_shape_attribute_name
        node_name = 'switch_setting'
        if self._switch_shape_node_name:
            node_name = self._switch_shape_node_name
        if not self._switch_shape_node_name:
            if self._switch_shape_attribute_name:
                node_name = self._switch_shape_attribute_name

        if cmds.objExists(node_name) and core.is_a_shape(node_name):
            shapes = [node_name]

        if not shapes:
            locator = cmds.spaceLocator()
            shapes = core.get_shapes(locator, shape_type='locator', no_intermediate=True)

            cmds.setAttr('%s.localScaleX' % shapes[0], 0)
            cmds.setAttr('%s.localScaleY' % shapes[0], 0)
            cmds.setAttr('%s.localScaleZ' % shapes[0], 0)

            attr.hide_attributes(shapes[0], ['localPosition', 'localScale'])
            shapes = cmds.parent(shapes[0], self.joints[0], r=True, s=True)
            cmds.delete(locator)
            shapes[0] = cmds.rename(shapes[0], core.inc_name(node_name))

        joint_shape = shapes[0]

        if not cmds.objExists('%s.%s' % (joint_shape, name)):
            cmds.addAttr(joint_shape, ln=name, k=True, min=0)

        if not attr.is_connected('%s.switch' % self.joints[0]):
            cmds.connectAttr('%s.%s' % (joint_shape, name), '%s.switch' % self.joints[0])

        max_value = cmds.attributeQuery('switch', max=True, node=self.joints[0])[0]

        try:
            test_max = cmds.attributeQuery(name, max=True, node=joint_shape)[0]

            if max_value < test_max:
                max_value = test_max
        except:
            pass

        cmds.addAttr('%s.%s' % (joint_shape, name), edit=True, maxValue=max_value)

        cmds.setAttr('%s.%s' % (joint_shape, name), max_value)

        for control in self.controls:
            cmds.parent(shapes[0], control, add=True, s=True)

        attr.connect_message(shapes[0], self.control_group, 'switch')

    def _post_create_rotate_order(self):

        for control in self.controls:
            test = ['X', 'Y', 'Z']

            count = 0

            for t in test:
                if not attr.is_locked('%s.rotate%s' % (control, t)):
                    count += 1

            if count == 3:
                cmds.setAttr('%s.rotateOrder' % control, cb=True)
                cmds.setAttr('%s.rotateOrder' % control, k=True)

    def _post_create_connect(self, inst_attribute, description):
        if hasattr(self, inst_attribute):
            value = getattr(self, inst_attribute)
            if value:
                value = vtool.util.convert_to_sequence(value)
                for inc, sub_value in enumerate(value, 1):
                    attr.connect_message(sub_value, self.control_group, '%s%s' % (description, inc))
                return value

    def _post_store_orig_matrix(self, inst_attribute):

        if hasattr(self, inst_attribute):

            value = getattr(self, inst_attribute)

            if value:
                value = vtool.util.convert_to_sequence(value)
                for sub_value in value:
                    if sub_value:
                        attr.store_world_matrix_to_attribute(sub_value, skip_if_exists=True)

                return value

    def _post_add_to_control_set(self):

        set_name = 'set_controls'

        exists = False

        if cmds.objExists(set_name) and cmds.nodeType(set_name) == 'objectSet':
            exists = True

        if not exists:

            sets = cmds.ls('%s*' % set_name, type='objectSet')

            if sets:
                set_name = sets[0]
                exists = True

            if not exists:
                cmds.sets(name=core.inc_name(set_name), empty=True)

        parent_set = set_name
        child_set = None

        for set_name in self._custom_sets:

            if set_name == parent_set:
                continue

            custom_set_name = 'set_' + set_name

            if not cmds.objExists(custom_set_name):
                custom_set_name = cmds.sets(name=custom_set_name, empty=True)

            cmds.sets(custom_set_name, addElement=parent_set)

            parent_set = custom_set_name

        if self.__class__ != Rig:
            child_set = 'set_%s' % self.description
            if self.side:
                child_set = 'set_%s_%s' % (self.description, self.side)

            if child_set != parent_set:
                if not cmds.objExists(child_set):
                    cmds.sets(name=child_set, empty=True)

                cmds.sets(child_set, add=parent_set)

        if not child_set:
            child_set = parent_set

        controls = self.get_all_controls()

        for control in controls:
            vtool.util.show('Adding %s to control sets' % control)
            cmds.sets(control, e=True, add=child_set)

    def _post_connect_controller(self):

        controller = attr.get_message_input(self.control_group, 'control1')

        if not self._pick_walk_parent:
            parent = cmds.listRelatives(self.control_group, p=True)

            if parent:
                parent = parent[0]
            else:
                return
        else:
            parent = self._pick_walk_parent

        if controller:
            if not cmds.controller(parent, q=True, isController=True):
                return

            if cmds.controller(controller, q=True, isController=True):
                cmds.controller(controller, parent, e=True, p=True)

    def _post_connect_controls_to_switch_parent(self):

        if not self._switch_parent:
            return

        controls = self.get_all_controls()

        for control in controls:
            attr.connect_message(self._switch_parent, control, 'switchParent')

    def _post_connect_sub_control_visibility(self):

        if not self._connect_sub_vis_attr:
            return

        if not self.sub_controls:
            return

        for sub_control in self.sub_controls:

            shapes = cmds.listRelatives(sub_control, shapes=True)
            for shape in shapes:

                if attr.is_connected('%s.visibility' % shape):
                    input_attribute = attr.get_attribute_input('%s.visibility' % shape, node_only=False)

                    if input_attribute.endswith('isibility'):
                        try:
                            cmds.connectAttr(self._connect_sub_vis_attr, input_attribute)
                        except:
                            pass
                else:
                    attr.connect_visibility(self._connect_sub_vis_attr, shape, self.sub_visibility)

    def __getattribute__(self, item):

        custom_functions = ['create']

        if item in custom_functions:

            if item == 'create':
                result = self._pre_create()
                if result == False:
                    return lambda *args: None

            result = object.__getattribute__(self, item)

            result_values = result()

            def results():
                return result_values

            if item == 'create':
                self._post_create()

            return results

        else:

            return object.__getattribute__(self, item)

    def _handle_side_variations(self):

        if vtool.util.is_left(self.side):
            self.side = 'L'
        if vtool.util.is_right(self.side):
            self.side = 'R'
        if vtool.util.is_center(self.side):
            self.side = 'C'

    def _create_group(self, prefix=None, description=None):

        rig_group_name = self._get_name(prefix, description)

        group = cmds.group(em=True, n=core.inc_name(rig_group_name))

        return group

    def _create_default_groups(self):

        self.control_group = self._create_control_group()
        self.setup_group = self._create_setup_group()

        self._create_control_group_attributes()

        cmds.hide(self.setup_group)

        self._parent_default_groups()
        self._setup_default_groups()

    def _parent_default_groups(self):

        self._parent_custom_default_group(self.control_group, self.control_parent)
        self._parent_custom_default_group(self.setup_group, self.setup_parent)

    def _setup_default_groups(self):

        attr.create_title(self.control_group, 'vetala')
        cmds.addAttr(self.control_group, ln='controlVisibility', at='bool', k=True, dv=1)
        cmds.addAttr(self.control_group, ln='subVisibility', at='bool', k=True, dv=1)
        cmds.addAttr(self.control_group, ln='size', at='double3', k=True)
        cmds.addAttr(self.control_group, ln='sizeX', at='double', p='size', k=True, dv=1)
        cmds.addAttr(self.control_group, ln='sizeY', at='double', p='size', k=True, dv=1)
        cmds.addAttr(self.control_group, ln='sizeZ', at='double', p='size', k=True, dv=1)

        decompose = cmds.createNode('decomposeMatrix', n=core.inc_name('%s_decompose_scale' % self.control_group))

        cmds.connectAttr('%s.worldMatrix' % self.control_group, '%s.inputMatrix' % decompose)
        cmds.connectAttr('%s.outputScaleX' % decompose, '%s.sizeX' % self.control_group)
        cmds.connectAttr('%s.outputScaleY' % decompose, '%s.sizeY' % self.control_group)
        cmds.connectAttr('%s.outputScaleZ' % decompose, '%s.sizeZ' % self.control_group)

    def _parent_custom_default_group(self, group, custom_parent):

        if not group or not custom_parent:
            return

        if not cmds.objExists(group):
            return
        if not cmds.objExists(custom_parent):
            vtool.util.warning('%s does not exist to be a parent.' % custom_parent)
            return

        parent = cmds.listRelatives(group, p=True)
        if parent:
            if custom_parent == parent[0]:
                return

        try:

            cmds.parent(group, custom_parent)

        except:
            pass

    def _create_setup_group(self, description=''):

        group = self._create_group('setup', description)

        if self.setup_group:
            cmds.parent(group, self.setup_group)

        return group

    def _create_control_group(self, description=''):

        group = self._create_group('controls', description)

        if self.control_group:
            cmds.parent(group, self.control_group)

        return group

    def _create_control_group_attributes(self):

        cmds.addAttr(self.control_group, ln='rigControlGroup', at='bool', dv=True)
        cmds.setAttr('%s.rigControlGroup' % self.control_group, l=True)

        cmds.addAttr(self.control_group, ln='description', dt='string')
        cmds.setAttr('%s.description' % self.control_group, self.description, type='string', l=True)

        cmds.addAttr(self.control_group, ln='side', dt='string')
        side = self.side
        if not side:
            side = ''
        cmds.setAttr('%s.side' % self.control_group, side, type='string', l=True)

    def _get_name(self, prefix=None, description=None, sub=False):

        name_list = [prefix, self.description, description, '1', self.side]

        filtered_name_list = []

        for name in name_list:
            if name:
                filtered_name_list.append(str(name))

        name = '_'.join(filtered_name_list)

        return name

    def _get_control_name(self, description=None, sub=False):

        current_process = os.environ.get('VETALA_CURRENT_PROCESS')

        if current_process:
            control_inst = util_file.ControlNameFromSettingsFile(current_process)

            if sub == False:
                control_inst.set_number_in_control_name(self._control_number)

            self._control_inst = control_inst

            if description:
                description = self.description + '_' + description
            else:
                description = self.description

            if sub == True:
                description = 'sub_%s' % description

            control_name = control_inst.get_name(description, self.side)

        if not current_process:

            prefix = 'CNT'
            if sub:
                prefix = 'CNT_SUB'

            control_name = self._get_name(prefix, description, sub=sub)

            control_name = control_name.upper()

        control_name = core.inc_name(control_name)

        return control_name

    def _create_control(self, description=None, sub=False, curve_type=None):

        control = rigs_util.Control(self._get_control_name(description, sub))

        cmds.parent(control.control, self.control_group)

        if curve_type:
            control.set_curve_type(curve_type)

        side = self.side

        if not side:
            side = 'C'

        if not self._set_sub_control_color_only:
            control.color(attr.get_color_of_side(side, sub))
        if self._set_sub_control_color_only:
            control.color(attr.get_color_of_side(side, True))

        if self.control_color is not None and self.control_color >= 0 and not sub:
            control.color(self.control_color)

        if self.sub_control_color is not None\
                and not isinstance(self.sub_control_color, list)\
                and self.sub_control_color >= 0 and sub:
            control.color(self.sub_control_color)

        control.hide_visibility_attribute()

        if self.control_shape and not curve_type:

            control.set_curve_type(self.control_shape)

            if sub:
                if self.sub_control_shape:
                    control.set_curve_type(self.sub_control_shape)

        if not sub:

            control.scale_shape(self.control_size,
                                self.control_size,
                                self.control_size)

            for shape in control.shapes:
                cmds.connectAttr('%s.controlVisibility' % self.control_group, '%s.lodVisibility' % shape)

        if sub:

            size = self.control_size * self.sub_control_size

            control.scale_shape(size,
                                size,
                                size)

            for shape in control.shapes:
                cmds.connectAttr('%s.subVisibility' % self.control_group, '%s.lodVisibility' % shape)

        if not sub:
            self.controls.append(control.get())

        if sub:
            self.sub_controls.append(control.get())
            if not self._sub_controls_with_buffer:
                self._sub_controls_with_buffer.append(control.get())
            else:
                self._sub_controls_with_buffer[-1] = control.get()
        else:
            self._sub_controls_with_buffer.append(None)

        if self.control_offset_axis:

            if self.control_offset_axis == 'x':
                control.rotate_shape(90, 0, 0)

            if self.control_offset_axis == 'y':
                control.rotate_shape(0, 90, 0)

            if self.control_offset_axis == 'z':
                control.rotate_shape(0, 0, 90)

            if self.control_offset_axis == '-x':
                control.rotate_shape(-90, 0, 0)

            if self.control_offset_axis == '-y':
                control.rotate_shape(0, -90, 0)

            if self.control_offset_axis == '-z':
                control.rotate_shape(0, 0, -90)

        self.control_dict[control.get()] = {}

        if self.hue is not None and sub != True:
            control.set_color_hue(self.hue)

        if self.sub_hue is not None and sub == True:
            control.set_color_hue(self.sub_hue)

        if self.saturation is not None and sub == False:
            control.set_color_saturation(self.saturation)

        if self.color_value is not None and sub == False:
            control.set_color_value(self.color_value)

        if self.hue_inc:
            if self.hue:
                self.hue += self.hue_inc

        if self.saturation_inc and not sub:
            self.saturation += self.saturation_inc

        if self.color_value_inc and not sub:
            self.color_value += self.color_value_inc

        return control

    def _connect_sub_visibility(self, control_and_attr, sub_control):

        shapes = cmds.listRelatives(sub_control, shapes=True)

        for shape in shapes:
            attr.connect_visibility(control_and_attr, shape, self.sub_visibility)

    def set_control_shape(self, shape_name):
        """
        Sets the look of the controls, based on predefined names.
        """

        self.control_shape = shape_name

    def set_sub_control_shape(self, shape_name):
        """
        Sets the look of the curve for the sub controls.

        """

        self.sub_control_shape = shape_name

    def set_control_color(self, color):
        """
        Set the color of the control based on an integer value.
        """

        self.control_color = color

    def set_sub_control_color(self, color):
        """
        Set the color of sub controls.
        """

        self.sub_control_color = color

    def set_sub_control_color_only(self, bool_value):
        """
        Makes main controls use the same color has sub controls.
        """
        self._set_sub_control_color_only = bool_value

    def set_control_size(self, float_value):
        """
        Sets the default size of the control curve.
        """

        if float_value == 0:
            vtool.util.warning('Setting control size to zero!')

        self.control_size = float_value

    def set_sub_control_size(self, float_value):
        """
        Sets the default size of the sub control curve.
        """

        self.sub_control_size = float_value

    def set_control_parent(self, parent_transform):
        """
        Sets the parent of the control group for this rig.
        This usually should get run after create.
        """

        self.control_parent = parent_transform

        self._parent_custom_default_group(self.control_group, self.control_parent)

    def set_setup_parent(self, parent_transform):
        """
        Sets the parent of the setup group for this rig.
        This usually should get run after create.
        """

        self.setup_parent = parent_transform

        self._parent_custom_default_group(self.setup_group, self.setup_parent)

    def set_switch_parent(self, rig_control_group):
        """
        This is used for IK/FK matching. This could be used to allow the hands to be associated with the IK/FK switching of the arm.
        """
        self._switch_parent = rig_control_group

    def set_control_offset_axis(self, axis_letter):
        """
        This sets the axis that the control curve cvs will offset to. This happens by rotating the control in 90 degrees on the axi.
        This is good for lining up the control cvs to a different axis than its default.

        Args:
            axis_letter (str): The letter of the axis to offset the control cvs around. 'x', 'y' or 'z'

        """
        self.control_offset_axis = axis_letter.lower()

    def set_control_color_hue(self, value):
        """
        Using HSV this sets the hue component for the controls.
        """
        self.hue = value

    def set_sub_control_color_hue(self, value):
        """
        Using HSV this sets the hue component for the sub controls.
        """
        self.sub_hue = value

    def set_control_color_increment_hue(self, value):
        """
        Using HSV this increments (.1) or decrements (-.1) the hue component of controls as they are created.
        This allows for things like FK control chains to get progressively darker/lighter.
        """
        self.hue_inc = value

    def set_control_color_saturation(self, value):
        """
        Using HSV this sets the saturation component for the controls.
        """
        self.saturation = value

    def set_control_color_value(self, value):
        """
        Using HSV this sets the value component for the controls.
        """
        self.color_value = value

    def set_control_color_increment_saturation(self, value):
        """
        Using HSV this increments (.1) or decrements (-.1) the saturation component of controls as they are created.
        This allows for things like FK control chains to get progressively darker/lighter.
        """
        self.saturation_inc = value

    def set_control_color_increment_value(self, value):
        """
        Using HSV this increments (.1) or decrements (-.1) the value component of controls as they are created.
        This allows for things like FK control chains to get progressively darker/lighter.
        """
        self.color_value_inc = value

    def set_sub_visibility(self, bool_value):
        """
        This controls whether sub controls are visible by default after building the rig.

        Args:
            bool_value (bool)
        """
        self.sub_visibility = bool_value

    def set_connect_important(self, bool_value):
        self._connect_important = bool_value

    def set_number_in_control_name(self, bool_value):
        """
        By default, controls are named with a number.
        For example: "CNT_DEFAULT_1_L"
        If this is set to false, the name would become:
        "CNT_DEFAULT_L"
        This helps simplify control names especially for major controls.
        """
        self._control_number = bool_value

    def set_no_last_number(self, bool_value):
        """
        By default, controls are named with a number.
        For example: "CNT_DEFAULT_1_L"
        If this is set to false, the name would become:
        "CNT_DEFAULT_L"
        This helps simplify control names especially for major controls.
        """

        self._control_number = bool_value

    def set_pick_walk_parent(self, control_name):
        """
        Some rig classes support pick walking.
        When pick walking gets to the first control, it will then navigate to the control specified here.
        """
        self._pick_walk_parent = control_name

    def set_control_set(self, list_of_set_names):
        """
        This will create the sets if they don't already exist.
        This will put all the controls generated under the last set name in the list
        """

        self._custom_sets = vtool.util.convert_to_sequence(list_of_set_names)

    def connect_sub_visibility(self, attr_name):
        """
        This connects the subVisibility attribute to the specified attribute.  Good when centralizing the sub control visibility.
        """
        self._connect_sub_vis_attr = attr_name

    def get_all_controls(self):
        """
        Returns all controls in the setup.
        """
        return list(self.control_dict.keys())

    def get_controls(self, title):
        """
        Get entries for every control.
        For example, title could be "xform".  It would return all the xform nodes.
        """

        entries = []

        for control in self.controls:
            if title in self.control_dict[control]:
                entries.append(self.control_dict[control][title])

        return entries

    def get_sub_controls(self, title):
        """
        Get entries for every sub control.
        For example, title could be "xform".  It would return all the xform nodes.
        """

        entries = []

        for control in self.sub_controls:
            if title in self.control_dict[control]:
                entries.append(self.control_dict[control][title])

        return entries

    def create(self):
        """
        Create the rig.  Set commands must be set before running this.
        """

    def delete_setup(self):
        """
        This will delete the setup group.
        """

        self._delete_setup = True

        if not self._created:
            return

        if cmds.objExists(self.setup_group):

            if core.is_empty(self.setup_group):
                parent = cmds.listRelatives(self.setup_group, p=True)

                if parent:
                    vtool.util.warning('Setup group was parented. Skipping deletion.')

                if not parent:
                    cmds.delete(self.setup_group)
                    return
            if core.is_empty(self.setup_group) and self._delete_setup:
                vtool.util.warning('Setup group is not empty. Skipping deletion.')
                self._delete_setup = False
                return

        if not cmds.objExists(self.setup_group) and self._delete_setup:
            vtool.util.warning('Setup group does not exist. Skipping deletion.')

        if self._delete_setup:
            vtool.util.warning('Could not delete setup group. rig: %s side: %s of class: %s' % (
                self.description, self.side, self.__class__.__name__))


class JointRig(Rig):
    """
    Joint rig class adds attaching buffer chain functionality.
    Also, the ability to specify a joint chain for a rig.

    """

    attach_type_constraint = 0
    attach_type_matrix = 1

    def __init__(self, description, side=None):
        super(JointRig, self).__init__(description, side)

        self._switch_shape_node_name = None
        self.joints = []

        self.attach_joints = True
        self.auto_control_visibility = True

        self._switch_shape_attribute_name = None
        self._attach_type = 0

        self.joint_name_token = 'joint'

    def _pre_create(self):
        super(JointRig, self)._pre_create()
        vtool.util.show('Using joints:%s' % self.joints)

        if not self.joints:
            vtool.util.warning('No joints passed. Nothing to build')
            return False

    def _attach_joints(self, source_chain, target_chain):

        if not self.joints:
            return

        if not self.attach_joints:
            return

        attach = space.AttachJoints(source_chain, target_chain)
        attach.set_attach_type(self._attach_type)
        attach.create()

        if cmds.objExists('%s.switch' % target_chain[0]):
            switch = rigs_util.RigSwitch(target_chain[0])

            weight_count = switch.get_weight_count()

            if weight_count > 0:
                if self.auto_control_visibility:
                    switch.add_groups_to_index((weight_count - 1), self.control_group)

                switch.create()

    def _check_joints(self, joints):

        for joint in joints:
            if cmds.nodeType(joint) == 'joint':
                continue

            if cmds.nodeType(joint) == 'transform':
                continue

            vtool.util.show(
                '%s is not a joint or transform. %s may not build properly.' % (joint, self.__class__.__name__))

    def set_joints(self, joints):
        """
        Set the joints that the rig should work on.

        Args:
            joints (list): Joints by name.
        """

        joints = vtool.util.convert_to_sequence(joints)

        self.joints = joints
        self.buffer_joints = joints

        self._check_joints(self.joints)

    def set_attach_joints(self, bool_value):
        """
        Turn off/on joint attaching.

        Args:
            bool_value (bool): Whether to attach joints.
        """

        self.attach_joints = bool_value

    def set_attach_type(self, attach_type):

        self._attach_type = attach_type

    def set_auto_switch_visibility(self, bool_value):
        """
        When attaching more than one joint chain.
        This will attach the control group visibility to the switch attribute on the first joint.
        """

        self.auto_control_visibility = bool_value

    def set_add_switch_shape(self, name_for_attribute, name_for_node=None):
        """
        Add a switch attribute, for example: ikFk

        Args:
            name_for_attribute (str) : The name to give the switch attribute upon creation. i.e. ikFk
            name_for_node (str) : The name to give the shape to be created that the attribute will live on.  i.e. settings_arm_L
        """

        self._switch_shape_attribute_name = name_for_attribute
        self._switch_shape_node_name = name_for_node

    def set_joint_name_token(self, joint_token_string):
        self.joint_name_token = joint_token_string


class BufferRig(JointRig):
    """
    Extends JointRig with ability to create buffer chains.
    The buffer chain creates a duplicate chain for attaching the setup to the main chain.
    This allows multiple rigs to be attached to the main chain.
    """

    def __init__(self, name, side=None):
        super(BufferRig, self).__init__(name, side)

        self._switch_shape_node_name = None
        self.create_buffer_joints = False
        self.build_hierarchy = False
        self._buffer_replace = ['joint', 'buffer']

    def _duplicate_joints(self):

        if not self.joints:
            return

        if self.create_buffer_joints:

            if not self._is_buffer_ready(self.joints[0]):
                vtool.util.warning(
                    'Buffer joints added to chain that was not ready. This is probably because the joint chain was rigged without set_buffer(True) in the past.')
                vtool.util.warning('')
                vtool.util.warning('Layering rigs will error.')
                vtool.util.warning('')

            if not self.build_hierarchy:
                duplicate_hierarchy = space.DuplicateHierarchy(self.joints[0])

                duplicate_hierarchy.stop_at(self.joints[-1])
                duplicate_hierarchy.only_these(self.joints)
                duplicate_hierarchy.replace(self._buffer_replace[0], self._buffer_replace[1])

                self.buffer_joints = duplicate_hierarchy.create()

            if self.build_hierarchy:
                build_hierarchy = space.BuildHierarchy()
                build_hierarchy.set_transforms(self.joints)
                build_hierarchy.set_replace(self._buffer_replace[0], self._buffer_replace[1])
                self.buffer_joints = build_hierarchy.create()

            cmds.parent(self.buffer_joints[0], self.setup_group)

        if not self.create_buffer_joints:
            self.buffer_joints = self.joints

            if self._has_buffer(self.joints[0]):
                vtool.util.warning(
                    'set_buffer(False) on a rig that has used buffer joints in the past. Consider turning on set_buffer(True)')
                vtool.util.warning('')
                vtool.util.warning('Layering rigs will error.')
                vtool.util.warning('')

            if space.has_constraint(self.joints[0]) and self.attach_joints:
                vtool.util.warning('set_buffer(False) on joints that are already constrained. ')
                vtool.util.warning('')
                vtool.util.warning('Layering rigs will error.')
                vtool.util.warning('')

        return self.buffer_joints

    def _create_before_attach_joints(self):
        return

    def _has_buffer(self, top_joint):
        if cmds.objExists('%s.switch' % top_joint):
            return True

        return False

    def _is_buffer_ready(self, top_joint):

        if cmds.objExists('%s.switch' % top_joint):
            return True

        else:
            if not space.has_constraint(top_joint):
                return True

        return False

    def set_buffer_replace(self, replace_this, with_this):

        self._buffer_replace = [replace_this, with_this]

    def set_build_hierarchy(self, bool_value):

        self.build_hierarchy = bool_value

    def set_buffer(self, bool_value, name_for_attribute=None, name_for_node=None):
        """
        Turn off/on the creation of a buffer chain.

        Args:
            bool_value (bool): Whether to create the buffer chain.
            name_for_attribute : Name to give an optional switch attribute
            name_for_node: name of a node the optional switch attribute lives on.
        """

        self.create_buffer_joints = bool_value
        self._connect_important = bool_value

        if name_for_attribute:
            self._switch_shape_attribute_name = name_for_attribute
            self._switch_shape_node_name = name_for_node

    def create(self):
        super(BufferRig, self).create()

        self._duplicate_joints()

        self._create_before_attach_joints()

        if self.create_buffer_joints and self.buffer_joints:
            self._attach_joints(self.buffer_joints, self.joints)

    def delete_setup(self):

        if self.create_buffer_joints:
            vtool.util.warning(
                'Skipping setup group deletion. The buffer is set to True and duplicate joints need to be stored under the setup.')
            self._delete_setup = False
            return

        super(BufferRig, self).delete_setup()


class CurveRig(Rig):
    """
        A rig class that accepts curves instead of joints as the base structure.
    """

    def __init__(self, description, side=None):
        super(CurveRig, self).__init__(description, side)

        self.curves = None

    def set_curve(self, curve_list):
        """
        Set the curve to rig with.

        Args:
            curve_list (str): The name of a curve.
        """
        self.curves = vtool.util.convert_to_sequence(curve_list)


class PolyPlaneRig(Rig):
    """
        A rig class that accepts curves instead of joints as the base structure.
    """

    def __init__(self, description, side=None):
        super(PolyPlaneRig, self).__init__(description, side)

        self.poly_plane = None

    def set_poly_plane(self, poly_plane):
        """
        Set the curve to rig with.

        Args:

        """
        self.poly_plane = poly_plane


class SurfaceRig(Rig):
    """
        A rig class that accepts curves instead of joints as the base structure.
    """

    def __init__(self, description, side=None):
        super(SurfaceRig, self).__init__(description, side)

        self.surfaces = None
        self.curves = None

    def set_surface(self, surface_list):
        """
        Set the curve to rig with.

        Args:
            curve_list (str): The name of a curve.
        """
        self.surfaces = vtool.util.convert_to_sequence(surface_list)

# --- Rigs


class SparseRig(JointRig):
    """
    This class create controls on joints. The controls are not interconnected.
    For example Fk rig, the controls have a parent/child hierarchy. Sparse rig does not have any hierarchy.
    This is good for a pile of leaves or tweakers on a body.
    """

    def __init__(self, description, side=None):
        super(SparseRig, self).__init__(description, side)

        self.current_inc = None
        self.respect_side_offset = None
        self.control_shape = 'cube'
        self.is_scalable = False
        self.respect_side = False
        self.respect_side_tolerance = 0.001
        self.match_scale = False

        self.use_joint_controls = False
        self.use_joint_controls_scale_compensate = False

        self.xform_rotate = None
        self.xform_scale = None

        self.control_to_pivot = False
        self._control_to_boundingbox = False
        self._control_to_boundingbox_bottom = False
        self._control_to_boundingbox_top = False
        self.follow_parent = False
        self.control_compensate = False
        self.run_function = None
        self._create_sub_control = False
        self.sub_visibility = 1
        self.keep_negative_scale = False

    def _convert_to_joints(self):

        for inc in range(0, len(self.controls)):
            control = self.controls[inc]

            control = rigs_util.Control(control)
            control.set_to_joint(scale_compensate=self.use_joint_controls_scale_compensate)

    def _position_control(self, transform_source, transform_target):

        match_space = space.MatchSpace(transform_source, transform_target)
        match_space.translation_rotation()

        if self.control_to_pivot:
            match_space.translation_to_rotate_pivot()
        if self._control_to_boundingbox:
            pos = space.get_center(transform_source)
            cmds.xform(transform_target, ws=True, t=pos)
        if self._control_to_boundingbox_bottom:
            pos = space.get_btm_center(transform_source)
            cmds.xform(transform_target, ws=True, t=pos)
        if self._control_to_boundingbox_top:
            pos = space.get_top_center(transform_source)
            cmds.xform(transform_target, ws=True, t=pos)

        match_space.scale()

    def _post_connect_controller(self):

        if not self._pick_walk_parent:
            parent = cmds.listRelatives(self.control_group, p=True)

            if parent:
                parent = parent[0]
                if not cmds.controller(parent, q=True, isController=True):
                    return
        else:
            parent = self._pick_walk_parent

        for control in self.controls:

            if cmds.controller(control, q=True, isController=True):
                cmds.controller(control, parent, e=True, p=True)

    def set_scalable(self, bool_value, keep_negative_scale_on_joint=False):
        """
        Turn off/on the ability for controls to scale the joints.

        Args:
            bool_value (bool): Whether to open the scale attributes of the controls.
            keep_negative_scale_on_joint (bool): TODO: Fill description.
        """

        self.is_scalable = bool_value

        self.keep_negative_scale = keep_negative_scale_on_joint

    def set_respect_side(self, bool_value, tolerance=0.001, center_line_offset=0):
        """
        Respecting side will change the color of controls based on their position along the X coordinate.
        Less than x will be red. Greater than x will be blue.
        Inside the center axis will be yellow.
        This will also change the naming of the control.
        The end suffix letter will change to L, R or C depending on where it is in space.

        Args:
            bool_value (bool): Whether to have the control respect side by changing name and color.
            tolerance (float): The value a control needs to be away from the center before it has a side.
            center_line_offset (int): TODO: Fill description.
        """

        self.respect_side = bool_value
        self.respect_side_tolerance = tolerance
        self.respect_side_offset = center_line_offset

    def set_match_scale(self, bool_value):
        """
        Match the size of the control to the scale of the joint.

        Args:
            bool_value (bool): Whether to match the control to the scale of the joint.
        """

        self.match_scale = bool_value

    def set_use_joint_controls(self, bool_value, scale_compensate=False):

        self.use_joint_controls = bool_value
        self.use_joint_controls_scale_compensate = scale_compensate

    def set_xform_values(self, rotate=None, scale=None):
        """
        This is good for mirroring control behavior
        """

        if rotate is None:
            rotate = [0, 180, 0]
        if scale is None:
            scale = [1, 1, -1]
        self.xform_rotate = rotate
        self.xform_scale = scale

    def set_control_to_pivot(self, bool_value):
        """
        This will build the control at the pivot point of the joint or transform supplied with set_joints()
        """
        self.control_to_pivot = bool_value

    def set_control_to_bounding_box_center(self, bool_value):
        self._control_to_boundingbox = bool_value

    def set_control_to_bounding_box_bottom(self, bool_value):
        self._control_to_boundingbox_bottom = bool_value

    def set_control_to_bounding_box_top(self, bool_value):
        self._control_to_boundingbox_top = bool_value

    def set_follow_parent(self, bool_value):

        self.follow_parent = bool_value

    def set_control_compensate(self, bool_value):
        """
        This feeds the translation of the control into a group above using a negative offset.
        Good if the control is attached to a mesh that it affects using a rivet.
        """
        self.control_compensate = bool_value

    def set_run_after_increment(self, function):
        """
        function will get passed the current control and current transform.
        """

        self.run_function = function

    def set_create_sub_control(self, bool_value):
        self._create_sub_control = bool_value

    def create(self):

        super(SparseRig, self).create()

        inc = 0
        self.current_inc = 0

        if not self.joints:
            vtool.util.warning('No joints given.')
            return

        for joint in self.buffer_joints:

            control = self._create_control()

            control_name = control.get()

            xform = space.create_xform_group(control.get())
            driver = space.create_xform_group(control.get(), 'driver')

            if self.control_compensate:
                offset = space.create_xform_group(control_name, 'offset')

                attr.connect_translate_multiply(control_name, offset, -1)

            self._position_control(joint, xform)

            if self.respect_side:

                sub = False
                if self._set_sub_control_color_only:
                    sub = True

                side = control.color_respect_side(sub=sub, center_tolerance=self.respect_side_tolerance,
                                                  offset=self.respect_side_offset)

                if side != 'C':
                    control_data = self.control_dict[control_name]
                    self.control_dict.pop(control_name)

                    new_name = self._control_inst.get_name(self.description, side)

                    control_name = rigs_util.rename_control(control_name, new_name)

                    xform = space.get_xform_group(control_name)
                    driver = space.get_xform_group(control_name, 'driver')

                    control = rigs_util.Control(control_name)

                    self.control_dict[control_name] = control_data

                    self.controls[-1] = control_name

            if self.match_scale:
                const = cmds.scaleConstraint(joint, xform)
                cmds.delete(const)

            sub = False
            if self._create_sub_control:
                sub = self._create_control(sub=True)

                cmds.parent(sub.control, control.control, r=True)

                self._connect_sub_visibility('%s.subVisibility' % control.get(), sub.get())

            if self.attach_joints:
                const_control = control_name

                if sub:
                    const_control = sub.control

                maintain_offset = True
                if space.world_matrix_equivalent(const_control, joint):
                    maintain_offset = False

                cmds.parentConstraint(const_control, joint, mo=maintain_offset)

                if self.is_scalable:
                    if self.keep_negative_scale:
                        scale_constraint = cmds.scaleConstraint(const_control, joint, mo=True)[0]
                    else:
                        scale_constraint = cmds.scaleConstraint(const_control, joint)[0]

                    if not sub:
                        space.scale_constraint_to_local(scale_constraint, self.keep_negative_scale)

            if not self.is_scalable:
                control.hide_scale_attributes()
                if sub:
                    sub.hide_scale_attributes()

            self.control_dict[control_name]['xform'] = xform
            self.control_dict[control_name]['driver'] = driver

            if self.follow_parent:
                parent = cmds.listRelatives(joint, p=True)

                if parent:
                    space.create_follow_group(parent[0], xform)

            if self.run_function:
                self.run_function(self.controls[self.current_inc], self.joints[self.current_inc])

            inc += 1
            self.current_inc = inc

        if self.use_joint_controls:
            self._convert_to_joints()


class SparseLocalRig(SparseRig):
    """
    A sparse rig that does that connects controls locally.
    This is important for cases where the controls when parented need to move separately from the rig.
    For example if the setup deformation blendshapes in before a skin cluster.
    """

    def __init__(self, description, side=None):
        super(SparseLocalRig, self).__init__(description, side)

        self.local_constraint = True
        self.local_parent = None
        self.local_xform = None
        self.connect_xform = False
        self.connect_driver = False
        self._read_locators = []
        self._read_locators_dict = {}
        self.read_locators = []
        self._loc_group = None

    def _create_read_locators(self):

        if not self._read_locators:
            return

        self._temp_loc_dict = {}

        for read_dict in self._read_locators:
            if not self._loc_group:
                group = cmds.group(em=True, n=core.inc_name(self._get_name('group', 'read_locator')))
                cmds.parent(group, self.setup_group)
                self._loc_group = group
            else:
                group = self._loc_group

            self.read_locators = []

            for joint in self.joints:

                if joint not in self._temp_loc_dict:
                    loc = cmds.spaceLocator(n=core.inc_name(self._get_name('locator', 'read')))[0]
                    self._temp_loc_dict[joint] = loc

                    cmds.pointConstraint(joint, loc)

                    xform = space.create_xform_group(loc)
                    cmds.parent(xform, group)
                    self._read_locators_dict[joint] = []

                if joint in self._temp_loc_dict:
                    loc = self._temp_loc_dict[joint]

                values = [loc, read_dict['min'], read_dict['max'], read_dict['axis']]

                self.read_locators.append(loc)
                self._read_locators_dict[joint].append(values)

    def set_local_constraint(self, bool_value):
        self.local_constraint = bool_value

    def set_local_parent(self, local_parent):
        self.local_parent = local_parent

    def set_connect_local_xform(self, bool_value):

        self.connect_xform = bool_value

    def set_connect_local_driver(self, bool_value):

        self.connect_driver = bool_value

    def set_create_position_read_locators(self, bool_value, min_value=None, max_value=None, axis='Y'):
        """
        Good to hookup of blendshapes to the translation.
        Weight attribute named weight if set_position_read_locators called once
        if called for more than one axis = weightX or weightY or weightZ
        """

        read_dict = {'min': min_value,
                     'max': max_value,
                     'axis': axis}

        self._read_locators.append(read_dict)

    def create(self):

        super(SparseRig, self).create()

        if not self.joints:
            vtool.util.warning('No joints given.')
            return

        if self._read_locators:
            self._create_read_locators()

        self.local_xform = cmds.group(em=True, n=core.inc_name('localParent_%s' % self._get_name()))
        cmds.parent(self.local_xform, self.setup_group)

        self.current_inc = 0
        inc = 0

        for joint in self.buffer_joints:

            control = self._create_control()

            control_name = control.get()

            if not self.is_scalable:
                control.hide_scale_attributes()

            xform = space.create_xform_group(control.get())
            driver = space.create_xform_group(control.get(), 'driver')

            if self.control_compensate:
                offset = space.create_xform_group(control_name, 'offset')

                attr.connect_translate_multiply(control_name, offset, -1)

            self._position_control(joint, xform)

            if self.respect_side:

                sub = False

                if self._set_sub_control_color_only:
                    sub = True

                side = control.color_respect_side(sub, center_tolerance=self.respect_side_tolerance,
                                                  offset=self.respect_side_offset)

                if side != 'C':
                    control_data = self.control_dict[control_name]
                    self.control_dict.pop(control_name)

                    new_name = self._control_inst.get_name(self.description, side)

                    control_name = rigs_util.rename_control(control_name, new_name)

                    xform = space.get_xform_group(control_name)
                    driver = space.get_xform_group(control_name, 'driver')

                    self.control_dict[control_name] = control_data

                    control = rigs_util.Control(control_name)

                    self.controls[-1] = control_name

            if not self.local_constraint:
                if not self.attach_joints:
                    xform_joint = space.create_xform_group(joint)

                    if self.local_parent:
                        cmds.parent(xform_joint, self.local_xform)

                    attr.connect_translate(control.get(), joint)
                    attr.connect_rotate(control.get(), joint)

                    attr.connect_translate(driver, joint)
                    attr.connect_rotate(driver, joint)

            if self.local_constraint:
                if self.attach_joints:
                    local_group, local_xform = space.constrain_local(control.get(), joint, use_duplicate=True,
                                                                     scale_connect=self.is_scalable)

                    if self.local_xform:
                        cmds.parent(local_xform, self.local_xform)

                    local_driver = space.create_xform_group(local_group, 'driver')

                    attr.connect_translate(driver, local_driver)
                    attr.connect_rotate(driver, local_driver)
                    attr.connect_scale(driver, local_driver)

                    if self.connect_xform:
                        attr.connect_transforms(xform, local_xform)

                    if self.connect_driver:
                        attr.connect_transforms(driver, local_driver)

                    if not self.local_xform:
                        cmds.parent(local_xform, self.setup_group)

            if not self.attach_joints:
                attr.connect_scale(control.get(), joint)

            if self.read_locators:
                # loc, read_dict['min'], read_dict['max'], read_dict['axis']

                for values in self._read_locators_dict[joint]:
                    locator, read_min, read_max, read_axis = values

                    if not cmds.objExists('%s.readLocator' % self.controls[inc]):
                        attr.connect_message(locator, self.controls[inc], 'readLocator')

                    read_axis = read_axis.upper()

                    attribute = 'weight%s' % read_axis

                    if len(self._read_locators_dict[joint]) == 1:
                        attribute = 'weight'

                    if read_min is not None and read_max is not None:
                        cmds.addAttr(joint, ln=attribute, at='float', dv=0, min=read_min, max=read_max)

                    if read_max is not None:
                        anim.quick_driven_key('%s.translate%s' % (locator, read_axis), '%s.%s' % (joint, attribute),
                                              [0, read_max], [0, -1])
                    if read_min is not None:
                        anim.quick_driven_key('%s.translate%s' % (locator, read_axis), '%s.%s' % (joint, attribute),
                                              [0, read_min], [0, 1])

            if self.run_function:
                self.run_function(self.controls[self.current_inc], self.joints[self.current_inc])

            self.current_inc = inc
            inc += 1

        if self.local_parent:
            space.create_follow_group(self.local_parent, self.local_xform)

        self.control_dict[control_name]['xform'] = xform
        self.control_dict[control_name]['driver'] = driver

        if self.use_joint_controls:
            self._convert_to_joints()


class ControlRig(Rig):
    """
    Convenience for creating controls to hold blendshape sliders.
    """

    def __init__(self, name, side=None):
        super(ControlRig, self).__init__(name, side)

        self.transforms = None
        self.control_count = 1
        self.control_shape_types = {}
        self.control_descriptions = {}
        self.only_translate = False
        self.no_channels = False

    def set_transforms(self, transforms):
        """
        Set transforms where controls should be created.
        """
        self.transforms = transforms

    def set_control_count_per_transform(self, int_value):
        """
        Set the number of controls per transform.
        """
        self.control_count = int_value

    def set_control_shape(self, index, shape_name):
        """
        Set the control shape at the index.
        Corresponds to set_control_count_per_transform.
        """
        self.control_shape_types[index] = shape_name

    def set_control_description(self, index, description):
        """
        Set the description of the control at the index.
        Corresponds to set_control_count_per_transform.
        """
        self.control_descriptions[index] = description

    def set_only_translate_channels(self, bool_value):
        self.only_translate = bool_value

    def set_no_channels(self, bool_value):
        self.no_channels = bool_value

    def create(self):
        super(ControlRig, self).create()
        if not self.transforms:
            self.transforms = [None]

        self.transforms = vtool.util.convert_to_sequence(self.transforms)

        for transform in self.transforms:
            for inc in range(0, self.control_count):

                description = None
                if inc in self.control_descriptions:
                    description = self.control_descriptions[inc]

                control = self._create_control(description)

                if transform:
                    space.MatchSpace(transform, control.get()).translation_rotation()

                if inc in self.control_shape_types:
                    control.set_curve_type(self.control_shape_types[inc])

                control.scale_shape(self.control_size, self.control_size, self.control_size)

                space.create_xform_group(control.get())

                if self.only_translate:
                    control.hide_scale_attributes()
                    control.hide_rotate_attributes()

                if self.no_channels:
                    control.hide_attributes()


class GroundRig(JointRig):
    """
    Create a ground and sub controls
    """

    def __init__(self, name, side=None):
        super(GroundRig, self).__init__(name, side)

        self.control_shape = 'square_point'
        self.control_size = 1
        self.sub_control_size = .9
        self.scalable = False

    def _pre_create(self):
        super(JointRig, self)._pre_create()
        vtool.util.show('Using joints:%s' % self.joints)

    def set_joints(self, joints=None):
        super(GroundRig, self).set_joints(joints)

    def set_control_size(self, float_value):
        super(GroundRig, self).set_control_size(float_value * 40)

    def set_scalable(self, bool_value):
        self.scalable = bool_value

    def create(self):

        super(GroundRig, self).create()

        scale = self.sub_control_size
        last_control = None

        controls = []

        first_control = None

        for inc in range(0, 3):

            if inc == 0:
                control = self._create_control()

                first_control = control.get()

            if inc > 0:
                control = self._create_control(sub=True)

                self._connect_sub_visibility('%s.subVisibility' % first_control, control.get())

            controls.append(control.get())

            if inc > 1:
                control.scale_shape(scale, scale, scale)
                scale *= 0.9

            if last_control:
                cmds.parent(control.get(), last_control)

            last_control = control.get()

            if not self.scalable:
                control.hide_scale_and_visibility_attributes()
            if self.scalable:
                control.hide_visibility_attribute()

        if self.joints:
            xform = space.create_xform_group(controls[0])
            space.MatchSpace(self.joints[0], xform).translation_rotation()

        if self.joints:
            if self.attach_joints:
                cmds.parentConstraint(control.get(), self.joints[0])
                if self.scalable:
                    cmds.scaleConstraint(control.get(), self.joints[0])

# --- FK


class FkRig(BufferRig):
    """
    This is a great simple setup for appendages like fingers or arms.
    """

    def __init__(self, name, side=None):
        super(FkRig, self).__init__(name, side)
        self.last_control = ''
        self.control = ''

        self.current_xform_group = ''
        self.control_size = 3
        self.sub_control_size = .9

        self.transform_list = []
        self.drivers = []
        self.current_increment = None

        self.parent = None

        self.connect_to_driver = None
        self.match_to_rotation = True

        self.create_sub_controls = False
        self.nice_sub_naming = False
        self.use_joint_controls = False
        self.use_joint_controls_scale_compensate = False

        self.hide_sub_translates = True

        self.skip_controls = []
        self.offset_rotation = []
        self.inc_offset_rotation = {}
        self._runtime_hierarchy = {}

        self._use_hier_parent = False
        self._use_hier_color = False
        self._use_hier_name = False
        self._use_hier_size = False
        self._use_hier_size_offset = 0.8
        self._use_hier_color_offset = 0.7
        self.use_hierarchy_dict = {}

        self._skip_childless_joints = False

        self.sub_control_count = 2

    def _create_control(self, description='', sub=False, curve_type=''):

        orig_side = self.side

        if self._use_hier_name:
            transform = self.current_transform
            transform = core.get_basename(transform, remove_attribute=True)
            transform = transform.replace(self.joint_name_token, '')
            transform = vtool.util.replace_last_number(transform, '')

            transform, side = vtool.util.remove_side(transform)
            if side:
                side_code = vtool.util.get_side_code(side)

                self.side = side_code

            if transform.endswith('_'):
                transform = transform[:-1]
            if transform.startswith('_'):
                transform = transform[1:]
            if transform.find('__'):
                transform.replace('__', '_')

            if description:
                description = description + '_' + transform
            else:
                description = transform

        control = super(FkRig, self)._create_control(description, sub, curve_type)

        if self._use_hier_name:
            self.side = orig_side
            joint_key = self.joints[self.current_increment]
            joint_uuid = core.get_uuid(joint_key)
            self.use_hierarchy_dict[joint_uuid] = control.get_uuid()

        if not sub:
            self.last_control = self.control
            self.control = control

        self._set_control_attributes(control)

        xform = space.create_xform_group(control.get())
        driver = space.create_xform_group(control.get(), 'driver')

        if not sub:
            self.current_xform_group = xform

        self.control_dict[control.get()]['xform'] = xform
        self.control_dict[control.get()]['driver'] = driver

        if not sub:
            self.drivers.append(driver)

        if self.create_sub_controls and not sub:

            subs = []
            sub_scale_offset = 0.1
            sub_scale = 1

            for inc in range(0, self.sub_control_count):

                if inc == 0:
                    sub_control = super(FkRig, self)._create_control(sub=True, curve_type=self.sub_control_shape)

                if inc > 0:
                    if not self.nice_sub_naming:
                        sub_control = super(FkRig, self)._create_control(description='sub', sub=True,
                                                                         curve_type=self.sub_control_shape)
                    if self.nice_sub_naming:
                        sub_control = super(FkRig, self)._create_control(sub=True)
                    sub_scale -= sub_scale_offset
                    sub_control.scale_shape(sub_scale, sub_scale, sub_scale)

                if self.hide_sub_translates:
                    sub_control.hide_translate_attributes()

                sub_control.hide_scale_and_visibility_attributes()

                space.MatchSpace(control.get(), sub_control.get()).translation_rotation()

                self._connect_sub_visibility('%s.subVisibility' % control.get(), sub_control.get())

                subs.append(sub_control.get())

                if inc == 0:
                    cmds.parent(sub_control.get(), control.get())
                if inc > 0:
                    cmds.parent(sub_control.get(), self.sub_controls[-2])

            self.control_dict[control.get()]['subs'] = subs

        return control

    def _set_control_attributes(self, control):

        control.hide_scale_attributes()

    def _edit_at_increment(self, control, transform_list):
        self.transform_list = transform_list
        current_transform = transform_list[self.current_increment]

        self._all_increments(control, current_transform)

        if self.current_increment == 0:
            self._first_increment(control, current_transform)

        if self.current_increment == ((len(transform_list)) - 1):
            self._last_increment(control, current_transform)

        if self.current_increment > 0:
            self._increment_greater_than_zero(control, current_transform)

        if self.current_increment < (len(transform_list)):
            self._increment_less_than_last(control, current_transform)

        if self.current_increment < (len(transform_list)) and self.current_increment > 0:
            self._incrment_after_start_before_end(control, current_transform)

        if self.current_increment == (len(transform_list) - 1) or self.current_increment == 0:
            self._increment_equal_to_start_end(control, current_transform)

    def _all_increments(self, control, current_transform):

        match_space = space.MatchSpace(current_transform, self.control_dict[control]['xform'])

        if self.match_to_rotation:
            match_space.translation_rotation()

        if not self.match_to_rotation:
            match_space.translation()

        match_space.scale()

        match_space.translation_to_rotate_pivot()

    def _first_increment(self, control, current_transform):

        self._attach(control, current_transform)

    def _last_increment(self, control, current_transform):
        return

    def _increment_greater_than_zero(self, control, current_transform):

        self._attach(control, current_transform)

        if not self.create_sub_controls:

            if self.last_control:
                cmds.parent(self.control_dict[control]['xform'], self.last_control.get())

                cmds.controller(control, self.last_control.get(), e=True, p=True)

        if self.create_sub_controls:
            last_control = self.control_dict[self.last_control.get()]['subs'][-1]
            cmds.parent(self.control_dict[control]['xform'], last_control)

            cmds.controller(control, last_control, e=True, p=True)

    def _increment_less_than_last(self, control, current_transform):
        return

    def _increment_equal_to_start_end(self, control, current_transform):
        return

    def _incrment_after_start_before_end(self, control, current_transform):
        return

    def _loop(self, transforms):

        inc = 0

        found_to_skip = []

        if self.skip_controls:
            for increment in self.skip_controls:

                found_transform = None

                try:
                    found_transform = transforms[increment]
                except:
                    pass

                if found_transform:
                    found_to_skip.append(found_transform)

        self.current_increment = 0

        for inc in range(0, len(transforms)):

            if transforms[inc] in found_to_skip:
                self.current_increment += 1
                continue

            self.current_increment = inc

            transform = transforms[inc]

            children = cmds.listRelatives(transform, type='joint')
            if not children and self._skip_childless_joints:
                continue

            self.current_transform = transform
            control = self._create_control()

            uuid = cmds.ls(transform, uuid=True)[0]
            self._runtime_hierarchy[uuid] = {}
            self._runtime_hierarchy[uuid]['control'] = control

            parent = cmds.listRelatives(transform, p=True, f=True)
            if parent:
                parent_uuid = cmds.ls(parent, uuid=True)[0]
                self._runtime_hierarchy[uuid]['parent'] = parent_uuid

            control = control.get()

            self._edit_at_increment(control, transforms)

        self._use_hier()

    def _use_hier(self):

        if not self._use_hier_parent:
            return

        for transform in self.buffer_joints:
            radius = 1

            if cmds.objExists('%s.radius' % transform):
                radius = cmds.getAttr('%s.radius' % transform)

            uuid = cmds.ls(transform, uuid=True)[0]
            if uuid not in self._runtime_hierarchy:
                continue

            hier_dict = self._runtime_hierarchy[uuid]
            parent_uuid = None
            if 'parent' in hier_dict:
                parent_uuid = hier_dict['parent']

            control = hier_dict['control']
            current_xform = self._get_control_xform_group(control.get())
            current_parent = cmds.listRelatives(current_xform, p=True)
            if current_parent:
                current_parent = current_parent[0]

            if self._use_hier_size:
                control.scale_shape(radius, radius, radius)

            if self._use_hier_color:
                color = attr.get_color_rgb(transform, as_float=True)
                control.color_rgb(*color)

            if parent_uuid in self._runtime_hierarchy:

                parent_hier_dict = self._runtime_hierarchy[parent_uuid]
                if 'control' in parent_hier_dict:

                    parent_control = parent_hier_dict['control']

                    parent_xform = self._get_control_xform_group(parent_control.get())

                    current_parent_hier = cmds.ls(parent_xform, l=True)[0]

                    if control.get() in current_parent_hier:

                        if current_parent:
                            cmds.parent(parent_xform, current_parent)

                    if parent_control.get() != current_parent:

                        input_attr = attr.get_attribute_input('%s.inverseScale' % current_xform)
                        if input_attr:
                            cmds.connectAttr('%s.scale' % parent_control.get(), '%s.inverseScale' % current_xform, f=True)
                        cmds.parent(current_xform, parent_control.get())

                    offset = 0.8
                    color_offset = .9
                    if 'offset' in parent_hier_dict:
                        offset = parent_hier_dict['offset']
                        if not offset <= 0.1:
                            offset *= self._use_hier_size_offset

                    control.scale_shape(offset, offset, offset)

                    if 'offset_color' in parent_hier_dict:
                        color_offset = parent_hier_dict['offset_color']
                        if not color_offset <= 0.1:
                            color_offset *= self._use_hier_color_offset

                    control.set_color_value(color_offset)

                    hier_dict['offset'] = offset
                    hier_dict['offset_color'] = color_offset

            elif current_parent != self.control_group:
                cmds.parent(current_xform, self.control_group)

    def _attach(self, control, target_transform):

        if not self.attach_joints:
            return

        if self.create_sub_controls:
            control = self.control_dict[control]['subs'][-1]

        xform = None

        if 'xform' in self.control_dict[control]:
            xform = self.control_dict[control]['xform']

        if xform:
            if self.offset_rotation:
                cmds.xform(xform, ro=self.offset_rotation, r=True, os=True)

            if self.current_increment in self.inc_offset_rotation:
                offset_rotation = self.inc_offset_rotation[self.current_increment]
                cmds.xform(xform, ro=offset_rotation, r=True, os=True)

        equivalent = space.world_matrix_equivalent(control, target_transform)

        maintain_offset = True
        if equivalent:
            maintain_offset = False
        cmds.parentConstraint(control, target_transform, mo=maintain_offset)

    def _convert_to_joints(self):
        for inc in range(0, len(self.controls)):
            control = self.controls[inc]

            control = rigs_util.Control(control)
            control.set_to_joint(scale_compensate=self.use_joint_controls_scale_compensate)

    def _get_control_xform_group(self, control):
        xform = space.get_xform_group(control)
        return xform

    def set_parent(self, parent):
        # CBB this needs to be replaced with self.set_control_parent

        self.parent = parent

    def set_match_to_rotation(self, bool_value):
        """
        Whether to match control to the closest joint orientation or not. If not just match to translate. Control stays oriented to world.
        Default is True.   This is only used in Fk rigs not FkCurve rigs.
        """
        self.match_to_rotation = bool_value

    def get_drivers(self):
        """
        Get the driver groups above the controls.
        """

        drivers = self.get_control_entries('driver')

        return drivers

    def set_use_joint_controls(self, bool_value, scale_compensate=False):
        """
        Whether to make the controls have a joint as their base transform node.
        """
        self.use_joint_controls = bool_value
        self.use_joint_controls_scale_compensate = scale_compensate

    def set_create_sub_controls(self, bool_value):
        """
        Whether each fk control should have sub controls.
        """
        self.create_sub_controls = bool_value

    def set_sub_control_count(self, int_value):
        if int_value < 1:
            int_value = 1
            vtool.util.warning('Sub control count must at least be 1. Setting sub control count to 1.')

        if int_value > 10:
            int_value = 10
            vtool.util.warning('Sub control limit of 10. Setting sub control count to 10.')

        self.sub_control_count = int_value

    def set_skip_controls(self, increment_list):
        """
        Set which increments are skipped.

        Args:
            increment_list (list): A list of integers. [0] will skip the first increment, [0,1] will skip the first 2 increments.
        """

        self.skip_controls = increment_list

    def set_hide_sub_translates(self, bool_value):

        self.hide_sub_translates = bool_value

    def set_nice_sub_control_naming(self, bool_value):
        """
        Nice sub control naming just increments the number of the name of the next sub control.
        So instead of CNT_SUB_THING_1_C and CNT_SUB_THING_SUB_1_C as the names, names are:
        CNT_SUB_THING_1_C and CNT_SUB_THING_2_C
        This may not be desirable in every case.
        """

        self.nice_sub_naming = bool_value

    def set_offset_rotation(self, value_list):
        """
        This will offset the controls by the rotation vector. Ex. [0,90,0] will rotate the xform group of the control 90 degrees on the Y axis.
        """
        self.offset_rotation = value_list

    def set_offset_rotation_at_inc(self, inc, value_list):
        """
        This will offset the controls by the rotation vector. Ex. [0,90,0] will rotate the xform group of the control 90 degrees on the Y axis.
        Inc starts at 0. 0 is the first control.
        """
        self.inc_offset_rotation[inc] = value_list

    def use_hierarchy_to_inform_parenting(self, bool_value):
        """
        This will activate using the hierarchy of the joints to inform control parenting.
        """
        self._use_hier_parent = bool_value

    def use_hierarchy_to_inform_color(self, bool_value):
        """
        This will activate using the color of the joints to inform control colors.
        """
        self._use_hier_color = bool_value

    def use_hierarchy_to_inform_naming(self, bool_value):
        """
        This will activate using the naming of the joints to inform control naming.
        """
        self._use_hier_name = bool_value

    def use_hierarchy_to_inform_size(self, bool_value):
        """
        This will activate using the radius of the joints to inform control size.
        """
        self._use_hier_size = bool_value

    def use_hierarchy_offset(self, size_offset=0.8, color_offset=0.7):
        """
        offsets work as a scalar where 1 does nothing and 0.8 scales down.
        """
        self._use_hier_size_offset = size_offset
        self._use_hier_color_offset = color_offset

    def set_skip_joints_with_no_children(self, bool_value):
        """
        This will completely remove end joints from getting a control or any setup.
        """
        self._skip_childless_joints = bool_value

    def create(self):

        super(FkRig, self).create()

        if self._use_hier_parent:
            self.buffer_joints = core.get_hierarchy_by_depth(self.buffer_joints)

        self._loop(self.buffer_joints)

        if self.parent:
            cmds.parent(self.control_group, self.parent)

        if self.use_joint_controls:
            self._convert_to_joints()


class FkLocalRig(FkRig):
    """
    Same as FkRig but joints get connected in instead of constrained.
    This allows the controls as a group to move separately from the joints.
    """

    def __init__(self, name, side=None):
        super(FkLocalRig, self).__init__(name, side)

        self.local_parent = None
        self.main_local_parent = None
        self.local_xform = None
        self.rig_scale = False
        self.connect_driver = False
        self.connect_xform = False

    def _attach(self, source_transform, target_transform):

        if not self.attach_joints:
            return

        local_group, local_xform = space.constrain_local(source_transform, target_transform,
                                                         scale_connect=self.rig_scale, use_duplicate=True)

        if not self.local_parent:
            self.local_xform = local_xform
            cmds.parent(local_xform, self.setup_group)

        if self.local_parent:
            cmds.parent(local_xform, self.local_parent)

        if self.connect_driver:
            driver = space.create_xform_group(local_group, 'driver')

            orig_driver = self.control_dict[source_transform]['driver']
            attr.connect_transforms(orig_driver, driver)

        if self.connect_xform:
            orig_xform = self.control_dict[source_transform]['xform']
            attr.connect_transforms(orig_xform, local_xform)

        self.local_parent = local_group

        return local_group, local_xform

    def _create_control(self, description='', sub=False, curve_type=''):

        self.last_control = self.control

        self.control = super(FkLocalRig, self)._create_control(description, sub, curve_type)

        if self.rig_scale:
            self.control.show_scale_attributes()

        if self.rig_scale:
            self.control.hide_visibility_attribute()

        return self.control

    def set_control_scale(self, bool_value):
        """
        Set whether the fk setup should be scalable at each control.
        """
        self.rig_scale = bool_value

    def set_scalable(self, bool_value):
        """
        Set whether the fk setup should be scalable at each control.
        """
        self.rig_scale = bool_value

    def set_connect_local_driver(self, bool_value):
        self.connect_driver = bool_value

    def set_connect_local_xform(self, bool_value):

        self.connect_xform = bool_value

    def set_local_parent(self, local_parent):
        self.main_local_parent = local_parent

    def create(self):
        super(FkLocalRig, self).create()

        if self.main_local_parent:
            space.create_local_follow_group(self.main_local_parent, self.local_xform)


class FkScaleRig(FkRig):
    """
    This extends FkRig so that it can be scalable at each control.
    """

    def __init__(self, name, side=None):
        super(FkScaleRig, self).__init__(name, side)
        self.last_control = ''
        self.control = ''
        self.controls = []
        self.current_xform_group = ''

    def _create_scale_offset(self, control, target_transform):

        scale_offset = cmds.group(em=True, n=core.inc_name('scaleOffset_%s' % target_transform))
        offset_scale_offset = cmds.group(em=True, n=core.inc_name('offset_scaleOffset_%s' % target_transform))

        space.MatchSpace(control, offset_scale_offset).translation_rotation()
        space.MatchSpace(target_transform, scale_offset).translation_rotation()

        cmds.parent(scale_offset, offset_scale_offset)

        space.create_xform_group(scale_offset)

        attr.connect_scale(control, offset_scale_offset)
        cmds.scaleConstraint(scale_offset, target_transform)

        cmds.parent(offset_scale_offset, self.setup_group)
        parent = cmds.listRelatives(target_transform, p=True)
        if parent:
            cmds.parent(offset_scale_offset, parent[0])

    def _attach(self, control, target_transform):

        if not self.attach_joints:
            return

        orig_control = control
        if self.create_sub_controls:
            control = self.control_dict[control]['subs'][-1]

        xform = None

        if 'xform' in self.control_dict[control]:
            xform = self.control_dict[control]['xform']

        if xform:
            was_offset = False

            if self.offset_rotation:
                cmds.xform(xform, ro=self.offset_rotation, r=True, os=True)
                self._create_scale_offset(control, target_transform)
                was_offset = True

            if self.current_increment in self.inc_offset_rotation:
                offset_rotation = self.inc_offset_rotation[self.current_increment]
                cmds.xform(xform, ro=offset_rotation, r=True, os=True)
                self._create_scale_offset(control, target_transform)
                was_offset = True

            if not was_offset:
                const = cmds.scaleConstraint(control, target_transform, mo=True)[0]
                space.scale_constraint_to_local(const)

        if not xform:
            if not attr.get_attribute_input('%s.scaleX' % target_transform, node_only=True):
                if self.create_sub_controls:
                    const = cmds.scaleConstraint(orig_control, target_transform, mo=True)[0]
                    space.scale_constraint_to_local(const)
                else:
                    const = cmds.scaleConstraint(control, target_transform, mo=True)[0]
                    space.scale_constraint_to_local(const)

        if target_transform == self.buffer_joints[-1]:
            cmds.pointConstraint(control, target_transform, mo=True)
            cmds.orientConstraint(control, target_transform, mo=True)
        else:
            maintain_offset = True
            if space.world_matrix_equivalent(control, target_transform):
                maintain_offset = False

            cmds.parentConstraint(control, target_transform, mo=maintain_offset)

    def _create_control(self, description='', sub=False, curve_type=''):
        control = super(FkScaleRig, self)._create_control(description, sub, curve_type)

        self._set_control_attributes(control)

        return self.control

    def _set_control_attributes(self, control):
        super(FkScaleRig, self)._set_control_attributes(control)

        control.show_scale_attributes()
        cmds.setAttr('%s.overrideEnabled' % control.get(), 1)

    def _edit_at_increment(self, control, transform_list):
        self.transform_list = transform_list
        current_transform = transform_list[self.current_increment]

        self._all_increments(control, current_transform)

        if self.current_increment == 0:
            self._first_increment(control, current_transform)

        if self.current_increment == ((len(transform_list)) - 1):
            self._last_increment(control, current_transform)

        if self.current_increment > 0:
            self._increment_greater_than_zero(control, current_transform)

        if self.current_increment < (len(transform_list)):
            self._increment_less_than_last(control, current_transform)

        if self.current_increment < (len(transform_list)) and self.current_increment > 0:
            self._incrment_after_start_before_end(control, current_transform)

        if self.current_increment == (len(transform_list) - 1) or self.current_increment == 0:
            self._increment_equal_to_start_end(control, current_transform)

    def _first_increment(self, control, current_transform):
        super(FkScaleRig, self)._first_increment(control, current_transform)
        if not attr.get_attribute_input('%s.scaleX' % current_transform, node_only=True):
            const = cmds.scaleConstraint(control, current_transform, mo=True)[0]
            space.scale_constraint_to_local(const)
            attr.connect_scale(control, current_transform)

    def _increment_greater_than_zero(self, control, current_transform):

        cmds.select(cl=True)

        name = self._get_name('jointFk')

        buffer_joint = cmds.joint(n=core.inc_name(name))

        cmds.setAttr('%s.overrideEnabled' % buffer_joint, 1)
        cmds.setAttr('%s.overrideDisplayType' % buffer_joint, 1)

        cmds.setAttr('%s.radius' % buffer_joint, 0)

        if not self.create_sub_controls:
            if self.last_control:
                compensate = 1
                try:
                    compensate = cmds.getAttr('%s.segmentScaleCompensate' % current_transform)
                except:
                    pass
                if compensate:
                    cmds.connectAttr('%s.scale' % self.last_control.get(), '%s.inverseScale' % buffer_joint)

        match_space = space.MatchSpace(control, buffer_joint)
        match_space.translation_rotation()

        cmds.makeIdentity(buffer_joint, apply=True, r=True)

        self._attach(control, current_transform)

        cmds.parent(self.current_xform_group, buffer_joint)

        if not self.create_sub_controls:
            if self.last_control:
                cmds.parent(buffer_joint, self.last_control.get())

                cmds.controller(control, self.last_control.get(), e=True, p=True)

        if self.create_sub_controls:
            last_control = self.control_dict[self.last_control.get()]['subs'][-1]
            cmds.parent(buffer_joint, last_control)

            cmds.controller(control, last_control, e=True, p=True)

    def _get_control_xform_group(self, control):
        xform = space.get_xform_group(control)

        parent = cmds.listRelatives(xform, p=True, type='joint', f=True)
        if parent:
            xform = parent[0]

        return xform


class FkCurlNoScaleRig(FkRig):
    """
    This extends FkRig with the ability to have a curl attribute. Good for fingers.
    """

    def __init__(self, description, side=None):
        super(FkCurlNoScaleRig, self).__init__(description, side)

        self.attribute_control = None
        self.attribute_name = None
        self.curl_description = self.description
        self.curl_axis = 'Z'

        self.skip_increments = []

        self.create_curl = True

        self.title_description = None

    def _create_control(self, description='', sub=False, curve_type=''):

        control = super(FkCurlNoScaleRig, self)._create_control(description, sub, curve_type)  # _create_control(sub)

        # TODO: Refactor
        if self.curl_axis is None:
            return control

        if sub:
            return control

        if not self.attribute_control:
            self.attribute_control = control.get()

        if self.create_curl:

            title = 'CURL'
            if self.title_description:
                title = 'CURL_%s' % self.title_description

            if not cmds.objExists('%s.%s' % (self.attribute_control, title)):
                title = attr.MayaEnumVariable(title)
                title.create(self.attribute_control)

            driver = space.create_xform_group(control.get(), 'driver2')
            self.control_dict[control.get()]['driver2'] = driver

            other_driver = self.drivers[-1]
            self.drivers[-1] = [other_driver, driver]

            if self.curl_axis != 'All':
                self._attach_curl_axis(driver)

            if self.curl_axis == 'All':
                all_axis = ['x', 'y', 'z']

                for axis in all_axis:
                    self._attach_curl_axis(driver, axis)

        return control

    def _attach_curl_axis(self, driver, axis=None):

        if self.current_increment in self.skip_increments:
            return

        if not self.attribute_name:
            description = self.curl_description
        if self.attribute_name:
            description = self.attribute_name

        if axis is None:
            var_name = '%sCurl' % description
        if axis:
            var_name = '%sCurl%s' % (description, axis.capitalize())

        if not axis:
            curl_axis = self.curl_axis
        if axis:
            curl_axis = axis.capitalize()

        curl_variable = attr.MayaNumberVariable(var_name)
        curl_variable.set_variable_type(curl_variable.TYPE_DOUBLE)
        curl_variable.create(self.attribute_control)

        curl_variable.connect_out('%s.rotate%s' % (driver, curl_axis))

        if self.current_increment and self.create_buffer_joints:
            current_transform = self.transform_list[self.current_increment]
            attr.connect_rotate(driver, current_transform)

    def set_curl_axis(self, axis_letter):
        """
        Set the axis that the curl should rotate on.

        Args:
            axis_letter (str): 'X','Y','Z'
        """
        self.curl_axis = axis_letter.capitalize()

    def set_curl_description(self, description):
        """
        The attribute name for the curl slider.

        Args:
            attribute_name (str): The name of the curl slider attribute.
        """
        self.curl_description = description

    def set_attribute_control(self, control_name):
        """
        Set the control that the curl slider should live on.

        Args:
            control_name (str): The name of a control.
        """
        self.attribute_control = control_name

    def set_attribute_name(self, attribute_name):
        """
        The attribute name for the curl slider.

        Args:
            attribute_name (str): The name of the curl slider attribute.
        """

        self.attribute_name = attribute_name

    def set_title_description(self, description):

        self.title_description = description

    def set_skip_increments(self, increments):
        """
        You can skip increments, so they don't get affected by the curl.
        Each increment corresponds to a joint set in set_joints

        Args:
            increments (list): E.g. [0], will not add curl to the control on the first joint.
        """
        self.skip_increments = increments

    def set_curl_title(self, name):
        self.title_description = name.upper()

    def set_create_curl(self, bool_value):
        self.create_curl = bool_value


class FkCurlRig(FkScaleRig):

    def __init__(self, description, side=None):
        super(FkCurlRig, self).__init__(description, side)

        self.attribute_name = None
        self.attribute_control = None
        self.curl_axis = 'Z'
        self.curl_description = self.description
        self.skip_increments = []
        self.title = 'CURL'
        self.create_curl = True

    def _create_control(self, description='', sub=False, curve_type=''):
        control = super(FkCurlRig, self)._create_control(description, sub, curve_type)

        if sub:
            return control

        if not self.attribute_control:
            self.attribute_control = control.get()

        if self.create_curl:

            attr.create_title(self.attribute_control, self.title)

            driver = space.create_xform_group(control.get(), 'driver2')
            self.control_dict[control.get()]['driver2'] = driver

            other_driver = self.drivers[-1]
            self.drivers[-1] = [other_driver, driver]

            if self.curl_axis != 'All':
                self._attach_curl_axis(driver)

            if self.curl_axis == 'All':
                all_axis = ['x', 'y', 'z']

                for axis in all_axis:
                    self._attach_curl_axis(driver, axis)

        return self.control

    def _attach_curl_axis(self, driver, axis=None):

        if self.current_increment in self.skip_increments:
            return

        if axis is None:
            var_name = '%sCurl' % self.curl_description
        if axis:
            var_name = '%sCurl%s' % (self.curl_description, axis.capitalize())

        if not axis:
            curl_axis = self.curl_axis
        if axis:
            curl_axis = axis.capitalize()

        curl_variable = attr.MayaNumberVariable(var_name)
        curl_variable.set_variable_type(curl_variable.TYPE_DOUBLE)
        curl_variable.create(self.attribute_control)

        curl_variable.connect_out('%s.rotate%s' % (driver, curl_axis))

    def set_curl_axis(self, axis_letter):
        """
        Set the axis that the curl should rotate on.

        Args:
            axis_letter (str): 'X','Y','Z'
        """
        self.curl_axis = axis_letter.capitalize()

    def set_curl_description(self, description):
        """
        The attribute name for the curl slider.

        Args:
            attribute_name (str): The name of the curl slider attribute.
        """
        self.curl_description = description

    def set_skip_increments(self, increments):
        """
        You can skip increments, so they don't get affected by the curl.
        Each increment corresponds to a joint set in set_joints

        Args:
            increments (list): E.g. [0], will not add curl to the control on the first joint.
        """
        self.skip_increments = increments

    def set_curl_skip_incrment(self, increments):

        self.set_skip_increments(increments)

    def set_attribute_control(self, control_name):
        """
        Set the control that the curl slider should live on.

        Args:
            control_name (str): The name of a control.
        """
        self.attribute_control = control_name

    def set_attribute_name(self, attribute_name):
        """
        The attribute name for the curl slider.

        Args:
            attribute_name (str): The name of the curl slider attribute.
        """

        self.attribute_name = attribute_name

    def set_curl_title(self, name):
        self.title = name.upper()

    def set_create_curl(self, bool_value):
        self.create_curl = bool_value


class SplineRibbonBaseRig(JointRig):

    def __init__(self, description, side=None):

        super(SplineRibbonBaseRig, self).__init__(description, side)

        self.orig_curve = None
        self.curve = None

        self.control_count = 2
        self.span_count = 2
        self.stretchy = True
        self.advanced_twist = True
        self.stretch_on_off = False
        self.ik_curve = None
        self.wire_hires = False
        self.last_pivot_top_value = False
        self.fix_x_axis = False

        self.closest_y = False
        self.stretch_axis = 'X'
        self.stretch_attribute_control = None
        self._buffer_replace = ['joint', 'buffer']

        self._joint_aims = []

        self._bezier = False
        self._bezier1 = None
        self._bezier2 = None
        self.bezier_curves = []

        self.ribbon = False
        self.ribbon_offset = 1
        self.ribbon_offset_axis = 'Y'
        self.follicle_ribbon = False
        self._aim_ribbon_joints = False
        self._aim_ribbon_joints_up = [0, 0, 0]
        self._aim_ribbon_joints_world_up = [0, 1, 0]
        self._ribbon_length_compensate = False
        self._ribbon_stretch_curve = None
        self._ribbon_stretch_curve_node = None
        self._ribbon_arc_length_node = None
        self.ribbon_follows = []
        self._overshoot_ribbon_stretch = True
        self._overshoot_ribbon_stretch_axis = None

        self.create_ribbon_buffer_group = False

    def _create_curve(self, span_count):

        if not self.curve:

            name = self._get_name()

            self.orig_curve = geo.transforms_to_curve(self.joints, self.span_count, name)
            cmds.setAttr('%s.inheritsTransform' % self.orig_curve, 0)

            self.curve = cmds.duplicate(self.orig_curve)[0]

            cmds.rebuildCurve(self.curve,
                              spans=span_count,
                              rpo=True,
                              rt=0,
                              end=1,
                              kr=False,
                              kcp=False,
                              kep=True,
                              kt=False,
                              d=3)

            name = self.orig_curve
            self.orig_curve = cmds.rename(self.orig_curve, core.inc_name('orig_curve'))
            self.curve = cmds.rename(self.curve, name)

            if self._bezier:
                cmds.select(self.curve)
                cmds.nurbsCurveToBezier()

            cmds.parent(self.orig_curve, self.setup_group)

            cmds.parent(self.curve, self.setup_group)

    def _create_surface(self, span_count, description=None):

        if not self._bezier:
            self.surface = geo.transforms_to_nurb_surface(self.joints, self._get_name(description=description),
                                                          spans=span_count,
                                                          offset_amount=self.ribbon_offset,
                                                          offset_axis=self.ribbon_offset_axis)
        if self._bezier:
            self.surface, self._bezier1, self._bezier2 = geo.transforms_to_nurb_surface(self.joints,
                                                                                        self._get_name(
                                                                                            description=description),
                                                                                        spans=span_count,
                                                                                        offset_amount=self.ribbon_offset,
                                                                                        offset_axis=self.ribbon_offset_axis,
                                                                                        bezier=True,
                                                                                        keep_history=True)

            self._bezier1 = cmds.rename(self._bezier1, self._get_name('bezier'))
            self._bezier2 = cmds.rename(self._bezier2, self._get_name('bezier'))

            cmds.setAttr('%s.inheritsTransform' % self._bezier1, 0)
            cmds.setAttr('%s.inheritsTransform' % self._bezier2, 0)
            cmds.parent(self._bezier1, self.setup_group)
            cmds.parent(self._bezier2, self.setup_group)

            self.bezier_curves = [self._bezier1, self._bezier2]

        cmds.setAttr('%s.inheritsTransform' % self.surface, 0)

        cmds.parent(self.surface, self.setup_group)

        max_u = cmds.getAttr('%s.minMaxRangeU' % self.surface)[0][1]
        u_value = max_u / 2.0
        curve, curve_node = cmds.duplicateCurve(self.surface + '.u[' + str(u_value) + ']', ch=True, rn=0, local=0,
                                                r=True, n=core.inc_name(self._get_name('liveCurve')))
        curve_node = cmds.rename(curve_node, self._get_name('curveFromSurface'))
        self._ribbon_stretch_curve = curve
        self._ribbon_stretch_curve_node = curve_node
        cmds.parent(curve, self.setup_group)

        if self.stretch_on_off:
            cmds.setAttr('%s.inheritsTransform' % curve, 0)

            arclen = cmds.createNode('arcLengthDimension')

            parent = cmds.listRelatives(arclen, p=True)
            cmds.parent(parent, self.setup_group)
            arclen = cmds.rename(parent, core.inc_name(self._get_name('arcLengthDimension')))

            self._ribbon_arc_length_node = arclen

            cmds.setAttr('%s.vParamValue' % arclen, 1)
            cmds.setAttr('%s.uParamValue' % arclen, u_value)
            cmds.connectAttr('%s.worldSpace' % self.surface, '%s.nurbsGeometry' % arclen)

        return self.surface

    def _create_clusters(self):

        join_ends = True

        if self.ribbon:
            if not self._bezier:
                cluster_surface = deform.ClusterSurface(self.surface, self.description)
            if self._bezier:
                cluster_surface = deform.ClusterCurve(self._bezier1, self.description)
                cluster_surface.set_other_curve(self._bezier2)
                join_ends = False

        if not self.ribbon:
            cluster_surface = deform.ClusterCurve(self.curve, self.description)
            if self._bezier:
                join_ends = False

        if self.last_pivot_top_value:
            last_pivot_end = True
        if not self.last_pivot_top_value:
            last_pivot_end = False

        cluster_surface.set_first_cluster_pivot_at_start(True)
        cluster_surface.set_last_cluster_pivot_at_end(last_pivot_end)
        cluster_surface.set_join_ends(join_ends)
        cluster_surface.create()

        if not self._bezier:
            self.clusters = cluster_surface.handles
        if self._bezier:
            clusters = cluster_surface.handles

            main_clusters = []
            extra_clusters = {}

            extra_cluster_group = self._create_setup_group('extraClusters')

            for inc in range(0, len(clusters), 3):
                main_clusters.append(clusters[inc])

                extras = []

                if inc != 0:
                    extras.append(clusters[inc - 1])
                if inc != (len(clusters) - 1):
                    extras.append(clusters[inc + 1])

                extra_clusters[clusters[inc]] = extras
                cmds.parent(extras, extra_cluster_group)

            self.clusters = main_clusters

            self._extra_bezier_clusters = extra_clusters

        cluster_group = self._create_setup_group('clusters')
        cmds.parent(self.clusters, cluster_group)

        return self.clusters

    def _create_geo(self, span_count):

        if self.ribbon:
            self._create_surface(span_count)

        if not self.ribbon:
            self._create_curve(span_count)

    def _attach_to_geo(self):
        if not self.attach_joints:
            return

        if self.ribbon:
            self._create_ribbon_ik()

        if not self.ribbon:
            self._create_spline_ik()

    def _attach_aim(self):

        last_follow = None
        last_parent = None
        last_joint = None

        for joint, ribbon_follow in zip(self.buffer_joints, self.ribbon_follows):

            child = cmds.listRelatives(ribbon_follow, type='transform')

            for c in child:
                shape_type = core.get_shape_node_type(c)

                if shape_type == 'locator':
                    child = c

            space.create_xform_group(child)

            if last_follow:
                axis = space.get_axis_aimed_at_child(last_joint)

                ribbon_rotate_up = cmds.duplicate(ribbon_follow,
                                                  po=True,
                                                  n=core.inc_name(self._get_name(prefix='rotationUp'))
                                                  )[0]
                cmds.setAttr('%s.inheritsTransform' % ribbon_rotate_up, 1)
                cmds.parent(ribbon_rotate_up, last_parent)
                space.MatchSpace(last_follow, ribbon_rotate_up).translation_rotation()

                cmds.aimConstraint(child,
                                   last_follow,
                                   aimVector=axis,

                                   upVector=self._aim_ribbon_joints_up,
                                   wut='objectrotation',
                                   wuo=ribbon_rotate_up,
                                   mo=True,
                                   wu=self._aim_ribbon_joints_world_up)[0]

            last_joint = joint
            last_follow = child
            last_parent = ribbon_follow

    def _wire_hires(self, curve):

        if self.span_count == self.control_count:
            self.ik_curve = curve
            return

        if self.wire_hires:
            self.ik_curve = cmds.duplicate(self.orig_curve)[0]
            cmds.setAttr('%s.inheritsTransform' % self.ik_curve, 1)
            self.ik_curve = cmds.rename(self.ik_curve, 'ik_%s' % curve)
            cmds.rebuildCurve(self.ik_curve,
                              ch=False,
                              spans=self.span_count,
                              rpo=True,
                              rt=0,
                              end=1,
                              kr=False,
                              kcp=False,
                              kep=True,
                              kt=False,
                              d=3)

            wire, base_curve = cmds.wire(self.ik_curve,
                                         w=curve,
                                         dds=[(0, 1000000)],
                                         gw=False,
                                         n=core.inc_name('wire_%s' % self.curve))

            cmds.setAttr('%sBaseWire.inheritsTransform' % base_curve, 1)

            return

        if not self.wire_hires:
            cmds.rebuildCurve(curve,
                              ch=True,
                              spans=self.span_count,
                              rpo=True,
                              rt=0,
                              end=1,
                              kr=False,
                              kcp=False,
                              kep=True,
                              kt=False,
                              d=3)

            self.ik_curve = curve

            return

    def _setup_stretchy(self, control):

        if not self.attach_joints:
            return

        if self.stretch_attribute_control:
            control = self.stretch_attribute_control
        if not control:
            control = self.controls[-1]

        if self.ribbon:

            if not self.follicle_ribbon and self.stretch_on_off:
                attr.create_title(control, 'STRETCH')

                self._setup_ribbon_stretchy(control)

            if self._aim_ribbon_joints:
                self._attach_aim()

        if not self.ribbon:
            if not self.stretchy:
                return

            attr.create_title(control, 'STRETCH')
            axis = self.stretch_axis
            if self.fix_x_axis:
                axis = 'X'
            rigs_util.create_spline_ik_stretch(self.ik_curve, self.buffer_joints[:-1], control, self.stretch_on_off,
                                               scale_axis=axis)

    def _setup_ribbon_stretchy(self, control):

        scale_compensate_node, blend_length = self._create_scale_compensate_node(control, self._ribbon_arc_length_node)

        motion_paths = []

        for rivet in self.rivets:
            motion_path = self._motion_path_rivet(rivet, self._ribbon_stretch_curve, blend_length)
            motion_paths.append(motion_path)

        last_axis_letter = None

        length_condition = cmds.createNode('condition', n=core.inc_name(self._get_name('length_condition')))
        cmds.setAttr('%s.operation' % length_condition, 4)

        cmds.connectAttr('%s.arcLengthInV' % self._ribbon_arc_length_node, '%s.firstTerm' % length_condition)
        cmds.connectAttr('%s.outputX' % scale_compensate_node, '%s.secondTerm' % length_condition)
        self._length_condition = length_condition

        self._input_translate_overshoot = {}

        for joint, motion in zip(self.buffer_joints[1:], motion_paths[1:]):

            if self._overshoot_ribbon_stretch == True:

                if self._overshoot_ribbon_stretch_axis:
                    axis_letter = self._overshoot_ribbon_stretch_axis
                else:
                    axis_letter = space.get_axis_letter_aimed_at_child(joint)

                if not axis_letter and last_axis_letter:
                    axis_letter = last_axis_letter
                if not axis_letter:
                    axis_letter = self.stretch_axis

                if axis_letter.startswith('-'):
                    axis_letter = axis_letter[-1]

                last_axis_letter = axis_letter

                condition = cmds.createNode('condition', n=core.inc_name(self._get_name('lock_condition')))
                cmds.setAttr('%s.operation' % condition, 3)

                cmds.connectAttr('%s.uValue' % motion, '%s.firstTerm' % condition)
                param = cmds.getAttr('%s.uValue' % motion)
                max_value = self._get_max_value(param)
                cmds.setAttr('%s.secondTerm' % condition, max_value)

                cmds.connectAttr('%s.stretchOffOn' % control, '%s.colorIfTrueR' % condition)
                cmds.setAttr('%s.colorIfFalseR' % condition, 1)

                self._blend_two_lock('%s.outColorR' % condition, joint, axis_letter)

                self._input_translate_overshoot[joint] = ['%s.outColorR' % condition, axis_letter]

    def _blend_two_lock(self, condition_attr, transform, axis_letter):

        input_axis_attr = '%s.translate%s' % (transform, axis_letter)

        input_attr = attr.get_attribute_input(input_axis_attr)
        value = cmds.getAttr(input_attr)

        blend_two = cmds.createNode('blendTwoAttr', n=core.inc_name(self._get_name('lock_length')))

        # cmds.connectAttr('%s.stretchOffOn' % control, '%s.attributesBlender' % blend_two )
        cmds.connectAttr(condition_attr, '%s.attributesBlender' % blend_two)

        cmds.setAttr('%s.input[0]' % blend_two, value)

        cmds.connectAttr(input_attr, '%s.input[1]' % blend_two)

        attr.disconnect_attribute(input_axis_attr)
        cmds.connectAttr('%s.output' % blend_two, input_axis_attr)

        return blend_two

    def _create_scale_compensate_node(self, control, arc_length_node):

        cmds.addAttr(control, ln='stretchOffOn', min=0, max=1, k=True)

        div_length = cmds.createNode('multiplyDivide', n=core.inc_name(self._get_name('normalize_length')))
        blend_length = cmds.createNode('blendTwoAttr', n=core.inc_name(self._get_name('blend_length')))

        cmds.setAttr(blend_length + '.input[1]', 1)
        cmds.connectAttr('%s.outputX' % div_length, blend_length + '.input[0]')
        cmds.connectAttr('%s.stretchOffOn' % control, '%s.attributesBlender' % blend_length)

        length = cmds.getAttr('%s.arcLengthInV' % arc_length_node)
        cmds.setAttr('%s.operation' % div_length, 2)

        mult_scale = cmds.createNode('multiplyDivide', n=core.inc_name(self._get_name('multiplyDivide_scaleOffset')))
        cmds.setAttr('%s.input1X' % mult_scale, length)
        cmds.connectAttr('%s.outputX' % mult_scale, '%s.input1X' % div_length)
        cmds.connectAttr('%s.sizeY' % self.control_group, '%s.input2X' % mult_scale)

        cmds.connectAttr('%s.arcLengthInV' % arc_length_node, '%s.input2X' % div_length)

        return mult_scale, blend_length

    def _get_max_value(self, param):
        max_value = 1.0 - (1.0 - param) * 0.1
        return max_value

    def _motion_path_rivet(self, rivet, ribbon_curve, scale_compensate_node):
        motion_path = cmds.createNode('motionPath', n=core.inc_name(self._get_name('motionPath')))
        cmds.setAttr('%s.fractionMode' % motion_path, 1)

        cmds.connectAttr('%s.worldSpace' % ribbon_curve, '%s.geometryPath' % motion_path)

        position_node = attr.get_attribute_input('%s.translateX' % rivet, node_only=True)

        param = cmds.getAttr('%s.parameterV' % position_node)

        mult_offset = cmds.createNode('multDoubleLinear', n=core.inc_name(self._get_name('multiply_offset')))
        cmds.setAttr('%s.input2' % mult_offset, param)
        cmds.connectAttr('%s.output' % scale_compensate_node, '%s.input1' % mult_offset)

        clamp = cmds.createNode('clamp', n=core.inc_name(self._get_name('clamp_offset')))

        max_value = self._get_max_value(param)
        cmds.setAttr('%s.maxR' % clamp, max_value)
        cmds.connectAttr('%s.output' % mult_offset, '%s.inputR' % clamp)

        cmds.connectAttr('%s.outputR' % clamp, '%s.uValue' % motion_path)
        cmds.connectAttr('%s.outputR' % clamp, '%s.parameterV' % position_node)

        attr.disconnect_attribute('%s.translateX' % rivet)
        attr.disconnect_attribute('%s.translateY' % rivet)
        attr.disconnect_attribute('%s.translateZ' % rivet)

        cmds.connectAttr('%s.xCoordinate' % motion_path, '%s.translateX' % rivet)
        cmds.connectAttr('%s.yCoordinate' % motion_path, '%s.translateY' % rivet)
        cmds.connectAttr('%s.zCoordinate' % motion_path, '%s.translateZ' % rivet)

        closest = cmds.createNode('closestPointOnSurface', n=core.inc_name(self._get_name('closestPoint')))

        cmds.connectAttr('%s.xCoordinate' % motion_path, '%s.inPositionX' % closest)
        cmds.connectAttr('%s.yCoordinate' % motion_path, '%s.inPositionY' % closest)
        cmds.connectAttr('%s.zCoordinate' % motion_path, '%s.inPositionZ' % closest)
        cmds.connectAttr('%s.worldSpace' % self.surface, '%s.inputSurface' % closest)

        cmds.connectAttr('%s.parameterV' % closest, '%s.parameterV' % position_node, f=True)

        return motion_path

    def _create_spline_ik(self):

        self._wire_hires(self.curve)

        if self.buffer_joints:
            joints = self.buffer_joints
        if not self.buffer_joints:
            joints = self.joints

        if self.fix_x_axis:
            duplicate_hierarchy = space.DuplicateHierarchy(joints[0])

            duplicate_hierarchy.stop_at(self.joints[-1])

            prefix = self._buffer_replace[0]
            if self.create_buffer_joints:
                prefix = self._buffer_replace[1]

            duplicate_hierarchy.replace(prefix, 'xFix')
            x_joints = duplicate_hierarchy.create()

            try:
                cmds.parent(x_joints[0], self.setup_group)
            except:
                pass

            # working here to add auto fix to joint orientation.

            for inc in range(0, len(x_joints)):

                orient = attr.OrientJointAttributes(x_joints[inc])
                orient.set_default_values()

                for joint in x_joints:
                    if joint == x_joints[0]:
                        space.orient_x_to_child(joint)
                    else:
                        space.orient_x_to_child(joint, parent_rotate=True)

            for x_joint, joint in zip(x_joints, joints):
                cmds.parentConstraint(x_joint, joint, mo=True)
                other_axis = ['Y', 'Z']
                if self.stretch_axis == 'Y':
                    other_axis = ['X', 'Z']
                if self.stretch_axis == 'Z':
                    other_axis = ['X', 'Y']
                cmds.connectAttr('%s.scaleX' % x_joint, '%s.scale%s' % (joint, self.stretch_axis))

                cmds.connectAttr('%s.scaleY' % x_joint, '%s.scale%s' % (joint, other_axis[0]))
                cmds.connectAttr('%s.scaleZ' % x_joint, '%s.scale%s' % (joint, other_axis[1]))
            # self._attach_joints(x_joints, joints)

            joints = x_joints
            self.buffer_joints = x_joints

        children = cmds.listRelatives(joints[-1])

        if children:
            cmds.parent(children, w=True)

        start_joint = joints[0]
        end_joint = joints[-1]

        handle = space.IkHandle(self._get_name())
        handle.set_solver(handle.solver_spline)
        handle.set_start_joint(start_joint)
        handle.set_end_joint(end_joint)
        handle.set_curve(self.ik_curve)
        handle = handle.create()

        self.ik_handle = handle

        if self.closest_y:
            cmds.setAttr('%s.dWorldUpAxis' % handle, 2)

        if children:
            cmds.parent(children, joints[-1])

        cmds.parent(handle, self.setup_group)

        if self.advanced_twist:
            start_locator = cmds.spaceLocator(n=core.inc_name(self._get_name('locatorTwistStart')))[0]
            end_locator = cmds.spaceLocator(n=core.inc_name(self._get_name('locatorTwistEnd')))[0]

            self.start_locator = start_locator
            self.end_locator = end_locator

            cmds.hide(start_locator, end_locator)

            match_space = space.MatchSpace(self.buffer_joints[0], start_locator)
            match_space.translation_rotation()

            match_space = space.MatchSpace(self.buffer_joints[-1], end_locator)
            match_space.translation_rotation()

            cmds.setAttr('%s.dTwistControlEnable' % self.ik_handle, 1)
            cmds.setAttr('%s.dWorldUpType' % self.ik_handle, 4)
            cmds.connectAttr('%s.worldMatrix' % start_locator, '%s.dWorldUpMatrix' % self.ik_handle)
            cmds.connectAttr('%s.worldMatrix' % end_locator, '%s.dWorldUpMatrixEnd' % self.ik_handle)

    def _create_ribbon_ik(self):

        group_name = 'rivets'

        if self.follicle_ribbon:
            group_name = 'follicles'

        rivet_group = self._create_setup_group(group_name)

        rivets = []
        follicles = []

        for joint in self.buffer_joints:

            nurb_follow = None

            buffer_group = None

            constrain = True
            transform = joint

            if self.create_ribbon_buffer_group:
                buffer_group = cmds.group(em=True, n=core.inc_name('ribbonBuffer_%s' % joint))
                xform = space.create_xform_group(buffer_group)

                space.MatchSpace(joint, xform).translation_rotation()

                constrain = False
                transform = xform

            follicle = None
            rivet = None

            if not self.follicle_ribbon:
                rivet = geo.attach_to_surface(transform, self.surface, constrain=constrain)
                nurb_follow = rivet
                cmds.setAttr('%s.inheritsTransform' % rivet, 0)
                cmds.parent(rivet, rivet_group)
                rivets.append(rivet)

                cmds.connectAttr('%s.sizeX' % self.control_group, '%s.scaleX' % rivet)
                cmds.connectAttr('%s.sizeY' % self.control_group, '%s.scaleY' % rivet)
                cmds.connectAttr('%s.sizeZ' % self.control_group, '%s.scaleZ' % rivet)

            if self.follicle_ribbon:
                follicle = geo.follicle_to_surface(transform, self.surface, constrain=constrain)
                nurb_follow = follicle
                cmds.setAttr('%s.inheritsTransform' % follicle, 0)
                cmds.parent(follicle, rivet_group)

                follicles.append(follicle)

            if buffer_group:

                if rivet:
                    cmds.parentConstraint(buffer_group, joint, mo=True)

                if follicle:
                    cmds.parentConstraint(buffer_group, joint, mo=True)

            self.ribbon_follows.append(nurb_follow)

        self.follicles = follicles
        self.rivets = rivets

    def set_advanced_twist(self, bool_value):
        """
        Whether to use spline ik top btm advanced twist.
        """
        self.advanced_twist = bool_value

    def set_stretchy(self, bool_value):
        """
        Whether the joints should stretch to match the spline ik.
        """
        self.stretchy = bool_value

    def set_stretch_on_off(self, bool_value):
        """
        Whether to add a stretch on/off attribute.
        This allows the animator to turn the stretchy effect off over time.
        """
        self.stretch_on_off = bool_value

    def set_stretch_axis(self, axis_letter):
        """
        Set the axis that the joints should stretch on.
        """
        self.stretch_axis = axis_letter

    def set_stretch_attribute_control(self, node_name):
        self.stretch_attribute_control = node_name

    def set_curve(self, curve):
        """
        Set the curve that the controls should move and the joints should follow.
        """
        self.curve = curve

    def set_bezier(self, bool_value):
        self._bezier = bool_value

    def set_ribbon(self, bool_value):
        """
        By default, the whole setup uses a spline ik. This will cause the setup to use a nurbs surface.
        If this is on, stretch options are ignored.
        """
        self.ribbon = bool_value

    def set_ribbon_offset(self, float_value):
        """
        Set the width of the ribbon.
        """
        self.ribbon_offset = float_value

    def set_ribbon_offset_axis(self, axis_letter):
        """
        Set which axis the ribbon width is offset on.

        Args:
            axis_letter (str): 'X','Y' or 'Z'
        """
        self.ribbon_offset_axis = axis_letter

    def set_ribbon_follicle(self, bool_value):
        self.follicle_ribbon = bool_value

    def set_ribbon_buffer_group(self, bool_value):
        self.create_ribbon_buffer_group = bool_value

    def set_ribbon_joint_aim(self, bool_value, up_vector=None, world_up_vector=None):
        if up_vector is None:
            up_vector = [0, 0, 0]
        if world_up_vector is None:
            world_up_vector = [0, 1, 0]
        self._aim_ribbon_joints = bool_value
        self._aim_ribbon_joints_up = up_vector
        self._aim_ribbon_joints_world_up = world_up_vector

    def set_ribbon_overshoot_stretch(self, bool_value, axis=None):
        self._overshoot_ribbon_stretch = bool_value

    def set_ribbon_overshoot_stretch_axis(self, axis_letter):
        axis_letter = str(axis_letter)
        axis_letter = axis_letter.upper()
        self._overshoot_ribbon_stretch_axis = axis_letter

    def set_last_pivot_top(self, bool_value):
        """
        Set the last pivot on the curve to the top of the curve.
        """
        self.last_pivot_top_value = bool_value

    def set_fix_x_axis(self, bool_value):
        """
        This will create a duplicate chain for the spline ik, that has the x-axis pointing down the joint.
        The new joint chain moves with the controls, and constrains the regular joint chain.
        """
        self.fix_x_axis = bool_value

    def set_closest_y(self, bool_value):
        """
        Whether to turn on Maya's closest y option, which can solve flipping in some cases.
        """
        self.closest_y = bool_value


class SimpleFkCurveRig(FkCurlNoScaleRig, SplineRibbonBaseRig):

    def __init__(self, name, side=None):
        super(SimpleFkCurveRig, self).__init__(name, side)

        self._bezier_controls_parented = False

        self.controls = []
        self.orient_controls_to_joints = False
        self.sub_controls = []
        self.sub_control_on = True
        self.sub_drivers = []
        self.stretchy = True
        self.control_count = 3
        self.advanced_twist = True
        self.stretch_on_off = False
        self.orig_curve = None
        self.curve = None
        self.ik_curve = None
        self.span_count = self.control_count
        self.wire_hires = False
        self.curl_axis = None
        self.orient_joint = None
        self.control_xform = {}
        self.control_xform_relative = True
        self.last_pivot_top_value = False
        self.fix_x_axis = False
        self.skip_first_control = False
        self.ribbon = False
        self.ribbon_offset = 1
        self.ribbon_offset_axis = 'Y'
        self.create_follows = True
        self.create_btm_follow = False
        self.closest_y = False
        self.stretch_axis = 'X'
        self.sub_control_size = .8
        self.sub_visibility = 1
        self.bezier_controls = []

    def _create_sub_control(self):

        sub_control = self._create_control(sub=True)

        return sub_control

    def _first_increment(self, control, current_transform):

        self.first_control = control

        if self.skip_first_control:
            control = rigs_util.Control(control)
            control.delete_shapes()

            rename_control = rigs_util.Control(self.controls[-1])
            rename_control.rename(self.first_control.replace('CNT_', 'ctrl_'))
            self.first_control = rename_control.control

            self.controls[-1] = rename_control.control

        if self.sub_controls:
            self.top_sub_control = self.sub_controls[0]

            if self.skip_first_control:
                control = rigs_util.Control(self.sub_controls[0])
                control.delete_shapes()
                self.top_sub_control = cmds.rename(self.top_sub_control, self.top_sub_control.replace('CNT_', 'ctrl_'))
                self.sub_controls[0] = self.top_sub_control

    def _increment_greater_than_zero(self, control, current_transform):

        cmds.parent(self.current_xform_group, self.controls[-2])

        cmds.controller(control, self.controls[-2], e=True, p=True)

    def _last_increment(self, control, current_transform):

        if not self.sub_controls:
            return

        if self.create_follows:
            space.create_follow_fade(self.controls[-1], self.sub_drivers[:-1])
            space.create_follow_fade(self.sub_controls[-1], self.sub_drivers[:-1])
            space.create_follow_fade(self.sub_controls[0], self.sub_drivers[1:])
            space.create_follow_fade(self.sub_drivers[0], self.sub_drivers[1:])

        top_driver = self.drivers[-1]

        if self.create_follows:
            if not isinstance(top_driver, list):
                space.create_follow_fade(self.drivers[-1], self.sub_drivers[:-1])

        if self.create_follows:
            if self.create_btm_follow:
                space.create_follow_fade(self.controls[0], self.sub_drivers[1:])

    def _all_increments(self, control, current_transform):

        match_space = space.MatchSpace(self.clusters[self.current_increment], self.current_xform_group)
        match_space.translation_to_rotate_pivot()

        if self.orient_controls_to_joints:

            if not self.orient_joint:
                joint = self._get_closest_joint()
            if self.orient_joint:
                joint = self.orient_joint

            match_space = space.MatchSpace(joint, self.current_xform_group)
            match_space.rotation()

        if self.sub_control_on:
            sub_control = self._create_sub_control()
            sub_control_object = sub_control
            sub_control = sub_control.get()

            xform_sub_control = self.control_dict[sub_control]['xform']

            match_space = space.MatchSpace(control, xform_sub_control)
            match_space.translation_rotation()

            self.sub_drivers.append(self.control_dict[sub_control]['driver'])

            cmds.parent(xform_sub_control, self.control.get())

            cmds.controller(sub_control, self.control.get(), e=True, p=True)

            self._connect_sub_visibility('%s.subVisibility' % control, sub_control)

            sub_control_object.hide_scale_and_visibility_attributes()

        increment = self.current_increment + 1

        if increment in self.control_xform:
            vector = self.control_xform[increment]
            cmds.move(vector[0], vector[1], vector[2], self.current_xform_group, r=self.control_xform_relative)

        attach_control = None

        if self.sub_control_on:
            attach_control = sub_control

        if not self.sub_control_on:
            attach_control = control

        cmds.parentConstraint(attach_control, self.clusters[self.current_increment], mo=True)

        if self._bezier:
            current_cluster = self.clusters[self.current_increment]
            clusters = self._extra_bezier_clusters[current_cluster]

            for cluster in clusters:
                control_inst = self._create_control('offset_%s' % (self.current_increment + 1), True)

                xform = control_inst.get_xform_group()
                space.MatchSpace(cluster, xform).translation_to_rotate_pivot()

                driver = control_inst.get_xform_group('driver')

                space.MatchSpace(control, driver).rotate_scale_pivot_to_translation()

                if not self._bezier_controls_parented:
                    attr.connect_translate(control, driver)
                    attr.connect_rotate(control, driver)
                if self._bezier_controls_parented:
                    cmds.parent(xform, control)

                cmds.parentConstraint(control_inst.get(), cluster, mo=True)

                self.bezier_controls.append(control_inst.get())

                self._connect_sub_visibility('%s.subVisibility' % control, control_inst.get())

    def _get_closest_joint(self):

        current_cluster = self.clusters[self.current_increment]
        return space.get_closest_transform(current_cluster, self.joints)

    def _loop(self, transforms):

        super(SimpleFkCurveRig, self)._loop(self.clusters)

    def _create_before_attach_joints(self):
        super(SimpleFkCurveRig, self)._create_before_attach_joints()

        self._attach_to_geo()

    def _attach_ik_spline_to_controls(self):

        if not self.attach_joints:
            return

        if self.advanced_twist:
            if hasattr(self, 'top_sub_control'):
                cmds.parent(self.start_locator, self.sub_controls[0])

            if not hasattr(self, 'top_sub_control'):
                if not self.sub_controls:
                    cmds.parent(self.start_locator, self.controls[0])
                if self.sub_controls:
                    cmds.parent(self.start_locator, self.sub_controls[0])

            if self.sub_controls:
                cmds.parent(self.end_locator, self.sub_controls[-1])
            if not self.sub_controls:
                cmds.parent(self.end_locator, self.controls[-1])

        if not self.advanced_twist and self.buffer_joints != self.joints:
            follow = space.create_follow_group(self.controls[0], self.buffer_joints[0])
            cmds.parent(follow, self.setup_group)

        if not self.advanced_twist:
            var = attr.MayaNumberVariable('twist')
            var.set_variable_type(var.TYPE_DOUBLE)
            var.create(self.controls[0])
            var.connect_out('%s.twist' % self.ik_handle)

    def set_control_xform(self, vector, inc, relative=True):
        """
        This allows a control to be moved while its being created.
        This way all the clusters and everything are still functioning properly.

        Args:
            vector [list]: Eg [0,0,0], the amount to move the control, relative to its regular position.
            inc [int]: The increment of the control. An increment of 1 would move the first control.
        """
        self.control_xform[inc] = vector
        self.control_xform_relative = relative

    def set_orient_joint(self, joint):
        """
        Set a joint to match the orientation of the controls to.

        Args:
            joint (str): The name of a joint.
        """
        self.orient_joint = joint

    def set_match_to_rotation(self):
        """
        Not used in FkCurve Rigs. Use set_orient_controls_to_joints instead.
        """
        pass

    def set_orient_controls_to_joints(self, bool_value):
        """
        Whether to match the control's orientation to the nearest joint.
        """
        self.orient_controls_to_joints = bool_value

    def set_control_count(self, int_value, span_count=None, wire_hires=False):
        """
        Set the number of controls.
        Wire hires is good for having the joints follow a well-defined curve while maintaining a small amount of controls.

        Args:
            int_value (int): The number of controls.
            span_count (int): The number of spans on the curve.
            wire_hires (bool): Whether to wire deform the hires to the control Curve. If span count doesn't match the control count.

        """

        if int_value == 0 or int_value < 2:
            int_value = 2

        self.control_count = int_value

        if not span_count:
            self.span_count = self.control_count

        if span_count:
            self.span_count = span_count
            self.wire_hires = wire_hires

    def set_sub_control(self, bool_value):
        """
        Whether to create sub controls.
        """

        self.sub_control_on = bool_value

    def set_create_sub_controls(self, bool_value):

        self.sub_control_on = bool_value

    def set_skip_first_control(self, bool_value):
        """
        This allows the setup to not have the first control.
        """
        self.skip_first_control = bool_value

    def set_create_follows(self, bool_value):
        """
        By default, the first and last controls fade influence up the sub controls of the setup.
        By setting this to False, the top and btm controls will no longer affect mid-sub controls.
        """
        self.create_follows = bool_value

    def set_create_bottom_follow(self, bool_value):
        """
        This will cause the last control in the spine to have a follow fade on sub controls up the length of the spine.
        If set_create_follows is set to False this will be ignored.
        """

        self.create_btm_follow = bool_value

    def set_bezier_controls_parented(self, bool_value):

        self._bezier_controls_parented = bool_value

    def create(self):

        self._create_geo(self.control_count - 1)
        self._create_clusters()

        super(SimpleFkCurveRig, self).create()

        if not self.ribbon:
            self._setup_stretchy(self.controls[-1])
            self._attach_ik_spline_to_controls()
        if self.ribbon:
            self._setup_stretchy(self.controls[-1])


class FkCurveRig(SimpleFkCurveRig):
    """
    This extends SimpleFkCurveRig. This is usually used for spine setups.
    """

    def __init__(self, name, side=None):
        super(FkCurveRig, self).__init__(name, side)

        self.aim_end_vectors = False

    def _create_aims(self, clusters):

        control1 = self.sub_controls[0]
        control2 = self.sub_controls[-1]

        cluster1 = clusters[0]
        cluster2 = clusters[-1]

        cmds.delete(cmds.listRelatives(cluster1, ad=True, type='constraint'))
        cmds.delete(cmds.listRelatives(cluster2, ad=True, type='constraint'))

        aim1 = cmds.group(em=True, n=core.inc_name('aimCluster_%s_1' % self._get_name()))
        aim2 = cmds.group(em=True, n=core.inc_name('aimCluster_%s_2' % self._get_name()))

        xform_aim1 = space.create_xform_group(aim1)
        xform_aim2 = space.create_xform_group(aim2)

        space.MatchSpace(control1, xform_aim1).translation()
        space.MatchSpace(control2, xform_aim2).translation()

        cmds.parentConstraint(control1, xform_aim1, mo=True)
        cmds.parentConstraint(control2, xform_aim2, mo=True)

        mid_control_id = len(self.sub_controls) / 2

        cmds.aimConstraint(self.sub_controls[mid_control_id], aim1, wuo=self.controls[0], wut='objectrotation')
        cmds.aimConstraint(self.sub_controls[mid_control_id], aim2, wuo=self.controls[-1], wut='objectrotation')

        cmds.parent(cluster1, aim1)
        cmds.parent(cluster2, aim2)

        cmds.parent(xform_aim1, xform_aim2, self.setup_group)

    def set_aim_end_vectors(self, bool_value):
        """
        Whether the first and last clusters should aim at the mid-controls
        """
        self.aim_end_vectors = bool_value

    def create(self):
        super(FkCurveRig, self).create()

        if self.aim_end_vectors:
            if not self.ribbon:
                self._create_aims(self.clusters)
            if self.ribbon:
                self._create_aims(self.ribbon_clusters)


class FkCurveLocalRig(FkCurveRig):

    def __init__(self, description, side=None):
        super(FkCurveLocalRig, self).__init__(description, side)

        self.last_local_group = None
        self.last_local_xform = None
        self.local_parent = None
        self.sub_local_controls = []

    def _all_increments(self, control, current_transform):

        match_space = space.MatchSpace(self.clusters[self.current_increment], self.current_xform_group)
        match_space.translation_to_rotate_pivot()

        if self.orient_controls_to_joints:
            closest_joint = self._get_closest_joint()

            match_space = space.MatchSpace(closest_joint, self.current_xform_group)
            match_space.rotation()

        if self.sub_control_on:

            sub_control = rigs_util.Control(self._get_control_name(sub=True))

            sub_control.color(attr.get_color_of_side(self.side, True))

            if self.control_shape:
                sub_control.set_curve_type(self.control_shape)

            sub_control_object = sub_control
            sub_control = sub_control.get()

            match_space = space.MatchSpace(control, sub_control)
            match_space.translation_rotation()

            xform_sub_control = space.create_xform_group(sub_control)
            self.sub_drivers.append(space.create_xform_group(sub_control, 'driver'))

            local_group, local_xform = space.constrain_local(sub_control, self.clusters[self.current_increment])

            self.sub_local_controls.append(local_group)

            control_local_group, control_local_xform = space.constrain_local(control, local_xform)

            if 'driver2' in self.control_dict[self.control.get()]:
                control_driver = self.control_dict[self.control.get()]['driver2']

                driver = space.create_xform_group(control_local_group, 'driver')
                attr.connect_rotate(control_driver, driver)

            cmds.parent(control_local_xform, self.setup_group)

            cmds.parent(local_xform, control_local_group)

            if self.last_local_group:
                cmds.parent(control_local_xform, self.last_local_group)

            self.last_local_group = control_local_group
            self.last_local_xform = control_local_xform

            cmds.parent(xform_sub_control, self.control.get())
            self.sub_controls.append(sub_control)

            sub_vis = attr.MayaNumberVariable('subVisibility')
            sub_vis.set_variable_type(sub_vis.TYPE_BOOL)
            sub_vis.create(control)
            sub_vis.connect_out('%sShape.visibility' % sub_control)

            sub_control_object.hide_scale_and_visibility_attributes()

        if not self.sub_control_on:
            space.constrain_local(control, self.clusters[self.current_increment])

    def _first_increment(self, control, current_transform):
        super(FkCurveLocalRig, self)._first_increment(control, current_transform)

        if self.local_parent:
            cmds.parent(self.last_local_xform, self.local_parent)

    def _create_spline_ik(self):

        self._wire_hires(self.curve)

        children = cmds.listRelatives(self.buffer_joints[-1], c=True)

        if children:
            cmds.parent(children, w=True)

        handle = space.IkHandle(self._get_name())
        handle.set_solver(handle.solver_spline)
        handle.set_curve(self.curve)
        handle.set_start_joint(self.buffer_joints[0])
        handle.set_end_joint(self.buffer_joints[-1])
        handle = handle.create()

        self.ik_handle = handle

        if children:
            cmds.parent(children, self.buffer_joints[-1])

        cmds.parent(handle, self.setup_group)

        if self.advanced_twist:
            start_locator = cmds.spaceLocator(n=core.inc_name(self._get_name('locatorTwistStart')))[0]
            end_locator = cmds.spaceLocator(n=core.inc_name(self._get_name('locatorTwistEnd')))[0]

            self.start_locator = start_locator
            self.end_locator = end_locator

            cmds.hide(start_locator, end_locator)

            match_space = space.MatchSpace(self.buffer_joints[0], start_locator)
            match_space.translation_rotation()

            match_space = space.MatchSpace(self.buffer_joints[-1], end_locator)
            match_space.translation_rotation()

            cmds.setAttr('%s.dTwistControlEnable' % handle, 1)
            cmds.setAttr('%s.dWorldUpType' % handle, 4)
            cmds.connectAttr('%s.worldMatrix' % start_locator, '%s.dWorldUpMatrix' % handle)
            cmds.connectAttr('%s.worldMatrix' % end_locator, '%s.dWorldUpMatrixEnd' % handle)

    def _attach_ik_spline_to_controls(self):

        if self.advanced_twist:
            if hasattr(self, 'top_sub_control'):
                cmds.parent(self.start_locator, self.sub_local_controls[0])

            if not hasattr(self, 'top_sub_control'):
                cmds.parent(self.start_locator, self.sub_local_controls[0])

            cmds.parent(self.end_locator, self.sub_local_controls[-1])

        if not self.advanced_twist:
            space.create_local_follow_group(self.controls[0], self.buffer_joints[0])

            var = attr.MayaNumberVariable('twist')
            var.set_variable_type(var.TYPE_DOUBLE)
            var.create(self.controls[0])
            var.connect_out('%s.twist' % self.ik_handle)

    def set_local_parent(self, parent):
        self.local_parent = parent


class IkSplineNubRig(BufferRig):
    """
    This is used for the tweaker setup.
    """

    def __init__(self, description, side=None):

        super(IkSplineNubRig, self).__init__(description, side)

        self.btm_xform = None
        self.btm_control = None
        self.top_xform = None
        self.top_control = None
        self.end_with_locator = False
        self.top_guide = None
        self.btm_guide = None

        self.bool_create_middle_control = True

        self.right_side_fix = True
        self.right_side_fix_axis = 'x'

        self.negate_right_scale = False

        self.control_shape = 'pin'

        self.control_orient = None

    def _duplicate_joints(self):

        if self.create_buffer_joints:
            duplicate_hierarchy = space.DuplicateHierarchy(self.joints[0])

            duplicate_hierarchy.stop_at(self.joints[-1])
            duplicate_hierarchy.replace('joint', 'buffer')

            self.buffer_joints = duplicate_hierarchy.create()

            cmds.parent(self.buffer_joints[0], self.setup_group)

        if not self.create_buffer_joints:
            self.buffer_joints = self.joints

        return self.buffer_joints

    def _create_twist_group(self, top_control, top_handle, top_guide):

        name = self._get_name()

        twist_guide_group = cmds.group(em=True, n=core.inc_name('guideSetup_%s' % name))
        cmds.hide(twist_guide_group)

        cmds.parent([top_guide, top_handle], twist_guide_group)

        cmds.parent(twist_guide_group, self.setup_group)

        cmds.parentConstraint(top_control, twist_guide_group, mo=True)

        self.end_locator = True

    def _create_joint_line(self, rp=False):

        name = self._get_name()

        position_top = cmds.xform(self.buffer_joints[0], q=True, t=True, ws=True)
        position_btm = cmds.xform(self.buffer_joints[-1], q=True, t=True, ws=True)

        cmds.select(cl=True)
        guide_top = cmds.joint(p=position_top, n=core.inc_name('topTwist_%s' % name))

        cmds.select(cl=True)
        guide_btm = cmds.joint(p=position_btm, n=core.inc_name('btmTwist_%s' % name))

        space.MatchSpace(self.buffer_joints[0], guide_top).rotation()

        cmds.makeIdentity(guide_top, r=True, apply=True)

        cmds.parent(guide_btm, guide_top)

        cmds.makeIdentity(guide_btm, r=True, jo=True, apply=True)

        handle = space.IkHandle(name)
        if not rp:
            handle.set_solver(handle.solver_sc)
        if rp:
            handle.set_solver(handle.solver_rp)
        handle.set_start_joint(guide_top)
        handle.set_end_joint(guide_btm)

        handle = handle.create()

        if not rp:
            cmds.setAttr('%s.poleVectorX' % handle, 0)
            cmds.setAttr('%s.poleVectorY' % handle, 0)
            cmds.setAttr('%s.poleVectorZ' % handle, 0)

        return guide_top, handle

    def _create_spline(self, follow, btm_constrain, mid_constrain):

        name = self._get_name()

        spline_setup_group = cmds.group(em=True, n=core.inc_name('splineSetup_%s' % name))
        cmds.hide(spline_setup_group)
        cluster_group = cmds.group(em=True, n=core.inc_name('clusterSetup_%s' % name))

        ik_handle, effector, curve = cmds.ikHandle(sj=self.buffer_joints[0],
                                                   ee=self.buffer_joints[-1],
                                                   sol='ikSplineSolver',
                                                   pcv=False,
                                                   name=core.inc_name('handle_spline_%s' % name))

        cmds.setAttr('%s.inheritsTransform' % curve, 0)

        curve = cmds.rename(curve, core.inc_name('curve_%s' % name))
        effector = cmds.rename(effector, core.inc_name('effector_%s' % name))

        top_cluster, top_handle = cmds.cluster('%s.cv[0]' % curve, n=core.inc_name('clusterTop_%s' % name))
        mid_cluster, mid_handle = cmds.cluster('%s.cv[1:2]' % curve, n=core.inc_name('clusterMid_%s' % name))
        btm_cluster, btm_handle = cmds.cluster('%s.cv[3]' % curve, n=core.inc_name('clusterBtm_%s' % name))

        cmds.parent([top_handle, mid_handle, btm_handle], cluster_group)
        cmds.parent([ik_handle, curve], spline_setup_group)
        cmds.parent(cluster_group, spline_setup_group)

        cmds.parent(spline_setup_group, self.setup_group)

        cmds.parentConstraint(follow, cluster_group, mo=True)

        cmds.pointConstraint(btm_constrain, btm_handle, mo=True)
        cmds.parentConstraint(mid_constrain, mid_handle, mo=True)

        return ik_handle, curve

    def _setup_stretchy(self, curve, control):

        rigs_util.create_spline_ik_stretch(curve, self.buffer_joints[:-1], control)

    def _create_top_control(self):

        if not self.end_with_locator:
            control = self._create_control('top', curve_type=self.control_shape)
        if self.end_with_locator:
            control = self._create_control(curve_type=self.control_shape)

        control.hide_scale_and_visibility_attributes()

        xform = space.create_xform_group(control.get())

        orient_transform = self.control_orient

        if not orient_transform:
            orient_transform = self.joints[0]

        space.MatchSpace(orient_transform, xform).translation()
        space.MatchSpace(orient_transform, xform).rotation()

        self._fix_right_side_orient(xform)

        if self.negate_right_scale and self.side == 'R':
            cmds.setAttr('%s.scaleX' % xform, -1)
            cmds.setAttr('%s.scaleY' % xform, -1)
            cmds.setAttr('%s.scaleZ' % xform, -1)

        return control.get(), xform

    def _create_btm_control(self):
        control = self._create_control('btm', curve_type=self.control_shape)
        control.hide_scale_and_visibility_attributes()

        xform = space.create_xform_group(control.get())

        orient_translate = self.joints[-1]
        orient_rotate = self.control_orient

        if not orient_rotate:
            orient_rotate = self.joints[0]

        space.MatchSpace(orient_translate, xform).translation()
        space.MatchSpace(orient_rotate, xform).rotation()

        self._fix_right_side_orient(xform)

        if self.negate_right_scale and self.side == 'R':
            cmds.setAttr('%s.scaleX' % xform, -1)
            cmds.setAttr('%s.scaleY' % xform, -1)
            cmds.setAttr('%s.scaleZ' % xform, -1)

        return control.get(), xform

    def _create_btm_sub_control(self):
        control = self._create_control('btm', sub=True)
        control.scale_shape(.5, .5, .5)
        control.hide_scale_and_visibility_attributes()

        xform = space.create_xform_group(control.get())

        orient_translate = self.joints[-1]
        orient_rotate = self.control_orient

        if not orient_rotate:
            orient_rotate = self.joints[0]

        space.MatchSpace(orient_translate, xform).translation()
        space.MatchSpace(orient_rotate, xform).rotation()

        self._fix_right_side_orient(xform)

        if self.negate_right_scale and self.side == 'R':
            cmds.setAttr('%s.scaleX' % xform, -1)
            cmds.setAttr('%s.scaleY' % xform, -1)
            cmds.setAttr('%s.scaleZ' % xform, -1)

        return control.get(), xform

    def _create_mid_control(self):

        if self.bool_create_middle_control:
            control = self._create_control('mid', sub=True)
            control.scale_shape(.5, .5, .5)
            control.hide_scale_and_visibility_attributes()

            control = control.get()

        if not self.bool_create_middle_control:
            mid_locator = cmds.spaceLocator(n=core.inc_name(self._get_name('locator', 'mid')))[0]
            control = mid_locator
            cmds.hide(mid_locator)

        xform = space.create_xform_group(control)

        orient_transform = self.control_orient

        if not orient_transform:
            orient_transform = self.joints[0]

        space.MatchSpace(orient_transform, xform).translation_rotation()

        self._fix_right_side_orient(xform)

        if self.negate_right_scale and self.side == 'R':
            cmds.setAttr('%s.scaleX' % xform, -1)
            cmds.setAttr('%s.scaleY' % xform, -1)
            cmds.setAttr('%s.scaleZ' % xform, -1)

        return control, xform

    def _fix_right_side_orient(self, control):

        if not self.right_side_fix:
            return

        if not self.side == 'R':
            return

        xform_locator = cmds.spaceLocator()[0]

        match_space = space.MatchSpace(control, xform_locator)
        match_space.translation_rotation()

        spacer = space.create_xform_group(xform_locator)

        for letter in self.right_side_fix_axis:
            cmds.setAttr('%s.rotate%s' % (xform_locator, letter.upper()), 180)

        match_space = space.MatchSpace(xform_locator, control)
        match_space.translation_rotation()

        cmds.delete(spacer)

    def set_end_with_locator(self, bool_value):
        """
        Whether the end effector control should be a locator instead.
        """
        self.end_with_locator = bool_value

    def set_guide_top_btm(self, top_guide, btm_guide):
        """
        Set the parents for the top and btm guide controls.
        """
        self.top_guide = top_guide
        self.btm_guide = btm_guide

    def set_control_shape(self, name):
        self.control_shape = name

    def set_create_middle_control(self, bool_value):
        """
        Whether to create the elbow control.
        """
        self.bool_create_middle_control = bool_value

    def set_right_side_fix(self, bool_value, axis):
        """
        Whether to compensate for the right side joint orientation.
        """
        self.right_side_fix = bool_value
        self.right_side_fix_axis = axis

    def set_control_orient(self, transform):
        """
        Set the orientation of the top and btm control based on the transform.

        Args:
            transform (str): The name of a transform.
        """

        self.control_orient = transform

    def set_negate_right_scale(self, bool_value):

        self.negate_right_scale = bool_value

    def create(self):
        super(IkSplineNubRig, self).create()

        top_control, top_xform = self._create_top_control()

        self.top_control = top_control
        self.top_xform = top_xform

        if not self.end_with_locator:
            btm_control, btm_xform = self._create_btm_control()
            sub_btm_control, sub_btm_xform = self._create_btm_sub_control()
            cmds.parent(sub_btm_xform, btm_control)

        if self.end_with_locator:

            btm_control = cmds.spaceLocator(n=core.inc_name('locator_%s' % self._get_name()))[0]
            btm_xform = btm_control
            sub_btm_control = btm_control
            cmds.hide(btm_control)

            orient_translate = self.joints[-1]
            orient_rotate = self.control_orient

            if not orient_rotate:
                orient_rotate = self.joints[0]

            space.MatchSpace(orient_translate, btm_control).translation()
            space.MatchSpace(orient_rotate, btm_control).rotation()

            self._fix_right_side_orient(btm_control)

            if self.negate_right_scale and self.side == 'R':
                cmds.setAttr('%s.scaleX' % btm_control, -1)
                cmds.setAttr('%s.scaleY' % btm_control, -1)
                cmds.setAttr('%s.scaleZ' % btm_control, -1)

        self.btm_control = btm_control
        self.btm_xform = btm_xform

        mid_control, mid_xform = self._create_mid_control()

        cmds.parent(mid_xform, top_control)

        top_joint, handle = self._create_joint_line()
        sub_joint, sub_handle = self._create_joint_line()

        cmds.parent(sub_joint, top_joint)
        cmds.parent(sub_handle, top_joint)

        self._create_twist_group(top_control, handle, top_joint)

        space.create_follow_group(top_joint, mid_xform, use_duplicate=True)
        cmds.pointConstraint(top_control, sub_btm_control, mid_xform)

        spline_handle, curve = self._create_spline(top_joint, sub_btm_control, mid_control)

        self._setup_stretchy(curve, top_control)

        space.create_follow_group(top_control, top_joint)
        space.create_follow_group(sub_btm_control, sub_handle)

        top_twist = cmds.group(em=True, n=core.inc_name('topTwist_%s' % spline_handle))
        btm_twist = cmds.group(em=True, n=core.inc_name('btmTwist_%s' % spline_handle))

        space.MatchSpace(self.buffer_joints[0], top_twist).translation_rotation()

        space.MatchSpace(self.buffer_joints[-1], btm_twist).translation()
        space.MatchSpace(self.buffer_joints[0], btm_twist).rotation()

        cmds.setAttr('%s.dTwistControlEnable' % spline_handle, 1)
        cmds.setAttr('%s.dWorldUpType' % spline_handle, 4)

        cmds.connectAttr('%s.worldMatrix' % top_twist, '%s.dWorldUpMatrix' % spline_handle)
        cmds.connectAttr('%s.worldMatrix' % btm_twist, '%s.dWorldUpMatrixEnd' % spline_handle)

        cmds.parent(top_twist, top_control)
        # cmds.parent(btm_twist, sub_btm_control)

        cmds.pointConstraint(sub_btm_control, handle, mo=True)
        space.create_xform_group(handle)
        space.create_xform_group(sub_handle)

        cmds.parent(btm_xform, top_control)

        if self.top_guide:
            cmds.parentConstraint(self.top_guide, top_xform, mo=True)

        if self.btm_guide:
            cmds.parent(btm_xform, self.btm_guide)

        cmds.parent(btm_twist, sub_joint)


class IkAppendageRig(BufferRig):
    """
    This is usually used for arms or legs.
    """

    stretch_type_old = 0
    stretch_type_lock_elbow = 1
    stretch_type_lock_elbow_soft = 2

    def __init__(self, description, side=None):
        super(IkAppendageRig, self).__init__(description, side)

        self.top_control = None
        self.right_side_fix = True
        self._ik_buffer_joint = True
        self.create_twist = True
        self.create_stretchy = True
        self.btm_control = None
        self.offset_pole_locator = None
        self.pole_offset = 3
        self._build_pole_control = True
        self.orient_constrain = True
        self.curve_type = None
        self.create_sub_control = True
        self.sub_control = None
        self.top_as_locator = False
        self.match_btm_to_joint = True
        self.create_world_switch = True
        self.create_top_control = True
        self.pole_follow_transform = []
        self.pole_follow_transform_default = 0
        self.pole_angle_joints = []
        self.top_control_right_side_fix = True
        self.stretch_axis = 'X'
        self.control_offset_axis = None
        self.negate_right_scale = False
        self.negate_right_scale_values = [-1, -1, -1]
        self.ik_handle = None
        self.pole_control = None
        self.twist_guide = None

        self._pole_constraint = None
        self.pole_curve_type = 'cube'

        self._stretch_type = 0

        # dampen for legacy...
        self.damp_name = 'dampen'

        self.stretch_scale_attribute_offset = 1

        self._duplicate_chain_replace = ['joint', 'ik']

        self._solver_type = space.IkHandle.solver_rp

    def _attach_ik_joints(self, source_chain, target_chain):

        for inc in range(0, len(source_chain)):
            source = source_chain[inc]
            target = target_chain[inc]

            cmds.parentConstraint(source, target)
            attr.connect_scale(source, target)

    def _duplicate_joints(self):

        super(IkAppendageRig, self)._duplicate_joints()

        duplicate = space.DuplicateHierarchy(self.joints[0])
        duplicate.stop_at(self.joints[-1])
        duplicate.replace(self._duplicate_chain_replace[0], self._duplicate_chain_replace[1])

        self.ik_chain = self.buffer_joints

        if not self.create_buffer_joints:
            pass

        if self.create_buffer_joints:
            ik_group = self._create_group()
            cmds.parent(self.ik_chain[0], ik_group)
            cmds.parent(ik_group, self.setup_group)

    def _create_buffer_joint(self):

        buffer_joint = cmds.duplicate(self.ik_chain[-1], po=True)[0]

        cmds.parent(self.ik_chain[-1], buffer_joint)

        if not cmds.isConnected('%s.scale' % buffer_joint, '%s.inverseScale' % self.ik_chain[-1]):
            cmds.connectAttr('%s.scale' % buffer_joint, '%s.inverseScale' % self.ik_chain[-1])

        attributes = ['rotateX',
                      'rotateY',
                      'rotateZ',
                      'jointOrientX',
                      'jointOrientY',
                      'jointOrientZ'
                      ]

        for attribute in attributes:
            cmds.setAttr('%s.%s' % (self.ik_chain[-1], attribute), 0)

        return buffer_joint

    def _create_ik_handle(self):

        if self._ik_buffer_joint:
            buffer_joint = self._create_buffer_joint()
        else:
            buffer_joint = self.ik_chain[-1]

        ik_handle = space.IkHandle(self._get_name())
        ik_handle.set_start_joint(self.ik_chain[0])
        ik_handle.set_end_joint(buffer_joint)
        ik_handle.set_solver(self._solver_type)
        self.ik_handle = ik_handle.create()
        self._ik_pole_values = cmds.getAttr('%s.poleVector' % self.ik_handle)[0]
        xform_ik_handle = space.create_xform_group(self.ik_handle)
        cmds.parent(xform_ik_handle, self.setup_group)

        cmds.hide(xform_ik_handle)

    def _create_top_control(self):

        if not self.top_as_locator:
            control = self._create_control(description='top')
            control.hide_scale_and_visibility_attributes()

            self.top_control = control.get()

        if self.top_as_locator:
            self.top_control = cmds.spaceLocator(n=core.inc_name('locator_%s' % self._get_name()))[0]
            cmds.parent(self.top_control, self.control_group)

        return self.top_control

    def _xform_top_control(self, control):

        match_space = space.MatchSpace(self.ik_chain[0], control)
        match_space.translation_rotation()

        self._fix_right_side_orient(control)

        xform_group = space.create_xform_group(control)

        if self.negate_right_scale and self.side == 'R':
            cmds.setAttr('%s.scaleX' % xform_group, self.negate_right_scale_values[0])
            cmds.setAttr('%s.scaleY' % xform_group, self.negate_right_scale_values[1])
            cmds.setAttr('%s.scaleZ' % xform_group, self.negate_right_scale_values[2])

        cmds.parentConstraint(control, self.ik_chain[0], mo=True)

    def _create_btm_control(self):

        control = self._create_control(description='btm')
        control.hide_scale_and_visibility_attributes()

        self.btm_control = control.get()

        self._fix_right_side_orient(control.get())

        if self.create_sub_control:
            sub_control = self._create_control('BTM', sub=True)

            sub_control.hide_scale_and_visibility_attributes()

            xform_group = space.create_xform_group(sub_control.get())

            self.sub_control = sub_control.get()

            cmds.parent(xform_group, control.get())

            self._connect_sub_visibility('%s.subVisibility' % self.btm_control, self.sub_control)

        return control.get()

    def _fix_right_side_orient(self, control):

        if not self.right_side_fix:
            return

        if not self.side == 'R':
            return

        xform_locator = cmds.spaceLocator()[0]

        match_space = space.MatchSpace(control, xform_locator)
        match_space.translation_rotation()

        spacer = space.create_xform_group(xform_locator)

        cmds.setAttr('%s.rotateY' % xform_locator, 180)
        cmds.setAttr('%s.rotateZ' % xform_locator, 180)

        match_space = space.MatchSpace(xform_locator, control)
        match_space.translation_rotation()

        cmds.delete(spacer)

    def _xform_btm_control(self, control):

        if self.match_btm_to_joint:
            space.MatchSpace(self.ik_chain[-1], control).translation_rotation()

        if not self.match_btm_to_joint:
            space.MatchSpace(self.ik_chain[-1], control).translation()

        self._fix_right_side_orient(control)

        xform_group = space.create_xform_group(control)
        drv_group = space.create_xform_group(control, 'driver')

        if self.negate_right_scale and self.side == 'R':
            cmds.setAttr('%s.scaleX' % xform_group, self.negate_right_scale_values[0])
            cmds.setAttr('%s.scaleY' % xform_group, self.negate_right_scale_values[1])
            cmds.setAttr('%s.scaleZ' % xform_group, self.negate_right_scale_values[2])

        if self.create_world_switch:
            self._create_local_to_world_switch(control, xform_group, drv_group)

        ik_handle_parent = cmds.listRelatives(self.ik_handle, p=True)[0]

        if self.sub_control:
            cmds.parent(ik_handle_parent, self.sub_control)
        if not self.sub_control:
            cmds.parent(ik_handle_parent, control)

        if self.orient_constrain:
            cmds.orientConstraint(self.offset_pole_locator, self.ik_chain[-1], mo=True)

            # if self.sub_control:
            #    cmds.orientConstraint(self.offset_pole_locator, self.ik_chain[-1], mo = True)

            # if not self.sub_control:
            #    cmds.orientConstraint(control, self.ik_chain[-1], mo = True)

    def _create_local_to_world_switch(self, control, xform_group, driver_group):

        cmds.addAttr(control, ln='world', min=0, max=1, dv=0, at='double', k=True)

        # local_group = self._create_group('IkLocal')
        local_group = cmds.duplicate(control, po=True, n=core.inc_name(self._get_name('IkLocal')))[0]
        attr.remove_user_defined(local_group)
        shapes = cmds.listRelatives(local_group)
        if shapes:
            cmds.delete(shapes)

        world_group = self._create_group('IkWorld')
        match_space = space.MatchSpace(control, world_group)
        match_space.translation()

        if not self.right_side_fix and self.side == 'R':
            cmds.rotate(180, 0, 0, world_group)

            if cmds.getAttr('%s.scaleZ' % xform_group) < 0:
                cmds.setAttr('%s.scaleZ' % world_group, -1)

        if self.negate_right_scale and self.side == 'R':
            cmds.setAttr('%s.scaleX' % world_group, self.negate_right_scale_values[0])
            cmds.setAttr('%s.scaleY' % world_group, self.negate_right_scale_values[1])
            cmds.setAttr('%s.scaleZ' % world_group, self.negate_right_scale_values[2])

        cmds.parent([local_group, world_group], xform_group)

        cmds.orientConstraint(local_group, driver_group)
        cmds.orientConstraint(world_group, driver_group)

        constraint = space.ConstraintEditor()

        active_constraint = constraint.get_constraint(driver_group, constraint.constraint_orient)

        constraint.create_switch(control, 'world', active_constraint)

        self.world_group = world_group
        self.local_group = local_group

    def _create_top_btm_joint(self, joints, prefix):
        top_position = cmds.xform(joints[0], q=True, t=True, ws=True)
        btm_position = cmds.xform(joints[-1], q=True, t=True, ws=True)

        top_name = self._get_name(prefix, 'top')
        btm_name = self._get_name(prefix, 'btm')

        cmds.select(cl=True)

        top_joint = cmds.joint(p=top_position, n=core.inc_name(top_name))
        btm_joint = cmds.joint(p=btm_position, n=core.inc_name(btm_name))

        cmds.joint(top_joint, e=True, zso=True, oj='xyz', sao='yup')

        return [top_joint, btm_joint]

    def _create_twist_ik(self, joints, description, solver=None):

        ik_handle = space.IkHandle(description)

        if not solver:
            solver = ik_handle.solver_sc

        ik_handle.set_solver(solver)
        ik_handle.set_start_joint(joints[0])
        ik_handle.set_end_joint(joints[-1])
        return ik_handle.create()

    def _create_twist_joint(self, top_control):

        top_guide_joint, btm_guide_joint = self._create_top_btm_joint([self.buffer_joints[-1], self.buffer_joints[0]],
                                                                      'guide')
        top_guidetwist_joint, btm_guidetwist_joint = self._create_top_btm_joint(
            [self.buffer_joints[0], self.buffer_joints[-1]], 'guideTwist')

        self.twist_guide = top_guidetwist_joint

        guide_ik, twist_guide_ik = self._create_twist_guide_ik([top_guide_joint, btm_guide_joint],
                                                               [top_guidetwist_joint, btm_guidetwist_joint])

        cmds.parent(top_guidetwist_joint, top_guide_joint)
        cmds.parent(twist_guide_ik, top_guide_joint)

        cmds.parent(top_guide_joint, self.setup_group)
        cmds.parent(guide_ik, self.setup_group)

        if self.sub_control:
            cmds.pointConstraint(self.sub_control, top_guide_joint)
        if not self.sub_control:
            cmds.pointConstraint(self.btm_control, top_guide_joint)

        cmds.pointConstraint(top_control, guide_ik)

        cmds.pointConstraint(top_control, top_guidetwist_joint)

        # self._create_offset_locator()

        cmds.parentConstraint(self.offset_pole_locator, twist_guide_ik, mo=True)

    def _create_offset_locator(self):
        if self.sub_control:
            offset_locator = cmds.spaceLocator(n=core.inc_name('offset_%s' % self.sub_control))[0]
            cmds.parent(offset_locator, self.sub_control)

            match_space = space.MatchSpace(self.sub_control, offset_locator)
            match_space.translation_rotation()

        if not self.sub_control:
            offset_locator = cmds.spaceLocator(n=core.inc_name('offset_%s' % self.btm_control))[0]
            cmds.parent(offset_locator, self.btm_control)

            match_space = space.MatchSpace(self.btm_control, offset_locator)
            match_space.translation_rotation()

        space.create_xform_group(offset_locator)

        cmds.hide(offset_locator)

        self.offset_locator = offset_locator
        self.offset_pole_locator = offset_locator

    def _create_twist_guide_ik(self, guides, guides_twist):
        guide_ik = self._create_twist_ik(guides, 'guide')
        twist_guide_ik = self._create_twist_ik(guides_twist, 'guideTwist')

        return guide_ik, twist_guide_ik

    def _get_pole_joints(self):
        if not self.pole_angle_joints:
            mid_joint_index = len(self.ik_chain) / 2
            mid_joint_index = int(mid_joint_index)
            mid_joint = self.ik_chain[mid_joint_index]

            joints = [self.ik_chain[0], mid_joint, self.ik_chain[-1]]

            return joints

        return self.pole_angle_joints

    def _create_pole_control(self):

        if self._build_pole_control:
            control = self._create_control('POLE', curve_type=self.pole_curve_type)
            control.hide_scale_and_visibility_attributes()
            self.pole_control = control

    def _create_pole_twist_attrs(self):
        twist_var = attr.MayaNumberVariable('twist')
        twist_var.create(self.btm_control)

        if self.side == 'L' or not self.side:
            twist_var.connect_out('%s.twist' % self.ik_handle)

        if self.side == 'R':
            attr.connect_multiply('%s.twist' % self.btm_control, '%s.twist' % self.ik_handle, -1)

    def _create_pole_vector(self):

        control = self.pole_control
        self.pole_control = self.pole_control.get()

        attr.create_title(self.btm_control, 'POLE_VECTOR')

        pole_vis = attr.MayaNumberVariable('poleVisibility')
        pole_vis.set_variable_type(pole_vis.TYPE_BOOL)
        pole_vis.create(self.btm_control)

        self._create_pole_twist_attrs()

        pole_joints = self._get_pole_joints()

        position = space.get_polevector(pole_joints[0], pole_joints[1], pole_joints[2], self.pole_offset)
        cmds.move(position[0], position[1], position[2], control.get())

        self._create_pole_constraint(control.get(), self.ik_handle)

        xform_group = space.create_xform_group(control.get())

        follow_group = None

        if self.create_twist:
            pole_locator = self._create_pole_follow()

            follow_group = space.create_follow_group(pole_locator, xform_group)
            # xform_group = space.create_xform_group( control.get() )

            constraint = cmds.parentConstraint(self.twist_guide, follow_group, mo=True)[0]
            constraint_editor = space.ConstraintEditor()
            constraint_editor.create_switch(self.btm_control, 'autoTwist', constraint)

            cmds.setAttr('%s.autoTwist' % self.btm_control, 0)

        if not self.create_twist:
            if self.pole_follow_transform:
                follow_group = space.create_follow_group(self.pole_follow_transform, xform_group)
                cmds.parent(follow_group, self.control_group)

            if not self.pole_follow_transform:
                follow_group = xform_group

        name = self._get_name()

        rig_line = rigs_util.RiggedLine(pole_joints[1], control.get(), name).create()
        cmds.parent(rig_line, self.control_group)

        pole_vis.connect_out('%s.visibility' % xform_group)
        pole_vis.connect_out('%s.visibility' % rig_line)

        self.pole_vector_xform = xform_group

    def _create_pole_constraint(self, control, handle):
        self._pole_constraint = cmds.poleVectorConstraint(control, handle)[0]

    def _create_pole_follow(self):

        self.pole_follow_transform = vtool.util.convert_to_sequence(self.pole_follow_transform)

        pole_locator = cmds.spaceLocator(n=core.inc_name(self._get_name('locator', 'pole')))[0]

        space.MatchSpace(self.pole_control, pole_locator).translation_rotation()
        cmds.parent(pole_locator, self.setup_group)

        self.pole_follow_transform.append(self.top_control)

        if len(self.pole_follow_transform) == 1:
            space.create_follow_group(self.pole_follow_transform[0], pole_locator)
        if len(self.pole_follow_transform) > 1:
            space.create_multi_follow(self.pole_follow_transform, pole_locator, self.pole_control,
                                      value=self.pole_follow_transform_default)

        return pole_locator

    def _create_stretchy(self, top_transform, btm_transform, control):

        if self._stretch_type == 0:
            stretchy = rigs_util.StretchyChain()

            stretchy.set_joints(self.ik_chain)
            # dampen should be damp... dampen means wet, damp means diminish
            stretchy.set_add_damp(True, self.damp_name)
            stretchy.set_node_for_attributes(control)
            stretchy.set_description(self._get_name())
            stretchy.set_scale_axis(self.stretch_axis)
            stretchy.set_scale_attribute_offset(self.stretch_scale_attribute_offset)

            top_locator, btm_locator = stretchy.create()

            cmds.parent(top_locator, top_transform)
            cmds.parent(btm_locator, btm_transform)

            cmds.connectAttr('%s.sizeX' % self.control_group, '%s.input2X' % stretchy.distance_offset)
            cmds.connectAttr('%s.sizeY' % self.control_group, '%s.input2Y' % stretchy.distance_offset)
            cmds.connectAttr('%s.sizeZ' % self.control_group, '%s.input2Z' % stretchy.distance_offset)

        if self.pole_control:
            controls = [top_transform, self.pole_control, self.offset_pole_locator]

            if self.offset_pole_locator:

                if self._stretch_type == 1:
                    self._create_elbow_lock_stretchy(controls, soft=False)

                if self._stretch_type == 2:
                    self._create_elbow_lock_stretchy(controls, soft=True)

        if not self.pole_control:
            if self._stretch_type == 1 or self._stretch_type == 2:
                vtool.util.warning(
                    'Could not build stretch type %s because pole vector control creation turned off.' % self._stretch_type)

        if not self.offset_pole_locator:
            if self._stretch_type == 1 or self._stretch_type == 2:
                vtool.util.warning(
                    'Could not build stretch type %s because auto twist turned off.' % self._stretch_type)

    def _create_elbow_lock_stretchy(self, controls, soft=False):

        elbow_lock = rigs_util.StretchyElbowLock(self.buffer_joints, controls)
        elbow_lock.set_attribute_control(self.controls[-1])
        elbow_lock.set_stretch_axis(self.stretch_axis)
        if self.twist_guide:
            elbow_lock.set_top_aim_transform(self.twist_guide)
        elif self.top_control:
            elbow_lock.set_top_aim_transform(self.top_control)
        elbow_lock.set_description(self._get_name())
        elbow_lock.set_create_soft_ik(soft)
        elbow_lock.set_parent(self.setup_group)
        elbow_lock.create()

        if elbow_lock.soft_locator:
            xform = space.get_xform_group(self.ik_handle)
            cmds.parent(xform, elbow_lock.soft_locator)
            cmds.parent(elbow_lock.soft_locator, self.setup_group)

    def _create_tweakers(self):
        pass

    def _create_before_attach_joints(self):
        super(IkAppendageRig, self)._create_before_attach_joints()

        self._create_ik_handle()

    def set_duplicate_chain_replace(self, replace_this, with_this):

        self._duplicate_chain_replace = [replace_this, with_this]

    def set_create_twist(self, bool_value):
        """
        Whether to add an auto twist setup.
        """
        self.create_twist = bool_value

    def set_create_stretchy(self, bool_value):
        """
        Whether to add a stretchy setup.
        """
        self.create_stretchy = bool_value

    def set_stretch_axis(self, axis_letter):
        """
        What axis the stretch should scale on.

        Args:
            axis_letter (str): 'X','Y','Z'
        """
        self.stretch_axis = axis_letter

    def set_pole_offset(self, value):
        """
        Get the amount that the polevector control should offset from the elbow.

        Args:
            value (float)
        """
        self.pole_offset = value

    def set_pole_angle_joints(self, joints):
        """
        Set which joints the pole angle is calculated from.

        Args:
            joints (list): A list of 3 joints that form a triangle.
        """
        self.pole_angle_joints = joints

    def set_right_side_fix(self, bool_value):
        """
        Whether to compensate for right side orientation.
        """
        self.right_side_fix = bool_value

    def set_create_ik_buffer_joint(self, bool_value):
        """
        Vetala creates a buffer in the ik joints at the wrist.
        This was to try to fix an ik offset issue when the arm stretches
        However, it seems this fix can cause problems, especially when it zeros out the joint orient on the wrist joint.
        If your hand is offsetting when you stretch the arm, try turning this off.
        """

        self._ik_buffer_joint = bool_value

    def set_negate_right_scale(self, bool_value, scale_x=-1, scale_y=-1, scale_z=-1):
        """
        This will negate the scale of the right side making it better mirrored for cycles.
        """

        self.negate_right_scale = bool_value
        self.negate_right_scale_values = [scale_x, scale_y, scale_z]

    def set_orient_constrain(self, bool_value):
        """
        Whether the end effector control should orient constrain the ik handle.
        Default is True.
        """
        self.orient_constrain = bool_value

    def set_curve_type(self, curve_name):
        self.curve_type = curve_name

    def set_create_sub_control(self, bool_value):
        self.create_sub_control = bool_value

    def set_create_world_switch(self, bool_value):
        """
        Whether to create a world switch on the end effector control.
        This can be used to have the end effector control orient to world if the character is in a-pose.
        """
        self.create_world_switch = bool_value

    def set_top_control_as_locator(self, bool_value):
        """
        Instead of a control curve for the top control, make it a locator.
        """
        self.top_as_locator = bool_value

    def set_match_btm_to_joint(self, bool_value):
        """
        Whether to match orientation of the end effector control to the btm joint, or just translation.
        Default is True.
        """
        self.match_btm_to_joint = bool_value

    def set_create_top_control(self, bool_value):
        """
        Whether to create a top control.
        """
        self.create_top_control = bool_value

    def set_create_pole_control(self, bool_value):
        self._build_pole_control = bool_value

    def set_pole_control_shape(self, curve_type_name):

        self.pole_curve_type = curve_type_name

    def set_pole_follow_transform(self, transform, default_value=0):
        """
        Set a transform for the pole to follow with an on/off switch on the pole control.

        Args:
            transform (str): The name of a transform.s
            default_value (int): TODO: Fill description.
        """
        self.pole_follow_transform = transform
        self.pole_follow_transform_default = default_value

    def set_control_offset_axis(self, axis):
        """
        This will rotate the control shape cvs 90 on the axis, helping it to align better with different joint orientations.
        """
        axis = axis.lower()
        self.control_offset_axis = axis

    def set_damp_name(self, name):
        self.damp_name = name

    def set_stretch_scale_attribute_offset(self, value):
        self.stretch_scale_attribute_offset = value

    def set_stretch_type(self, stretch_type_int):

        self._stretch_type = stretch_type_int

    def set_solver_type(self, solver_name):
        self._solver_type = solver_name

    def create(self):
        super(IkAppendageRig, self).create()

        if self.create_top_control:
            top_control = self._create_top_control()
        if not self.create_top_control:
            top_control = cmds.spaceLocator(n=core.inc_name('locator_top_%s' % self._get_name()))[0]
            self.top_control = top_control
            cmds.parent(self.top_control, self.control_group)
            space.MatchSpace(self.joints[0], top_control).translation_rotation()

        self._xform_top_control(top_control)

        self._create_pole_control()

        btm_control = self._create_btm_control()

        self._create_offset_locator()
        self._xform_btm_control(btm_control)

        if self.create_twist:
            self._create_twist_joint(top_control)

        if self._build_pole_control:
            self._create_pole_vector()

        if self._solver_type == 'ikSpringSolver':
            self.create_stretchy = False

        if self.create_stretchy:

            if self.sub_control:
                self._create_stretchy(top_control, self.sub_control, btm_control)
            if not self.sub_control:
                self._create_stretchy(top_control, self.btm_control, btm_control)

        if self._build_pole_control:
            if self.create_top_control:
                cmds.controller(self.pole_control, self.top_control, e=True, p=True)
                cmds.controller(btm_control, self.pole_control, e=True, p=True)
        else:
            if self.create_top_control:
                cmds.controller(btm_control, self.top_control, e=True, p=True)

# --- Tweak


class TweakLevelRig(BufferRig, SplineRibbonBaseRig):

    def __init__(self, name, side=None):
        super(TweakLevelRig, self).__init__(name, side)

        self.control_count = 2
        self.span_count = 9
        self.fk = False
        self.ribbon = True
        self.stretch_on_off = True
        self.align_controls = [False, False, False]
        self._generate_joints = False
        self.generated_joints = []
        self.generate_joints_prefix = 'bind'

    def _create_before_attach_joints(self):
        super(TweakLevelRig, self)._create_before_attach_joints()

        if self.attach_joints:
            self._attach_to_geo()

    """
    def _create_surface(self, name, spans):
        surface = geo.transforms_to_nurb_surface(self.buffer_joints,
                                                 spans = spans,
                                                 offset_axis = self.ribbon_offset_axis,
                                                 offset_amount = self.ribbon_offset,
                                                 bezier = False,
                                                 keep_history = False)

        new_surface_name = core.inc_name(self._get_name('surface', name, sub = False))
        cmds.rename(surface, new_surface_name)

        return new_surface_name
    """

    def _cluster_surface(self, surface, name):
        cluster_inst = deform.ClusterSurface(surface, name)
        cluster_inst.set_join_ends(True)
        cluster_inst.create()

        handles = cluster_inst.get_cluster_handle_list()

        return handles

    def _create_cluster_controls(self, clusters, description=None, sub=False, fk=False, align=False, add_joint=False):

        last_control = None
        xforms = []

        for cluster in clusters:
            control = self._create_control(description=description, sub=sub)

            control_name = control.get()

            space.MatchSpace(cluster, control_name).translation_to_rotate_pivot()
            xform = space.create_xform_group(control_name)

            control.hide_scale_attributes()

            closest_joint = space.get_closest_transform(xform, self.buffer_joints)

            if align:
                space.MatchSpace(closest_joint, xform).rotation()

            self._attach_cluster(control_name, cluster)

            if add_joint:
                cmds.select(cl=True)
                joint = cmds.joint(n=core.inc_name(self._get_name('bind', description)))
                cmds.parent(joint, control_name)
                space.zero_out_transform_channels(joint)
                cmds.makeIdentity(joint, apply=True, r=True)
                cmds.hide(joint)
                self.generated_joints.append(joint)

            if last_control and fk:
                cmds.parent(xform, last_control)

            last_control = control_name

            xforms.append(xform)

        return xforms

    def _attach_cluster(self, control_name, cluster):

        under = cmds.group(em=True, n='under_%s' % control_name)
        cmds.parent(under, control_name)
        attr.zero_xform_channels(under)

        cmds.parentConstraint(under, cluster, mo=True)

    def set_fk(self, bool_value):
        self.fk = bool_value

    def set_control_count(self, int_control_count):
        self.control_count = (int_control_count - 1)

    def set_sub_control_count(self, int_control_count):
        self.span_count = (int_control_count - 1)

    def set_align_controls_to_joints(self, bool_value, level=-1):

        if level == -1:
            for inc, _ in enumerate(self.align_controls):
                self.align_controls[inc] = bool_value

        if len(self.align_controls) >= (level + 1):
            self.align_controls[level] = bool_value

    def set_generate_child_joint_at_control(self, bool_value, prefix='bind'):
        """
        This helps make the setup more flexible.
        Joints are created at the lowest level.  This allows the controls to easily drive another setup.
        One use case was having a spine and a neck drive the same ribbon.
        """

        self._generate_joints = bool_value
        self.generate_joints_prefix = prefix

    def create(self):

        surface_lvl1 = self._create_surface(self.control_count, 'lvl1')
        surface_lvl2 = self._create_surface(self.span_count, 'lvl2')
        # surface_lvl1 = self._create_surface('lvl1', self.control_count)
        # surface_lvl2 = self._create_surface('lvl2', self.span_count)
        # self.surface = surface_lvl2

        super(TweakLevelRig, self).create()

        lvl1_clusters = self._create_group('clusters', 'lvl1')
        lvl2_clusters = self._create_group('clusters', 'lvl2')
        cmds.parent(lvl1_clusters, self.setup_group)
        cmds.parent(lvl2_clusters, self.setup_group)

        handles_lvl1 = self._cluster_surface(surface_lvl1, 'lvl1')
        handles_lvl2 = self._cluster_surface(surface_lvl2, 'lvl2')

        cmds.parent(handles_lvl1, lvl1_clusters)
        cmds.parent(handles_lvl2, lvl2_clusters)

        self._create_cluster_controls(handles_lvl1, fk=self.fk, align=self.align_controls[0])
        xforms = self._create_cluster_controls(handles_lvl2,
                                               sub=True,
                                               align=self.align_controls[1],
                                               add_joint=self._generate_joints)

        rivet_group = self._create_group('rivets')
        cmds.parent(rivet_group, self.setup_group)

        for xform in xforms:
            rivet = geo.attach_to_surface(xform, surface_lvl1)
            cmds.parent(rivet, rivet_group)

        if self.stretch_on_off:
            self._setup_stretchy(self.controls[-1])


class TweakCurveRig(BufferRig):
    """
    TweakCurveRig is good for belts or straps that need to be riveted to a surface.
    """

    def __init__(self, name, side=None):
        super(TweakCurveRig, self).__init__(name, side)

        self.maya_type = None
        self.control_count = 4
        self.curve = None
        self.surface = None
        self.use_ribbon = True

        self.create_buffer_joints = False

        self.orient_controls_to_joints = True
        self.orient_joint = None

        self.join_both_ends = False

        self.ribbon_offset = 1
        self.ribbon_offset_axis = 'Z'

        self.follicle_ribbon = False

    def _create_control(self, sub=False):

        control = super(TweakCurveRig, self)._create_control(sub=sub)

        control.hide_scale_and_visibility_attributes()

        return control.get()

    def _create_ik_guide(self):

        if not self.use_ribbon:
            if not self.surface:
                name = self._get_name()

                self.surface = geo.transforms_to_curve(self.buffer_joints, self.control_count, name)

                cmds.rebuildCurve(self.surface,
                                  spans=self.control_count - 1,
                                  rpo=True,
                                  rt=0,
                                  end=1,
                                  kr=False,
                                  kcp=False,
                                  kep=True,
                                  kt=False,
                                  d=3)

                self.surface = cmds.rename(self.surface, name)

                cmds.parent(self.surface, self.setup_group)

        if self.use_ribbon:
            if not self.surface:
                surface = geo.transforms_to_nurb_surface(self.buffer_joints, self._get_name(self.description), spans=-1,
                                                         offset_axis=self.ribbon_offset_axis,
                                                         offset_amount=self.ribbon_offset)
                cmds.rebuildSurface(surface, ch=True, rpo=True, rt=False, end=True, kr=0, kcp=0, kc=0, su=1, du=1,
                                    sv=self.control_count - 1, dv=3, fr=0, dir=True)

                self.surface = surface

                cmds.parent(self.surface, self.setup_group)

    def _cluster(self, description):

        cluster_curve = deform.ClusterSurface(self.surface, self._get_name(description))
        cluster_curve.set_join_ends(True)
        cluster_curve.set_join_both_ends(self.join_both_ends)
        cluster_curve.create()

        self.cluster_handles = cluster_curve.handles
        self.cluster_deformers = cluster_curve.clusters

        return cluster_curve.get_cluster_handle_list()

    def _attach_cluster(self, control, cluster):

        cmds.parentConstraint(control, cluster, mo=True)

    def set_control_count(self, int_value):

        self.control_count = int_value

    def set_use_ribbon(self, bool_value):
        self.use_ribbon = bool_value

    def set_ribbon(self, bool_value):
        self.use_ribbon = bool_value

    def set_ribbon_follicle(self, bool_value):
        self.follicle_ribbon = bool_value

    def set_ribbon_offset(self, float_value):
        self.ribbon_offset = float_value

    def set_ribbon_offset_axis(self, axis_letter):
        self.ribbon_offset_axis = axis_letter

    def set_orient_controls_to_joints(self, bool_value):
        self.orient_controls_to_joints = bool_value

    def set_join_both_ends(self, bool_value):
        self.join_both_ends = bool_value

    def create(self):
        super(TweakCurveRig, self).create()

        self._create_ik_guide()
        clusters = self._cluster(self.description)

        cmds.parent(clusters, self.setup_group)

        for cluster in clusters:
            control = self._create_control()

            xform = space.create_xform_group(control)
            space.create_xform_group(control, 'driver')

            space.MatchSpace(cluster, xform).translation_to_rotate_pivot()

            if self.orient_controls_to_joints:

                if not self.orient_joint:
                    joint = space.get_closest_transform(cluster, self.buffer_joints)

                if self.orient_joint:
                    joint = self.orient_joint

                space.MatchSpace(joint, xform).translation_rotation()

            self._attach_cluster(control, cluster)

        if core.has_shape_of_type(self.surface, 'nurbsCurve'):
            self.maya_type = 'nurbsCurve'
        if core.has_shape_of_type(self.surface, 'nurbsSurface'):
            self.maya_type = 'nurbsSurface'

        if self.attach_joints:
            for joint in self.buffer_joints:

                if self.maya_type == 'nurbsSurface':
                    if not self.follicle_ribbon:
                        rivet = geo.attach_to_surface(joint, self.surface)
                        cmds.parent(rivet, self.setup_group)
                    if self.follicle_ribbon:
                        follicle = geo.follicle_to_surface(joint, self.surface, constrain=True)
                        cmds.parent(follicle, self.setup_group)

                if self.maya_type == 'nurbsCurve':
                    geo.attach_to_curve(joint, self.surface)
                    cmds.orientConstraint(self.control_group, joint)


class LocalTweakCurveRig(TweakCurveRig):

    def __init__(self, name, side=None):
        super(LocalTweakCurveRig, self).__init__(name, side)

        self.local_groups = []
        self.local_xform_groups = []

    def _attach_cluster(self, control, cluster):
        local, xform = space.constrain_local(control, cluster, use_duplicate=True)

        self.local_groups.append(local)
        self.local_xform_groups.append(xform)

        cmds.parent(xform, self.setup_group)


class RopeRig(CurveRig):

    def __init__(self, name, side=None):
        super(RopeRig, self).__init__(name, side)

        self.subdivision = 0

        self._sub_run = False

        self._division_value = 2
        self.cluster_deformers = []

    def _define_control_shape(self):
        return 'cube'

    def _rebuild_curve(self, curve, spans, inc):

        if self._sub_run:
            curve_split = curve.split('_')
            curve_split[-1] = 'sub%s' % (inc + 1)
            name = '_'.join(curve_split)

        if not self._sub_run:
            name = '%s_sub%s' % (curve, (inc + 1))

        rebuilt_curve, node = cmds.rebuildCurve(curve,
                                                constructionHistory=True,
                                                replaceOriginal=False,
                                                rebuildType=0,
                                                endKnots=1,
                                                keepRange=0,
                                                keepControlPoints=0,
                                                keepEndPoints=1,
                                                keepTangents=0,
                                                spans=spans,
                                                degree=3,
                                                name=name)

        cmds.delete(rebuilt_curve, ch=True)

        return rebuilt_curve, node

    def _cluster_curve(self, curve, description):

        cluster_curve = deform.ClusterCurve(curve, self._get_name(description))
        cluster_curve.create()
        self.cluster_deformers = cluster_curve.clusters

        return cluster_curve.get_cluster_handle_list()

    def _subdivide(self):

        curves = [self.curves[0]]

        last_curve = None

        for inc in range(0, self.subdivision):

            if last_curve:
                curve = last_curve
            if not last_curve:
                curve = self.curves[0]

            curve_object = api.nodename_to_mobject(cmds.listRelatives(curve, s=True)[0])
            curve_object = api.NurbsCurveFunction(curve_object)
            spans = curve_object.get_span_count()

            rebuilt_curve, rebuild_node = self._rebuild_curve(curve, spans * self._division_value, inc)

            curves.append(rebuilt_curve)
            cmds.parent(rebuilt_curve, self.setup_group)
            last_curve = rebuilt_curve

            self._sub_run = True

        self._sub_run = False
        return curves

    def set_subdivisions(self, int_value):

        if int_value < 0:
            int_value = 0

        self.subdivision = int_value

    def set_division_value(self, int_value):
        if int_value < 2:
            int_value = 2

        self._division_value = int_value

    def create(self):

        curves = self._subdivide()

        scale = 1

        scale_section = 1.000 / len(curves)
        alt_color = False

        description = None

        inc = 0

        last_curve = None

        for curve in curves:
            if inc > 0:
                description = 'sub%s' % inc
            if inc == 0:
                description = 'main'

            clusters = self._cluster_curve(curve, description)

            control_group = cmds.group(em=True, n=core.inc_name('controls_%s' % (self._get_name(description))))
            setup_group = cmds.group(em=True, n=core.inc_name('setup_%s' % (self._get_name(description))))

            cmds.parent(control_group, self.control_group)
            cmds.parent(setup_group, self.setup_group)

            inc2 = 0

            for cluster in clusters:

                if description:
                    control = self._create_control(description)
                if not description:
                    control = self._create_control()

                if not alt_color:
                    if not self.control_color:
                        control.color(attr.get_color_of_side(self.side))
                    if self.control_color:
                        control.color = self.control_color
                if alt_color:
                    control.color(attr.get_color_of_side(self.side, sub_color=True))

                space.MatchSpace(cluster, control.get()).translation_to_rotate_pivot()

                offset_cluster = cmds.group(em=True, n=core.inc_name('offset_%s' % cluster))
                space.MatchSpace(cluster, offset_cluster).translation_to_rotate_pivot()

                xform_cluster = space.create_xform_group(cluster)

                cmds.parent(xform_cluster, offset_cluster)
                cmds.parent(offset_cluster, setup_group)

                xform_offset = space.create_xform_group(offset_cluster)

                control.scale_shape(scale, scale, scale)

                xform = space.create_xform_group(control.get())
                attr.connect_translate(control.get(), cluster)

                control.hide_scale_attributes()

                if last_curve:
                    geo.attach_to_curve(xform, last_curve)
                    geo.attach_to_curve(xform_offset, last_curve)

                cmds.parent(xform, control_group)

                inc2 += 1

            scale = scale - scale_section

            last_curve = curve

            inc += 1

            if alt_color:
                alt_color = False
                continue

            if not alt_color:
                alt_color = True


class ConvertJointToNub(object):

    def __init__(self, name, side='C'):
        self.btm_xform = None
        self.top_xform = None
        self.btm_control = None
        self.top_control = None
        self.start_joint = None
        self.end_joint = None
        self.count = 10
        self.prefix = 'joint'
        self.name = name
        self.side = side

        self.add_mid_control = True

        self.joints = []
        self.control_group = None
        self.setup_group = None
        self.control_shape = 'pin_round'
        self.add_sub_joints = False

        self.right_side_fix = True
        self.right_side_fix_axis = 'x'
        self.negate_right_scale = False

        self.up_object = None
        self.up_axis = None

        self.control_parent = None
        self.setup_parent = None

        self.control_size = None

        self.orient_to_first_transform = False

    def set_start_joint(self, joint):
        self.start_joint = joint

    def set_end_joint(self, joint):
        self.end_joint = joint

    def set_joints(self, joints):
        self.joints = joints

    def set_create_mid_control(self, bool_value):
        self.add_mid_control = bool_value

    def set_joint_count(self, count):
        self.count = count

    def set_control_shape(self, shape_type_name):
        self.control_shape = shape_type_name

    def set_control_size(self, size_value):
        self.control_size = size_value

    def set_prefix(self, prefix):
        self.prefix = prefix

    def set_add_sub_joints(self, bool_value):
        self.add_sub_joints = bool_value

    def set_up_object(self, name):
        self.up_object = name

    def set_up_axis(self, axis_name):
        self.up_axis = axis_name.upper()

    def set_control_parent(self, name):
        self.control_parent = name

        if cmds.objExists(self.control_group) and cmds.objExists(name):
            cmds.parent(self.control_group, name)

    def set_setup_parent(self, name):
        self.setup_parent = name

        if cmds.objExists(self.setup_group) and cmds.objExists(name):
            cmds.parent(self.setup_group, name)

    def create(self):

        parent_joints = False

        if not self.joints:
            parent_joints = True
            joints = space.subdivide_joint(self.start_joint,
                                           self.end_joint,
                                           self.count, self.prefix,
                                           '%s_1_%s' % (self.name, self.side), True)

            for joint in joints[:-1]:
                orient = space.OrientJoint(joint)

                if not self.up_object:
                    self.up_object = self.start_joint

                up_vector = None

                if self.up_axis:

                    if self.up_axis == 'X':
                        up_vector = [1, 0, 0]
                    if self.up_axis == 'Y':
                        up_vector = [0, 1, 0]
                    if self.up_axis == 'Z':
                        up_vector = [0, 0, 1]
                    if self.up_axis == 'None':
                        up_vector = [0, 0, 0]

                orient.set_aim_up_at_object(self.up_object)

                if up_vector:
                    orient.set_world_up_vector(up_vector)

                orient.run()

            cmds.makeIdentity(joints[-1], r=True, jo=True, apply=True)

            self.joints = joints

        parent_map = {}

        if self.add_sub_joints:

            new_joints = []

            for joint in self.joints:
                duplicate = cmds.duplicate(joint, po=True)

                new_name = joint[0].upper() + joint[1:]

                new_joint = cmds.rename(joint, 'xform%s' % new_name)
                duplicate = cmds.rename(duplicate, joint)
                cmds.parent(duplicate, w=True)

                new_joints.append(new_joint)

                parent_map[new_joint] = duplicate

            self.joints = new_joints

        rig = IkSplineNubRig(self.name, self.side)
        rig.set_joints(self.joints)
        rig.set_end_with_locator(True)
        rig.set_create_middle_control(self.add_mid_control)
        rig.set_control_shape(self.control_shape)
        rig.set_negate_right_scale(self.negate_right_scale)
        if self.orient_to_first_transform:
            rig.set_control_orient(self.start_joint)
        rig.set_buffer(False)
        rig.set_right_side_fix(self.right_side_fix, self.right_side_fix_axis)

        if self.control_size:
            rig.set_control_size(self.control_size)

        rig.create()

        self.top_control = rig.top_control
        self.btm_control = rig.btm_control
        self.top_xform = rig.top_xform
        self.btm_xform = rig.btm_xform

        if parent_joints:
            cmds.parent(joints[0], rig.setup_group)

        if parent_map:
            for joint in parent_map:
                cmds.parent(parent_map[joint], joint)

        self.control_group = rig.control_group
        self.setup_group = rig.setup_group

        if self.control_parent:
            try:
                cmds.parent(self.control_group, self.control_parent)
            except:
                pass

        if self.setup_parent:
            try:
                cmds.parent(self.setup_group, self.setup_parent)
            except:
                pass

    def get_control_group(self):
        return self.control_group

    def get_setup_group(self):
        return self.setup_group

    def get_joints(self):
        return self.joints

    def set_right_side_fix(self, bool_value, axis='x'):
        self.right_side_fix = bool_value
        self.right_side_fix_axis = axis

    def set_negate_right_scale(self, bool_value):
        self.negate_right_scale = bool_value

    def set_orient_to_first_transform(self, bool_value):

        self.orient_to_first_transform = bool_value


class TwistRig(JointRig):

    def __init__(self, name, side=None):
        super(TwistRig, self).__init__(name, side)

        self.twist_group = None
        self.control_count = 5
        self._offset_axis = 'Y'
        self._attach_directly = True
        self._create_top_control = True
        self._create_btm_control = True
        self._btm_twist_fix = True
        self._top_twist_fix = True
        self.orient_example = None
        self._create_controls = True
        self.main_controls = []
        self.twist_controls = []
        self.parent_joints = True

        self.top_locator = None
        self.btm_locator = None

        self.control_xforms = []

        self.sub_joints = []

        self._twist_joint_name = None

        self._rounded = False

    def _create_twister(self, top_xform, btm_xform):
        top_joint1, top_joint2, top_ik = space.create_pole_chain(top_xform, btm_xform,
                                                                 'twist_topFix_%s' % self.description,
                                                                 space.IkHandle.solver_sc)
        cmds.hide(top_joint2)

        xform = space.create_xform_group(top_joint1)
        cmds.parent(xform, self.setup_group)
        cmds.parentConstraint(top_xform, top_joint1, mo=True)
        cmds.parent(top_ik, btm_xform)
        cmds.hide(top_ik)

        btm_joint1, btm_joint2, btm_ik = space.create_pole_chain(btm_xform, top_xform,
                                                                 'twist_btmFix_%s' % self.description,
                                                                 space.IkHandle.solver_sc)
        cmds.hide(btm_joint2)

        xform = space.create_xform_group(btm_joint1)
        cmds.parentConstraint(btm_xform, btm_joint1, mo=True)
        cmds.parent(xform, self.setup_group)
        cmds.parent(btm_ik, top_xform)

        cmds.hide(btm_ik)

        return top_joint1, btm_joint1

    def _create_xform_controls(self, top_joint, btm_joint):

        transforms = self.control_xforms

        if self.orient_example:

            for joint in self.sub_joints:
                space.MatchSpace(self.orient_example, joint).rotation()
                space.MatchSpace(self.orient_example, joint).scale()

            for transform in transforms:
                space.MatchSpace(self.orient_example, transform).rotation()
                space.MatchSpace(self.orient_example, transform).scale()

        for joint in self.sub_joints:
            control = self._create_control(sub=True)

            self.twist_controls.append(control.get())

            xform = space.create_xform_group(control.control)
            scale_offset = space.create_xform_group(control.control, 'offset')

            if self.controls:
                self._connect_sub_visibility('%s.subVisibility' % self.controls[0], control.get())

            parent_constraint = cmds.parentConstraint(joint)
            if not parent_constraint:
                continue

            transform = cmds.parentConstraint(parent_constraint, q=True, targetList=True)[0]

            space.MatchSpace(transform, xform).translation_rotation()

            parent = cmds.listRelatives(transform, p=True, f=True)

            cmds.parent(xform, parent)

            cmds.delete(transform)

            if self.orient_example:
                space.MatchSpace(self.orient_example, xform).rotation()
                space.MatchSpace(self.orient_example, scale_offset).scale()

            if self.parent_joints:
                cmds.parent(joint, control.control)
                cmds.setAttr('%s.rotateX' % joint, 0)
                cmds.setAttr('%s.rotateY' % joint, 0)
                cmds.setAttr('%s.rotateZ' % joint, 0)

            if not self.parent_joints:
                cmds.pointConstraint(control.control, joint, mo=True)
                cmds.orientConstraint(control.control, joint, mo=True)
                # cmds.parentConstraint(control.control, joint, mo = True)
                # cmds.scaleConstraint(control.control, joint)
                attr.connect_scale(control.control, joint)

    def _create_main_control(self, joint, type_name='top'):

        control = self._create_control(type_name)

        control.scale_shape(1.33, 1.33, 1.33)

        control.hide_scale_and_visibility_attributes()

        self.main_controls.append(control)

        xform = space.create_xform_group(control.control)

        space.MatchSpace(joint, xform).translation_rotation()

        if self.orient_example:
            space.MatchSpace(self.orient_example, xform).rotation()
            space.MatchSpace(self.orient_example, xform).scale()

        return control

    def set_orient_example(self, transform):
        self.orient_example = transform

    def set_control_count(self, int_value):
        self.control_count = (int_value - 1)

    def set_create_top_control(self, bool_value):
        self._create_top_control = bool_value

    def set_create_btm_control(self, bool_value):
        self._create_btm_control = bool_value

    def set_top_twist_fix(self, bool_value):
        self._top_twist_fix = bool_value

    def set_btm_twist_fix(self, bool_value):
        self._btm_twist_fix = bool_value

    def set_create_controls(self, bool_value):
        self._create_controls = bool_value

    def set_parent_sub_joints(self, bool_value):

        self.parent_joints = bool_value

    def set_twist_joint_name(self, name):
        self._twist_joint_name = name

    def set_rounded(self, bool_value):
        self._rounded = bool_value

    def create(self):
        super(TwistRig, self).create()

        for joint in self.joints:
            next_joint = cmds.listRelatives(joint, type='joint')

            if next_joint:
                next_joint = next_joint[0]

            if not next_joint:
                continue

            length = space.get_distance(joint, next_joint)

            if not self.orient_example:
                self.orient_example = joint

            twist = rigs_util.TwistRibbon(joint)
            twist.set_description(self._get_name())
            twist.joint_count = self.control_count
            twist._offset_axis = self._offset_axis
            twist._attach_directly = self._attach_directly
            twist._top_twist_fix = self._top_twist_fix
            twist._btm_twist_fix = self._btm_twist_fix
            twist.set_ribbon_offset(length / 4.0)
            twist.set_rounded(self._rounded)

            bad_axis = space.get_axis_letter_aimed_at_child(joint)

            if bad_axis == 'X' or bad_axis == '-X':
                twist.set_ribbon_offset_axis('Z')
            if bad_axis == 'Y' or bad_axis == '-Y':
                twist.set_ribbon_offset_axis('X')
            if bad_axis == 'Z' or bad_axis == '-Z':
                twist.set_ribbon_offset_axis('X')

            twist.create()

            cmds.setAttr('%s.inheritsTransform' % twist.surface, 0)

            self.twist_group = twist.group
            self.sub_joints = twist.joints

            cmds.parent(self.sub_joints, joint)

            cmds.parent(twist.surface_stretch_curve, self.setup_group)
            cmds.parent(twist.surface, self.setup_group)
            if self._create_controls:
                cmds.parent(twist.group, self.control_group)
            else:
                cmds.parent(twist.group, self.setup_group)
            cmds.setAttr('%s.inheritsTransform' % twist.group, 0)

            self.top_locator = twist.top_locator
            self.btm_locator = twist.btm_locator

            cmds.hide(self.top_locator)
            cmds.hide(self.btm_locator)

            cmds.parent(self.top_locator, self.setup_group)
            cmds.parent(self.btm_locator, self.setup_group)

            if self._create_controls:
                if self._create_top_control:
                    top_control = self._create_main_control(joint, 'top')
                    cmds.parent(self.top_locator, top_control.control)
                    if self._top_twist_fix:
                        cmds.addAttr(top_control.control, ln='topTwistFix', k=True)
                        cmds.connectAttr('%s.topTwistFix' % top_control.control, '%s.twist' % twist.top_ik)

                if self._create_btm_control:
                    btm_control = self._create_main_control(next_joint, 'btm')
                    cmds.parent(self.btm_locator, btm_control.control)
                    if self._btm_twist_fix:
                        cmds.addAttr(btm_control.control, ln='btmTwistFix', k=True)
                        cmds.connectAttr('%s.btmTwistFix' % btm_control.control, '%s.twist' % twist.btm_ik)
                else:
                    if self._btm_twist_fix:
                        cmds.addAttr(top_control.control, ln='btmTwistFix', k=True)
                        cmds.connectAttr('%s.btmTwistFix' % top_control.control, '%s.twist' % twist.btm_ik)

                self._create_xform_controls(self.top_locator, self.btm_locator)

            if self.parent_joints:
                cmds.hide(self.sub_joints)
            else:
                cmds.showHidden(self.sub_joints)

            radius = cmds.getAttr('%s.radius' % self.joints[0])

            for sub_joint in self.sub_joints:
                cmds.setAttr('%s.radius' % sub_joint, radius / 2)

            if self._twist_joint_name:
                new_joints = []
                for twist_joint in self.sub_joints:
                    new_joints.append(cmds.rename(twist_joint, core.inc_name(self._twist_joint_name)))

                    self.sub_joints = new_joints

# ---Body Rig


class SpineRig(BufferRig, SplineRibbonBaseRig):

    def __init__(self, description, side=None):

        super(SpineRig, self).__init__(description, side)

        self.bottom_color = None
        self.tweak_control_count = 2
        self.control_count = 1
        self.forward_fk = True
        self.btm_pivot = None
        self.top_pivot = None
        self.fk_pivots = []
        self.control_size = 1
        self.sub_control_size = .9

        self.top_hold_locator = None
        self.btm_hold_locator = None

        self.btm_color = None
        self.btm_curve_type = None
        self.top_color = None
        self.top_curve_type = None

        self.fk_color = None
        self.fk_curve_type = None
        self.sub_fk_count = 2
        self.sub_fk_color = None

        self.tweak_color = None
        self.tweak_curve_type = None

        self.orient_controls_to_joints = False

        self.create_buffer_joints = False
        self.stretch_on_off = True
        self.create_single_fk_follows = True
        self.create_sub_fk_controls = False
        self.create_sub_bottom_controls = False
        self.create_sub_top_controls = False

        self.hold_top = True
        self.hold_btm = True

        self.evenly_space_cvs = True

        self.sub_controls_dict = {}

    def _attach_joints(self, source_chain, target_chain):

        if not self.attach_joints:
            return
        if self.hold_top:
            self.top_hold_locator = cmds.spaceLocator(n=core.inc_name(self._get_name('locator', 'holdTop')))[0]

            cmds.hide(self.top_hold_locator)

            space.MatchSpace(source_chain[-1], self.top_hold_locator).translation_rotation()

        parent = cmds.listRelatives(target_chain[0], p=True)

        if parent:
            cmds.parent(target_chain[-1], parent)
            xform = space.create_xform_group(target_chain[-1])
            space.create_xform_group(target_chain[-1], 'buffer')
            cmds.reorder(xform, r=-1)

        temp_source = list(source_chain)
        if self.hold_top:
            temp_source[-1] = self.top_hold_locator

        if self.hold_btm:
            self.btm_hold_locator = cmds.spaceLocator(n=core.inc_name(self._get_name('locator', 'holdBtm')))[0]
            cmds.hide(self.btm_hold_locator)
            space.MatchSpace(source_chain[0], self.btm_hold_locator).translation_rotation()
            temp_source[0] = self.btm_hold_locator

        space.AttachJoints(temp_source, target_chain).create()

        if cmds.objExists('%s.switch' % target_chain[0]):
            switch = rigs_util.RigSwitch(target_chain[0])

            weight_count = switch.get_weight_count()

            if weight_count > 0:
                if self.auto_control_visibility:
                    switch.add_groups_to_index((weight_count - 1), self.control_group)
                switch.create()

    def _create_before_attach_joints(self):
        super(SpineRig, self)._create_before_attach_joints()

        self._attach_to_geo()

    def _create_curve(self, span_count):

        if not self.curve:

            name = self._get_name()

            self.orig_curve = geo.transforms_to_curve(self.joints, span_count, name)
            cmds.setAttr('%s.inheritsTransform' % self.orig_curve, 0)

            self.curve = cmds.duplicate(self.orig_curve)[0]

            cmds.rebuildCurve(self.curve,
                              spans=span_count,
                              rpo=True,
                              rt=0,
                              end=1,
                              kr=False,
                              kcp=False,
                              kep=True,
                              kt=True,
                              d=2)

            if self.evenly_space_cvs:
                geo.evenly_position_curve_cvs(self.curve, match_curve=self.orig_curve)

            name = self.orig_curve

            self.orig_curve = cmds.rename(self.orig_curve, core.inc_name('orig_curve'))
            self.curve = cmds.rename(self.curve, name)
            cmds.parent(self.orig_curve, self.setup_group)

            cmds.parent(self.curve, self.setup_group)

    def _create_clusters(self):

        if self.ribbon:
            cluster_surface = deform.ClusterSurface(self.surface, self.description)

        if not self.ribbon:
            cluster_surface = deform.ClusterCurve(self.curve, self.description)

        cluster_surface.set_join_ends(False)
        cluster_surface.create()

        self.clusters = cluster_surface.handles
        cluster_group = self._create_setup_group('clusters')
        cmds.parent(self.clusters, cluster_group)

        return self.clusters

    def _wire_hires(self, curve):

        self.ik_curve = curve

    """
    def _attach_to_geo(self):
        if not self.attach_joints:
            return

        if self.ribbon:
            rivet_group = self._create_setup_group('rivets')

            for joint in self.buffer_joints:
                rivet = geo.attach_to_surface(joint, self.surface)
                cmds.setAttr('%s.inheritsTransform' % rivet, 0)
                cmds.parent(rivet, rivet_group)

        if not self.ribbon:
            self._create_spline_ik()
        """

    def _orient_to_closest_joint(self, xform):

        if not self.orient_controls_to_joints:
            return

        orient_joint = space.get_closest_transform(xform, self.buffer_joints)
        space.MatchSpace(orient_joint, xform).rotation()

    def _create_btm_control(self):

        control = self._create_control(curve_type=self.btm_curve_type)
        control.hide_scale_attributes()
        control.scale_shape(1.4, 1.4, 1.4)

        if self.btm_color is not None:
            control.color(self.btm_color)

        control = control.control

        if self.create_sub_bottom_controls:
            self._create_sub_controls(control, None, self.btm_curve_type)

        xform = space.create_xform_group(control)
        space.MatchSpace(self.joints[0], xform).translation()

        if self.btm_pivot:
            self._set_pivot_vector(xform, self.btm_pivot)

        self._orient_to_closest_joint(xform)

        self.btm_control = control

    def _create_top_control(self):

        control = self._create_control(curve_type=self.top_curve_type)
        control.hide_scale_attributes()
        control.scale_shape(1.4, 1.4, 1.4)

        if self.top_color is not None:
            control.color(self.top_color)

        control = control.control

        if self.create_sub_top_controls:
            self._create_sub_controls(control, None, self.top_curve_type)

        xform = space.create_xform_group(control)

        space.MatchSpace(self.joints[-1], xform).translation()

        if self.top_pivot:
            self._set_pivot_vector(xform, self.top_pivot)

        self._orient_to_closest_joint(xform)

        self.top_control = control

    def _create_tweak_controls(self):

        group = self._create_control_group('tweak')

        follow = 0

        sub_follow = 1.0 / (len(self.clusters) - 2)

        self.tweak_controls = []

        for cluster in self.clusters:

            control = self._create_control(sub=True, curve_type=self.tweak_curve_type)

            control.hide_scale_attributes()

            if self.tweak_color is not None:
                control.color(self.tweak_color)

            control = control.control

            xform = space.create_xform_group(control)

            space.MatchSpace(cluster, xform).translation_to_rotate_pivot()

            self._orient_to_closest_joint(xform)

            cmds.parentConstraint(control, cluster)

            if follow > 1:
                follow = 1

            cmds.parent(xform, group)

            top_control = self.top_control
            btm_control = self.btm_control

            if top_control in self.sub_controls_dict:
                top_control = self.sub_controls_dict[top_control][-1]

            if btm_control in self.sub_controls_dict:
                btm_control = self.sub_controls_dict[btm_control][-1]

            if cluster != self.clusters[0] and cluster != self.clusters[-1]:
                space.create_multi_follow([btm_control, top_control], xform, control, attribute_name='follow',
                                          value=follow)

            if cluster == self.clusters[0]:
                cmds.parent(xform, btm_control)
            if cluster == self.clusters[-1]:
                cmds.parent(xform, top_control)

            self.tweak_controls.append(control)

            self._connect_sub_visibility('%s.tweakVisibility' % self.top_control, control)

            follow += sub_follow

    def _create_sub_controls(self, control, description, curve_type):

        subs = []

        for inc in range(0, self.sub_fk_count):

            number = vtool.util.get_last_number(control)

            if not description:
                description = number

            sub_control = self._create_control(sub=True, description=description, curve_type=curve_type)

            attr.connect_message(sub_control, control, 'group_sub')

            if inc == 1:
                sub_control.scale_shape(0.9, 0.9, 0.9)

            if self.sub_fk_color:
                sub_control.color(self.sub_fk_color)

            sub_control.hide_scale_and_visibility_attributes()

            space.MatchSpace(control, sub_control.get()).translation_rotation()

            self._connect_sub_visibility('%s.subVisibility' % control, sub_control.get())

            if not subs:
                cmds.parent(sub_control.get(), control)
            if subs:
                cmds.parent(sub_control.get(), subs[-1])

            subs.append(sub_control.get())

        self.sub_controls_dict[control] = subs

    def _create_fk_controls(self):

        group = self._create_control_group('fk')

        if not self.control_count:
            return

        xforms = []
        controls = []
        self._fk_shapes = []

        for inc in range(0, self.control_count):

            control = self._create_control(description='mid', curve_type=self.fk_curve_type)
            control.hide_scale_attributes()

            if self.fk_color is not None:
                control.color(self.fk_color)

            control = control.control

            xform = space.create_xform_group(control)

            xforms.append(xform)
            controls.append(control)

            cmds.parent(xform, group)

            shapes = cmds.listRelatives(control, shapes=True)
            self._fk_shapes += shapes

            if self.create_sub_fk_controls:
                self._create_sub_controls(control, 'mid_%s' % (inc + 1), self.fk_curve_type)

        self._snap_transforms_to_curve(xforms, self.curve)

        pivot_count = len(self.fk_pivots)
        xform_count = len(xforms)

        for inc in range(0, pivot_count):

            if inc > xform_count - 1:
                break

            transform = xforms[inc]

            self._set_pivot_vector(transform, self.fk_pivots[inc])

        if self.forward_fk == False:
            xforms.reverse()
            controls.reverse()

        last_control = None

        for inc in range(0, len(controls)):

            xform = xforms[inc]
            control = controls[inc]

            self._orient_to_closest_joint(xform)

            if last_control:
                if not self.sub_controls_dict:
                    cmds.parent(xform, last_control)
                if self.sub_controls_dict:
                    cmds.parent(xform, self.sub_controls_dict[last_control][-1])

            last_control = control

        self.fk_controls = controls

    def _fk_post_top_setup(self):

        last_control = self.fk_controls[-1]

        if self.forward_fk == True:
            top_xform = space.get_xform_group(self.top_control)
        if self.forward_fk == False:
            top_xform = space.get_xform_group(self.btm_control)

        if not self.sub_controls_dict:
            cmds.parent(top_xform, last_control)
        if self.sub_controls_dict:
            cmds.parent(top_xform, self.sub_controls_dict[last_control][-1])

        for shape in self._fk_shapes:
            attr.connect_visibility('%s.fkVisibility' % self.top_control, shape, True)

    def _create_mid_follow(self):

        if not self.create_single_fk_follows:
            return

        if self.control_count == 1:

            if self.forward_fk == False:
                value1 = 0
                value2 = 1
            if self.forward_fk == True:
                value1 = 1
                value2 = 0

            fk_control = self.fk_controls[-1]

            if self.sub_controls_dict:
                fk_control = self.sub_controls_dict[fk_control][-1]

            space.create_multi_follow([self.control_group, fk_control], space.get_xform_group(self.top_control),
                                      self.top_control, value=value1)
            space.create_multi_follow([self.control_group, fk_control], space.get_xform_group(self.btm_control),
                                      self.btm_control, value=value2)

    def _snap_transforms_to_curve(self, transforms, curve):

        if self.ribbon:
            max_value_u = cmds.getAttr('%s.maxValueU' % self.surface)
            curve = cmds.duplicateCurve('%s.u[%s]' % (self.surface, (max_value_u / 2.0)), ch=False, rn=0, local=0)[0]

        count = len(transforms) + 2

        total_length = cmds.arclen(curve)

        part_length = total_length / (count - 1)

        if count - 1 == 0:
            part_length = 0

        current_length = part_length

        temp_curve = cmds.duplicate(curve)[0]

        for inc in range(0, count - 2):

            param = geo.get_parameter_from_curve_length(temp_curve, current_length)
            position = geo.get_point_from_curve_parameter(temp_curve, param)

            transform = transforms[inc]

            if cmds.nodeType(transform) == 'joint':
                cmds.move(position[0], position[1], position[2], '%s.scalePivot' % transform,
                          '%s.rotatePivot' % transform, a=True)

            if not cmds.nodeType(transform) == 'joint':
                cmds.xform(transform, ws=True, t=position)

            current_length += part_length

        cmds.delete(temp_curve)

        if self.ribbon:
            cmds.delete(curve)

    def _set_pivot_vector(self, transform, value):
        list_value = vtool.util.convert_to_sequence(value)

        if len(list_value) == 3:
            vector_value = list_value
            cmds.xform(transform, os=True, t=vector_value, r=True)

        if len(list_value) == 1:
            if cmds.nodeType(list_value[0]) == 'transform' or cmds.nodeType(list_value[0]) == 'joint':
                vector_value = cmds.xform(list_value[0], q=True, t=True, ws=True)
                cmds.xform(transform, ws=True, t=vector_value)

    def set_tweak_control_count(self, control_count):
        """
        Set the number of sub controls
        """

        if control_count < 1:
            control_count = 1

        self.tweak_control_count = control_count

    def set_tweak_control_shape(self, curve_type):
        self.tweak_curve_type = curve_type

    def set_tweak_control_color(self, color_value):
        self.tweak_color = color_value

    def set_bottom_pivot(self, value):

        self.btm_pivot = value

    def set_bottom_control_shape(self, curve_type):
        self.btm_curve_type = curve_type

    def set_bottom_control_color(self, color_value):
        self.bottom_color = color_value

    def set_create_bottom_sub_controls(self, bool_value):
        self.create_sub_bottom_controls = bool_value

    def set_top_pivot(self, value):

        self.top_pivot = value

    def set_top_control_shape(self, curve_type):
        self.top_curve_type = curve_type

    def set_top_control_color(self, color_value):
        self.top_color = color_value

    def set_create_top_sub_controls(self, bool_value):
        self.create_sub_top_controls = bool_value

    def set_fk_control_count(self, control_count):
        """
        Set the number of fk controls.
        """
        if control_count < 0:
            control_count = 0

        self.control_count = control_count

    def set_fk_control_one_sub(self, bool_value):

        if bool_value:
            self.sub_fk_count = 1

    def set_fk_control_sub_color(self, number):

        self.sub_fk_color = number

    def set_fk_pivots(self, values):

        list_values = vtool.util.convert_to_sequence(values)

        self.fk_pivots = list_values

    def set_fk_forward(self, bool_value):
        self.forward_fk = bool_value

    def set_fk_control_shape(self, curve_type):

        self.fk_curve_type = curve_type

    def set_fk_control_color(self, color_value):
        self.fk_color = color_value

    def set_fk_single_control_follow(self, bool_value):
        self.create_single_fk_follows = bool_value

    def set_create_fk_sub_controls(self, bool_value):

        self.create_sub_fk_controls = bool_value

    def set_orient_controls_to_joints(self, bool_value):

        self.orient_controls_to_joints = bool_value

    def set_hold_top_joint(self, bool_value):
        self.hold_top = bool_value

    def set_hold_bottom_joint(self, bool_value):

        self.hold_btm = bool_value

    def set_evenly_space_cvs(self, bool_value):
        self.evenly_space_cvs = bool_value

    def create(self):

        self._create_geo(self.tweak_control_count)

        if self.ribbon:
            geo = self.surface
        if not self.ribbon:
            geo = self.curve

        self._create_clusters()

        super(SpineRig, self).create()

        self._create_btm_control()
        self._create_fk_controls()

        self._create_top_control()

        self._fk_post_top_setup()

        self._create_tweak_controls()

        self._create_mid_follow()

        if self.stretch_on_off:
            if not self.ribbon:
                cmds.parent(self.end_locator, self.tweak_controls[-1])
                cmds.parent(self.start_locator, self.tweak_controls[0])

            self._setup_stretchy(self.top_control)

            if not self.ribbon:
                cmds.setAttr('%s.stretchOnOff' % self.top_control, 1)
            if self.ribbon:
                cmds.setAttr('%s.stretchOffOn' % self.top_control, 1)

        if self.top_hold_locator:
            cmds.parent(self.top_hold_locator, self.top_control)

            if self.stretch_on_off and not self.ribbon:
                space.create_multi_follow([self.buffer_joints[-1], self.tweak_controls[-1]], self.top_hold_locator,
                                          constraint_type='pointConstraint')
                cmds.orientConstraint(self.tweak_controls[-1], self.top_hold_locator, mo=True)
                cmds.connectAttr('%s.stretchOnOff' % self.top_control, '%s.follow' % self.top_hold_locator)

            if not self.stretch_on_off:
                cmds.parentConstraint(self.tweak_controls[-1], self.top_hold_locator, mo=True)

        if self.btm_hold_locator:
            cmds.parent(self.btm_hold_locator, self.btm_control)

            if self.stretch_on_off and not self.ribbon:
                space.create_multi_follow([self.buffer_joints[0], self.tweak_controls[0]], self.btm_hold_locator,
                                          constraint_type='pointConstraint')
                cmds.orientConstraint(self.tweak_controls[0], self.btm_hold_locator, mo=True)
                cmds.connectAttr('%s.stretchOnOff' % self.top_control, '%s.follow' % self.btm_hold_locator)

            if not self.stretch_on_off:
                cmds.parentConstraint(self.tweak_controls[0], self.btm_hold_locator, mo=True)

    def get_tweak_controls(self):

        return self.tweak_controls

    def get_fk_controls(self):

        return self.fk_controls

    def get_top_and_btm_controls(self):

        return [self.top_control, self.btm_control]


class NeckRig(FkCurveRig):

    def __init__(self, description, side=None):
        super(NeckRig, self).__init__(description, side)

    def _first_increment(self, control, current_transform):
        self.first_control = control


class IkLegRig(IkAppendageRig):

    def __init__(self, description, side=None):

        super(IkLegRig, self).__init__(description, side)

    def _fix_right_side_orient(self, control, axis='yz'):

        if not self.right_side_fix:
            return

        if not self.side == 'R':
            return

        xform_locator = cmds.spaceLocator()[0]

        match_space = space.MatchSpace(control, xform_locator)
        match_space.translation_rotation()

        spacer = space.create_xform_group(xform_locator)

        for letter in axis:
            cmds.setAttr('%s.rotate%s' % (xform_locator, letter.upper()), 180)

        match_space = space.MatchSpace(xform_locator, control)
        match_space.translation_rotation()

        cmds.delete(spacer)

    def _xform_top_control(self, control):

        match_space = space.MatchSpace(self.ik_chain[0], control)
        match_space.translation_rotation()

        self._fix_right_side_orient(control, 'z')

        cmds.parentConstraint(control, self.ik_chain[0], mo=True)

        xform_group = space.create_xform_group(control)

        if self.negate_right_scale and self.side == 'R':
            cmds.setAttr('%s.scaleX' % xform_group, self.negate_right_scale_values[0])
            cmds.setAttr('%s.scaleY' % xform_group, self.negate_right_scale_values[1])
            cmds.setAttr('%s.scaleZ' % xform_group, self.negate_right_scale_values[2])

    def _create_pole_vector(self):

        control = self.pole_control
        self.pole_control = self.pole_control.get()

        attr.create_title(self.btm_control, 'POLE_VECTOR')

        pole_vis = attr.MayaNumberVariable('poleVisibility')
        pole_vis.set_variable_type(pole_vis.TYPE_BOOL)
        pole_vis.create(self.btm_control)

        self._create_pole_twist_attrs()

        pole_joints = self._get_pole_joints()

        position = space.get_polevector(pole_joints[0], pole_joints[1], pole_joints[2], self.pole_offset)
        cmds.move(position[0], position[1], position[2], control.get())

        match_space = space.MatchSpace(self.btm_control, control.get())
        match_space.rotation()

        self._create_pole_constraint(control.get(), self.ik_handle)

        xform_group = space.create_xform_group(control.get())

        if self.create_twist:

            follow_group = space.create_follow_group(self.top_control, xform_group)
            constraint = cmds.parentConstraint(self.twist_guide, follow_group, mo=True)[0]

            constraint_editor = space.ConstraintEditor()
            constraint_editor.create_switch(self.btm_control, 'autoTwist', constraint)
            cmds.setAttr('%s.autoTwist' % self.btm_control, 1)

            twist_offset = attr.MayaNumberVariable('autoTwistOffset')
            twist_offset.create(self.btm_control)

            if self.side == 'L':
                twist_offset.connect_out('%s.rotateY' % self.offset_pole_locator)
            if self.side == 'R':
                attr.connect_multiply('%s.autoTwistOffset' % self.btm_control,
                                      '%s.rotateY' % self.offset_pole_locator, -1)

        if not self.create_twist:
            follow_group = space.create_follow_group(self.top_control, xform_group)

        # cmds.parent(follow_group,  self.control_group )

        name = self._get_name()

        rig_line = rigs_util.RiggedLine(pole_joints[1], control.get(), name).create()
        cmds.parent(rig_line, self.control_group)

        pole_vis.connect_out('%s.visibility' % xform_group)
        pole_vis.connect_out('%s.visibility' % rig_line)


class IkFrontLegRig(IkAppendageRig):

    def __init__(self, description, side=None):
        super(IkFrontLegRig, self).__init__(description, side)

        self.right_side_fix = False

    def _create_top_control(self):

        self.top_control = super(IkFrontLegRig, self)._create_top_control()

        if not core.has_shape_of_type(self.top_control, 'spaceLocator'):
            control = rigs_util.Control(self.top_control)
            control.rotate_shape(0, 0, 90)

        return self.top_control

    def _create_twist_joint(self, top_control):

        top_guide_joint, btm_guide_joint, guide_ik = space.create_pole_chain(self.buffer_joints[0],
                                                                             self.buffer_joints[-1], 'guide')
        self._setup_twist_joint(top_guide_joint, btm_guide_joint, guide_ik)

    def _setup_twist_joint(self, top_guide_joint, btm_guide_joint, guide_ik):

        top_guide_joint = cmds.rename(top_guide_joint, self._get_name('joint', 'poleTop'))
        cmds.rename(btm_guide_joint, self._get_name('joint', 'poleBtm'))
        guide_ik = cmds.rename(guide_ik, self._get_name('ikHandle', 'poleGuide'))

        self.twist_guide = top_guide_joint

        cmds.parent(top_guide_joint, self.setup_group)
        cmds.parent(guide_ik, self.setup_group)

        cmds.pointConstraint(self.top_control, top_guide_joint)

        self.off_offset_locator = cmds.spaceLocator(n=core.inc_name(self._get_name('offset', 'guideTwist')))[0]
        space.MatchSpace(self.sub_control, self.off_offset_locator).translation_rotation()

        cmds.parent(self.off_offset_locator, self.top_control)

        cmds.pointConstraint(self.offset_locator, guide_ik, mo=True)

        self.twist_guide_ik = guide_ik
        cmds.hide(self.off_offset_locator)

    def _create_offset_locator(self):

        if self.sub_control:
            self.offset_locator = cmds.spaceLocator(n=core.inc_name('offset_%s' % self.sub_control))[0]
            cmds.parent(self.offset_locator, self.sub_control)

            match_space = space.MatchSpace(self.sub_control, self.offset_locator)
            match_space.translation_rotation()

        if not self.sub_control:
            self.offset_locator = cmds.spaceLocator(n=core.inc_name('offset_%s' % self.btm_control))[0]
            cmds.parent(self.offset_locator, self.btm_control)

            match_space = space.MatchSpace(self.btm_control, self.offset_locator)
            match_space.translation_rotation()

        space.create_xform_group(self.offset_locator)
        cmds.hide(self.offset_locator)
        self.offset_pole_locator = self.offset_locator

    def _create_pole_twist_attrs(self):
        super(IkFrontLegRig, self)._create_pole_twist_attrs()

    def _create_pole_vector(self):

        control = self.pole_control
        self.pole_control = self.pole_control.get()

        attr.create_title(self.btm_control, 'POLE_VECTOR')

        pole_vis = attr.MayaNumberVariable('poleVisibility')
        pole_vis.set_variable_type(pole_vis.TYPE_BOOL)

        if self.sub_visibility:
            pole_vis.set_value(1)

        pole_vis.create(self.btm_control)

        self._create_pole_twist_attrs()

        pole_joints = self._get_pole_joints()

        position = space.get_polevector(pole_joints[0], pole_joints[1], pole_joints[2], self.pole_offset)
        cmds.move(position[0], position[1], position[2], control.get())

        self._create_pole_constraint(control.get(), self.ik_handle)

        xform_group = space.create_xform_group(control.get())

        self.pole_vector_xform = xform_group

        if self.create_twist:
            self._create_twist_guide_follow()

        if not self.create_twist:
            if self.pole_follow_transform:
                space.create_follow_group(self.pole_follow_transform, xform_group)

        name = self._get_name()

        rig_line = rigs_util.RiggedLine(pole_joints[1], control.get(), name).create()
        cmds.parent(rig_line, self.control_group)

        pole_vis.connect_out('%s.visibility' % xform_group)
        pole_vis.connect_out('%s.visibility' % rig_line)

    def _create_twist_guide_follow(self):
        if not self.pole_follow_transform:
            cmds.parentConstraint(self.twist_guide, self.pole_vector_xform, mo=True)[0]
        if self.pole_follow_transform:
            sequence = vtool.util.convert_to_sequence(self.pole_follow_transform)
            sequence.append(self.twist_guide)

            space.create_multi_follow_direct(sequence, self.pole_vector_xform, self.pole_control)

        space.create_multi_follow([self.off_offset_locator, self.offset_locator],
                                  self.twist_guide_ik, self.btm_control,
                                  attribute_name='autoTwist',
                                  value=0,
                                  create_title=False)

    def _create_stretchy(self, top_transform, btm_transform, control):
        stretchy = rigs_util.StretchyChain()
        stretchy.set_joints(self.ik_chain)
        # dampen should be damp... dampen means wet, damp means diminish
        stretchy.set_add_dampen(True, 'damp')
        stretchy.set_node_for_attributes(control)
        stretchy.set_description(self._get_name())
        stretchy.set_scale_axis(self.stretch_axis)
        stretchy.set_scale_attribute_offset(self.stretch_scale_attribute_offset)

        top_locator, btm_locator = stretchy.create()

        cmds.parent(top_locator, top_transform)
        cmds.parent(btm_locator, self.offset_locator)

    def create(self):
        super(IkFrontLegRig, self).create()

        cmds.setAttr('%s.translateY' % self.pole_vector_xform, 0)

        ik_xform = cmds.listRelatives(self.ik_handle, p=True)
        cmds.parent(ik_xform, self.offset_locator)


class IkScapulaRig(BufferRig):

    def __init__(self, description, side=None):

        self._scapula_rotate_axis = None
        self._arm_rotate_axis = None
        self.control_shape = 'square'

        super(IkScapulaRig, self).__init__(description, side)

        self.control_offset = 10

        self.create_rotate_control = False
        self.ik_joints = None

        self.negate_right_scale = False

        self.offset_axis = 'X'
        self.rotate_control = None

        self._duplicate_chain_replace = [self.joint_name_token, 'ik']

        self._arm_joint = None
        self._ik_aim_control_shape = None

    def _duplicate_scapula(self):

        duplicate = space.DuplicateHierarchy(self.joints[0])
        duplicate.stop_at(self.joints[-1])
        duplicate.only_these(self.joints)

        duplicate.replace(self._duplicate_chain_replace[0], self._duplicate_chain_replace[1])
        joints = duplicate.create()

        self.ik_joints = joints
        cmds.parent(self.ik_joints[0], self.setup_group)

    def _create_top_control(self):

        control = self._create_control(curve_type=self._ik_aim_control_shape)
        control.hide_scale_and_visibility_attributes()

        self._offset_control(control)

        xform = space.create_xform_group(control.get())

        if self.side == 'R':

            if self.negate_right_scale:
                cmds.setAttr('%s.scaleZ' % xform, -1)
                cmds.setAttr('%s.rotateY' % xform, 180)

        return control.get()

    def _create_shoulder_control(self):

        control = self._create_control()
        control.hide_scale_and_visibility_attributes()

        ik_joints = self.joints

        if self.ik_joints:
            ik_joints = self.ik_joints

        space.MatchSpace(self.joints[0], control.get()).translation()

        xform = space.create_xform_group(control.get())

        space.create_xform_group(control.get(), 'driver')

        if self.side == 'R':

            if self.negate_right_scale:
                cmds.setAttr('%s.scaleZ' % xform, -1)
                cmds.setAttr('%s.rotateY' % xform, 180)

        under_group = cmds.group(n='under_%s' % control.get(), em=True)

        cmds.parent(under_group, control.get())
        space.zero_out_transform_channels(under_group)

        space.create_follow_group(under_group, ik_joints[0])

        self.shoulder_control = control.get()

        return control.get()

    def _offset_control(self, control):

        offset = cmds.group(em=True)
        match_space = space.MatchSpace(self.joints[-1], offset)
        match_space.translation_rotation()

        if self.offset_axis == 'X':
            vector = [self.control_offset, 0, 0]
        if self.offset_axis == 'Y':
            vector = [0, self.control_offset, 0]
        if self.offset_axis == 'Z':
            vector = [0, 0, self.control_offset]

        cmds.move(vector[0], vector[1], vector[2], offset, os=True, wd=True, r=True)

        match_space = space.MatchSpace(offset, control.get())
        match_space.translation()

        cmds.delete(offset)

    def _create_ik(self, control):

        ik_joints = self.joints

        if self.ik_joints:
            ik_joints = self.ik_joints

        handle = space.IkHandle(self._get_name())
        handle.set_start_joint(ik_joints[0])
        handle.set_end_joint(ik_joints[-1])
        handle.set_solver(handle.solver_sc)
        handle = handle.create()

        xform = space.create_xform_group(handle)
        space.MatchSpace(control, xform).translation()

        cmds.parent(xform, control)
        cmds.hide(handle)

    def _create_rotate_control(self):

        control = self._create_control('rotate')
        control.hide_scale_and_visibility_attributes()

        space.MatchSpace(self.joints[0], control.get()).translation_rotation()
        self.xform_rotate = space.create_xform_group(control.get())

        driver = space.create_xform_group(control.get(), 'driver')

        control.scale_shape(.6, .9, .6)

        self._rotate_control_driver = driver
        self.rotate_control = control.get()

    def set_control_offset(self, value):
        self.control_offset = value

    def set_create_rotate_control(self, bool_value):
        self.create_rotate_control = bool_value

    def set_negate_right_scale(self, bool_value):
        self.negate_right_scale = bool_value

    def set_offset_axis(self, axis_letter):

        axis_letter = axis_letter.upper()

        self.offset_axis = axis_letter

    def set_duplicate_chain_replace(self, replace_this, with_this):

        self._duplicate_chain_replace = [replace_this, with_this]

    def set_auto_arm_rotate(self, arm_joint, arm_rotate_axis, scapula_rotate_axis):
        self._arm_joint = arm_joint
        self._arm_rotate_axis = arm_rotate_axis
        self._scapula_rotate_axis = scapula_rotate_axis

    def set_ik_aim_control_shape(self, curve_type):
        self._ik_aim_control_shape = curve_type

    def create(self):
        super(IkScapulaRig, self).create()

        if self.create_rotate_control:
            self._duplicate_scapula()

        control = self._create_top_control()
        self._create_shoulder_control()

        self._create_ik(control)

        rig_line = rigs_util.RiggedLine(control, self.joints[-1], self._get_name()).create()
        cmds.parent(rig_line, self.control_group)

        attr.create_title(self.shoulder_control, 'Scapula')

        cmds.addAttr(self.shoulder_control, ln='aimVisibility', at='bool', k=True, dv=1)

        if self.create_rotate_control:
            self._create_rotate_control()

        cmds.connectAttr('%s.aimVisibility' % self.shoulder_control, '%s.visibility' % rig_line)
        cmds.connectAttr('%s.aimVisibility' % self.shoulder_control, '%sShape.visibility' % control)

        if self.create_rotate_control:
            cmds.parent(self.xform_rotate, self.shoulder_control)
            space.create_follow_group(self.ik_joints[0], self.xform_rotate, use_duplicate=True)

        if self.negate_right_scale and self.side == 'R':
            cmds.setAttr('%s.scaleX' % self.xform_rotate, -1)
            cmds.setAttr('%s.scaleY' % self.xform_rotate, -1)
            cmds.setAttr('%s.scaleZ' % self.xform_rotate, -1)

        if self.rotate_control:
            cmds.parentConstraint(self.rotate_control, self.joints[0], mo=True)

        if self._arm_joint:
            attr.create_title(self.rotate_control, 'ARM_ROTATE')
            cmds.addAttr(self.rotate_control, ln='autoArmRotate', k=True, dv=0, min=0, max=1)

            multi = attr.connect_multiply('%s.rotate%s' % (self._arm_joint, self._arm_rotate_axis),
                                          '%s.rotate%s' % (self._rotate_control_driver, self._scapula_rotate_axis),
                                          value=0)

            cmds.connectAttr('%s.autoArmRotate' % self.rotate_control, '%s.input2X' % multi)


class IkBackLegRig(IkFrontLegRig):

    def __init__(self, description, side=None):
        super(IkBackLegRig, self).__init__(description, side)

        self.offset_control_to_locator = False
        self.right_side_fix = False
        self._offset_ankle_axis = 'Z'
        self._offset_ankle_orient = None
        self._pole_at_knee_only = False
        self._offset_shape = 'square'
        self.invert_poles = False
        self.invert_twist = False

    def _duplicate_joints(self):

        super(IkBackLegRig, self)._duplicate_joints()

        duplicate = space.DuplicateHierarchy(self.joints[0])
        duplicate.stop_at(self.joints[-1])
        duplicate.only_these(self.joints)
        duplicate.replace(self._duplicate_chain_replace[0], self._duplicate_chain_replace[1])
        self.ik_chain = duplicate.create()

        ik_group = self._create_group()

        cmds.parent(self.ik_chain[0], ik_group)
        cmds.parent(ik_group, self.setup_group)

        self._create_offset_chain(ik_group)

        for inc in range(0, len(self.offset_chain)):
            cmds.parentConstraint(self.offset_chain[inc], self.buffer_joints[inc], mo=True)
            attr.connect_scale(self.offset_chain[inc], self.buffer_joints[inc])

            cmds.connectAttr('%s.scale%s' % (self.ik_chain[inc], self.stretch_axis),
                             '%s.scale%s' % (self.offset_chain[inc], self.stretch_axis))

        cmds.orientConstraint(self.ik_chain[-1], self.buffer_joints[-1], mo=True)

        cmds.parentConstraint(self.ik_chain[0], self.offset_chain[0], mo=True)

    def _create_twist_joint(self, top_control):

        if not self._pole_at_knee_only:
            solver = space.IkHandle.solver_sc
        else:
            solver = space.IkHandle.solver_rp

        top_guide_joint, btm_guide_joint, guide_ik = space.create_pole_chain(self.buffer_joints[0],
                                                                             self.buffer_joints[-1], 'guide', solver)
        self._setup_twist_joint(top_guide_joint, btm_guide_joint, guide_ik)

    def _create_offset_chain(self, parent=None):

        if not parent:
            parent = self.setup_group

        duplicate = space.DuplicateHierarchy(self.joints[0])
        duplicate.stop_at(self.joints[-1])
        duplicate.replace(self._duplicate_chain_replace[0], 'offset')
        duplicate.only_these(self.joints)
        self.offset_chain = duplicate.create()

        cmds.parent(self.offset_chain[0], self.setup_group)

        duplicate = space.DuplicateHierarchy(self.offset_chain[-2])
        duplicate.replace('offset', 'sway')
        self.lower_offset_chain = duplicate.create()

        cmds.parent(self.lower_offset_chain[1], self.offset_chain[-2])
        cmds.parent(self.lower_offset_chain[0], self.lower_offset_chain[1])
        cmds.makeIdentity(self.lower_offset_chain, apply=True, t=1, r=1, s=1, n=0, jointOrient=True)
        cmds.parent(self.lower_offset_chain[1], self.setup_group)
        self.lower_offset_chain.reverse()

        cmds.connectAttr('%s.scale%s' % (self.offset_chain[-2], self.stretch_axis),
                         '%s.scale%s' % (self.lower_offset_chain[0], self.stretch_axis))

        cmds.delete(self.offset_chain[-1])
        self.offset_chain.pop(-1)

        cmds.orientConstraint(self.lower_offset_chain[0], self.offset_chain[-1])

    def _get_pole_joints(self):

        if not self.pole_angle_joints:

            if self._pole_at_knee_only:
                return self.offset_chain
            else:
                return [self.ik_chain[0], self.ik_chain[1], self.ik_chain[2]]

        return self.pole_angle_joints

    def _create_offset_control(self):

        if not self.offset_control_to_locator:
            control = self._create_control(description='offset', curve_type=self._offset_shape)
            control.hide_scale_and_visibility_attributes()
            control.scale_shape(2, 2, 2)

            self.offset_control = control.get()

            match_space = space.MatchSpace(self.lower_offset_chain[1], self.offset_control)
            match_space.rotation()

            match_space = space.MatchSpace(self.lower_offset_chain[0], self.offset_control)
            match_space.translation()

        if self.offset_control_to_locator:
            self.offset_control = cmds.spaceLocator(n=core.inc_name('locator_%s' % self._get_name('offset')))[0]

            match_space = space.MatchSpace(self.lower_offset_chain[0], self.offset_control)
            match_space.translation()
            cmds.hide(self.offset_control)

        if self._offset_ankle_orient:
            space.MatchSpace(self._offset_ankle_orient, self.offset_control).rotation()

        cmds.parentConstraint(self.offset_control, self.lower_offset_chain[0], mo=True)

        space.create_xform_group(self.offset_control)
        driver_group = space.create_xform_group(self.offset_control, 'driver')

        attr.create_title(self.btm_control, 'ANKLE')
        offset = attr.MayaNumberVariable('offsetAnkle')

        offset.create(self.btm_control)
        self._offset_attr = offset

        self._offset_attr.connect_out('%s.rotate%s' % (driver_group, self._offset_ankle_axis))

        if not self.offset_control_to_locator:
            control.hide_translate_attributes()

        return self.offset_control

    def _rig_offset_chain(self):

        ik_handle = space.IkHandle(self._get_name('offset_top'))

        ik_handle.set_start_joint(self.offset_chain[0])
        ik_handle.set_end_joint(self.offset_chain[-1])
        if not self._pole_at_knee_only:
            ik_handle.set_solver(ik_handle.solver_sc)
        else:
            ik_handle.set_solver(ik_handle.solver_rp)

        ik_handle = ik_handle.create()

        self._offset_handle = ik_handle

        cmds.parent(ik_handle, self.lower_offset_chain[-1])

        ik_handle_btm = space.IkHandle(self._get_name('offset_btm'))
        ik_handle_btm.set_start_joint(self.lower_offset_chain[0])
        ik_handle_btm.set_end_joint(self.lower_offset_chain[-1])
        if not self._pole_at_knee_only:
            ik_handle_btm.set_solver(ik_handle_btm.solver_sc)
        else:
            ik_handle_btm.set_solver(ik_handle_btm.solver_rp)

        ik_handle_btm = ik_handle_btm.create()
        self.ik_handle_offset = ik_handle_btm

        follow = space.create_follow_group(self.offset_control, ik_handle_btm)
        cmds.parent(follow, self.setup_group)
        cmds.hide(ik_handle_btm)

        xform_group = space.get_xform_group(self.offset_control)

        follow_group = space.create_multi_follow([self.offset_locator, self.ik_chain[-2]], xform_group,
                                                 self.btm_control, attribute_name='autoAnkle', value=1,
                                                 create_title=False)

        scale_constraint = cmds.scaleConstraint(self.ik_chain[-2], follow_group)[0]

        space.scale_constraint_to_local(scale_constraint)

        if not self.negate_right_scale:
            cmds.parent(follow_group, self.top_control)
        if self.negate_right_scale:
            xform = space.create_xform_group(follow_group)
            cmds.parent(xform, self.top_control)

        if self._pole_at_knee_only:
            if self.invert_poles:
                attr.connect_multiply('%s.twistKnee' % self.btm_control, '%s.twist' % self._offset_handle, 1)
            else:
                attr.connect_multiply('%s.twistKnee' % self.btm_control, '%s.twist' % self._offset_handle, -1)

    def _create_pole_constraint(self, control, handle):
        if not self._pole_at_knee_only:
            super(IkBackLegRig, self)._create_pole_constraint(control, handle)

    def _create_pole_twist_attrs(self):
        super(IkBackLegRig, self)._create_pole_twist_attrs()

        if self._pole_at_knee_only:
            cmds.addAttr(self.btm_control, ln='twistKnee', k=True, dv=0)

    def _create_twist_guide_ik(self, guides, guides_twist):

        guide_ik_type = space.IkHandle.solver_sc

        if self._pole_at_knee_only:
            guide_ik_type = space.IkHandle.solver_rp

        guide_ik = self._create_twist_ik(guides, 'guide', guide_ik_type)
        twist_guide_ik = self._create_twist_ik(guides_twist, 'guideTwist')

        return guide_ik, twist_guide_ik

    def _pole_at_knee(self):
        cmds.poleVectorConstraint(self.pole_control, self._offset_handle)

        xform = space.get_xform_group(self.pole_control)
        locator = cmds.spaceLocator(n=core.inc_name(self._get_name('locator', 'pole', sub=False)))
        cmds.hide(locator)
        cmds.parent(locator, xform)
        space.MatchSpace(self.pole_control, locator).translation_rotation()

        cmds.setAttr('%s.poleVectorX' % self.ik_handle, 0)
        cmds.setAttr('%s.poleVectorY' % self.ik_handle, 0)
        cmds.setAttr('%s.poleVectorZ' % self.ik_handle, 0)

        example_xform = self.offset_locator

        ankle_locator = cmds.duplicate(example_xform,
                                       n=core.inc_name(self._get_name('locator', 'ankle', sub=False)),
                                       po=True
                                       )[0]
        cmds.showHidden(ankle_locator)
        cmds.parent(ankle_locator, self.setup_group)
        offset_ankle = cmds.duplicate(ankle_locator, n='offset_%s' % ankle_locator, po=True)[0]
        xform_ankle = cmds.duplicate(ankle_locator, n='xform_%s' % ankle_locator, po=True)[0]

        cmds.parent(ankle_locator, offset_ankle)
        cmds.parent(offset_ankle, xform_ankle)
        space.zero_out_transform_channels(ankle_locator)

        cmds.parentConstraint(space.get_xform_group(self.controls[-2]), xform_ankle)

        space.MatchSpace(self.offset_locator, offset_ankle).translation_rotation()

        cmds.parentConstraint(self.offset_locator, ankle_locator, mo=True)

        rot_x = cmds.getAttr('%s.rotateX' % ankle_locator)
        rot_y = cmds.getAttr('%s.rotateY' % ankle_locator)
        rot_z = cmds.getAttr('%s.rotateZ' % ankle_locator)

        cmds.setAttr('%s.rotateX' % offset_ankle, rot_x)
        cmds.setAttr('%s.rotateY' % offset_ankle, rot_y)
        cmds.setAttr('%s.rotateZ' % offset_ankle, rot_z)

        space.add_twist_reader(ankle_locator, 'Y')

        input_twist = attr.get_attribute_input('%s.twist' % ankle_locator, node_only=False)

        attr.disconnect_attribute('%s.twist' % ankle_locator)

        plus = cmds.createNode('plusMinusAverage', n=self._get_name('plusMinusAverage'))

        cmds.connectAttr(input_twist, '%s.input1D[0]' % plus)
        if not self.invert_twist:
            if self.invert_poles:
                attr.connect_multiply('%s.twist' % self.btm_control, '%s.input1D[1]' % plus, -1)
            else:
                cmds.connectAttr('%s.twist' % self.btm_control, '%s.input1D[1]' % plus)
        if self.invert_twist:
            if self.invert_poles:
                cmds.connectAttr('%s.twist' % self.btm_control, '%s.input1D[1]' % plus)
            else:
                attr.connect_multiply('%s.twist' % self.btm_control, '%s.input1D[1]' % plus, -1)

        cmds.connectAttr('%s.output1D' % plus, '%s.twist' % ankle_locator)

        attr.disconnect_attribute('%s.twist' % self.ik_handle)

        if self.invert_twist:
            cmds.connectAttr('%s.twist' % ankle_locator, '%s.twist' % self.ik_handle)
            cmds.connectAttr('%s.twist' % ankle_locator, '%s.twist' % self.twist_guide_ik)
        else:
            attr.connect_multiply('%s.twist' % ankle_locator, '%s.twist' % self.ik_handle, -1)
            attr.connect_multiply('%s.twist' % ankle_locator, '%s.twist' % self.twist_guide_ik, -1)

        loc = cmds.spaceLocator(n=self._get_name('locator', 'polePosition'))[0]
        pole_vector = self._ik_pole_values
        vtool.util.show(pole_vector)

        control_matrix = cmds.getAttr('%s.worldMatrix' % self.top_control)
        position = cmds.xform(self.joints[0], q=True, ws=True, t=True)
        om_position = om.MVector(position[0], position[1], position[2])

        om_control_matrix = om.MMatrix()

        om_pole_vector = om.MPoint([pole_vector[0], pole_vector[1], pole_vector[2], 1])

        # if self.side == 'R':
        #    om_pole_vector = om_pole_vector*-1

        new_vector = om_pole_vector + om_position

        cmds.xform(loc, t=[new_vector.x, new_vector.y, new_vector.z], ws=True)

        cmds.parent(loc, self.top_control)
        cmds.hide(loc)
        cmds.poleVectorConstraint(loc, self.ik_handle)

        pole_twist = self._create_group(description='poleTwist')
        cmds.parent(pole_twist, self.setup_group)
        cmds.parentConstraint(self.control_group, pole_twist, mo=True)
        cmds.parent(self.twist_guide, pole_twist)

    def _create_twist_guide_follow(self):
        if not self.pole_follow_transform:
            cmds.parentConstraint(self.twist_guide, self.pole_vector_xform, mo=True)[0]
        if self.pole_follow_transform:
            sequence = vtool.util.convert_to_sequence(self.pole_follow_transform)
            sequence.append(self.twist_guide)

            space.create_multi_follow_direct(sequence, self.pole_vector_xform, self.pole_control)

        if self._pole_at_knee_only:
            constraint = 'pointConstraint'
        else:
            constraint = 'parentConstraint'

        space.create_multi_follow([self.off_offset_locator, self.offset_locator],
                                  self.twist_guide_ik, self.btm_control,
                                  attribute_name='autoTwist',
                                  value=0,
                                  create_title=False,
                                  constraint_type=constraint)

    def set_offset_control_to_locator(self, bool_value):
        self.offset_control_to_locator = bool_value

    def set_offset_ankle_axis(self, axis_letter):
        axis_letter = axis_letter.capitalize()
        self._offset_ankle_axis = axis_letter

    def set_offset_ankle_orientation(self, transform_example):
        self._offset_ankle_orient = transform_example

    def set_offset_control_shape(self, curve_type_name):
        self._offset_shape = curve_type_name

    def set_pole_at_knee_only(self, bool_value):
        self._pole_at_knee_only = bool_value

    def set_invert_twist(self, bool_value):
        self.invert_twist = bool_value

    def set_invert_poles(self, bool_value):
        self.invert_poles = bool_value

    def create(self):
        super(IkBackLegRig, self).create()

        cmds.dgdirty(a=True)
        self._create_offset_control()

        self._rig_offset_chain()

        if self._pole_at_knee_only:
            self._pole_at_knee()

        temp_controls = list(self.controls)

        if len(temp_controls) == 4:
            self.controls[0] = temp_controls[0]
            self.controls[1] = temp_controls[1]
            self.controls[2] = temp_controls[3]
            self.controls[3] = temp_controls[2]


class RollRig(JointRig):

    def __init__(self, description, side=None):
        super(RollRig, self).__init__(description, side)

        self.create_roll_controls = True
        self.attribute_control = None
        self.attribute_control_shape = 'square'

        self.ik_chain = []
        self.fk_chain = []

        self.add_hik = None

        self.ik_attribute = 'ikFk'
        self.control_shape = 'circle'

        self.forward_roll_axis = 'X'
        self.side_roll_axis = 'Z'
        self.top_roll_axis = 'Y'

        self.right_side_fix = False

    def duplicate_joints(self):

        duplicate = space.DuplicateHierarchy(self.joints[0])
        duplicate.only_these(self.joints)
        joints = duplicate.create()

        cmds.parent(joints[0], self.setup_group)

        return joints

    def _get_attribute_control(self):
        if not self.attribute_control:
            return self.roll_control.get()

        if self.attribute_control:
            return self.attribute_control

    def _create_pivot_group(self, source_transform, description):

        name = core.inc_name(self._get_name('pivot', description))

        group = cmds.group(em=True, n=name)

        match_space = space.MatchSpace(source_transform, group)
        match_space.translation_rotation()

        xform_group = space.create_xform_group(group)

        attribute_control = self._get_attribute_control()

        cmds.addAttr(attribute_control, ln='%sPivot' % description, at='double', k=True)

        cmds.connectAttr('%s.%sPivot' % (attribute_control, description), '%s.rotateY' % group)

        if self.right_side_fix and self.side == 'R':
            attr.insert_multiply('%s.rotateY' % group, -1)

        return group, xform_group

    def _create_pivot_control(self, source_transform, description, sub=False, no_control=False, scale=1):

        if self.create_roll_controls:
            control = self._create_control(description, sub)

            control_object = control
            control.set_curve_type(self.control_shape)
            if sub:
                if self.sub_control_shape:
                    control.set_curve_type(self.sub_control_shape)

            control.scale_shape(scale, scale, scale)
            control = control.get()

        if not self.create_roll_controls or no_control:
            name = self._get_name('ctrl', description)
            control = cmds.group(em=True, n=core.inc_name(name))

        xform_group = space.create_xform_group(control)
        driver_group = space.create_xform_group(control, 'driver')

        match_space = space.MatchSpace(source_transform, xform_group)
        match_space.translation_rotation()

        if self.create_roll_controls:
            control_object.hide_scale_attributes()
            control_object.hide_translate_attributes()
            control_object.hide_visibility_attribute()

        if self.create_roll_controls:
            cmds.connectAttr('%s.controlVisibility' % self._get_attribute_control(), '%sShape.visibility' % control)

        return control, xform_group, driver_group

    def _create_roll_control(self, transform):

        roll_control = self._create_control('roll', curve_type=self.attribute_control_shape)

        self.roll_control = roll_control

        roll_control.scale_shape(.8, .8, .8)

        xform_group = space.create_xform_group(roll_control.get())

        roll_control.hide_keyable_attributes()

        match_space = space.MatchSpace(transform, xform_group)
        match_space.translation_rotation()

        # cmds.parentConstraint(roll_control.get(), transform)

        cmds.parent(xform_group, self.control_group)

        self.roll_control_xform = xform_group

        return roll_control

    def _mix_joints(self, joint_chain1, joint_chain2):

        count = len(joint_chain1)

        self.ik_chain = []

        joints_attach_1 = []
        joints_attach_2 = []
        target_joints = []

        for inc in range(0, count):

            for inc2 in range(0, count):
                if joint_chain1[inc].startswith(self.joints[inc2]):
                    joints_attach_1.append(joint_chain1[inc])
                    joints_attach_2.append(joint_chain2[inc])
                    target_joints.append(self.joints[inc2])

                    constraint = cmds.parentConstraint(joint_chain1[inc], joint_chain2[inc], self.joints[inc2])[0]

                    constraint_editor = space.ConstraintEditor()
                    constraint_editor.create_switch(self.roll_control.get(), self.ik_attribute, constraint)

                    self.ik_chain.append(joint_chain1[inc])
                    self.fk_chain.append(joint_chain2[inc])

        space.AttachJoints(joints_attach_1, target_joints).create()
        space.AttachJoints(joints_attach_2, target_joints).create()

        cmds.connectAttr('%s.%s' % (self.roll_control.get(), self.ik_attribute), '%s.switch' % target_joints[0])

    def _create_ik_fk_attribute(self):

        attr.create_title(self.roll_control.get(), 'IK_FK')
        ik_fk = attr.MayaNumberVariable(self.ik_attribute)
        ik_fk.set_variable_type(ik_fk.TYPE_DOUBLE)
        ik_fk.set_min_value(0)
        ik_fk.set_max_value(1)

        if self.add_hik:
            ik_fk.set_max_value(2)

        ik_fk.create(self.roll_control.get())

    def set_create_roll_controls(self, bool_value):

        self.create_roll_controls = bool_value

    def set_attribute_control(self, control_name):
        self.attribute_control = control_name

    def set_attribute_control_shape(self, shape_name):
        self.attribute_control_shape = shape_name

    def set_control_shape(self, shape_name):
        self.control_shape = shape_name

    def set_add_hik(self, bool_value):
        self.add_hik = bool_value
        if bool_value:
            self.ik_attribute = 'ikFkHik'

    def set_forward_roll_axis(self, axis_letter):
        self.forward_roll_axis = axis_letter

    def set_side_roll_axis(self, axis_letter):
        self.side_roll_axis = axis_letter

    def set_top_roll_axis(self, axis_letter):
        self.top_roll_axis = axis_letter

    def set_right_side_fix(self, bool_value):
        self.right_side_fix = bool_value

    def create(self):
        super(RollRig, self).create()

        joint_chain1 = self.duplicate_joints()
        joint_chain2 = self.duplicate_joints()

        self._create_roll_control(self.joints[0])

        self._create_ik_fk_attribute()

        self._mix_joints(joint_chain1, joint_chain2)

        attr.create_title(self._get_attribute_control(), 'FOOT_PIVOTS')

        if self.create_roll_controls:
            bool_var = attr.MayaNumberVariable('controlVisibility')
            bool_var.set_variable_type(bool_var.TYPE_BOOL)
            bool_var.create(self._get_attribute_control())
            bool_var.set_value(self.sub_visibility)


class FootRollRig(RollRig):

    def __init__(self, description, side=None):
        super(FootRollRig, self).__init__(description, side)

        self.defined_joints = []
        self.toe_rotate_as_locator = False
        self.mirror_yaw = False
        self.main_control_follow = None

    def _define_joints(self):

        self.ankle_index = 0
        self.heel_index = 1
        self.ball_index = 2
        self.toe_index = 3
        self.yawIn_index = 4
        self.yawOut_index = 5

        self.ankle = self.ik_chain[self.ankle_index]
        self.heel = self.ik_chain[self.heel_index]
        self.ball = self.ik_chain[self.ball_index]
        self.toe = self.ik_chain[self.toe_index]
        self.yawIn = self.ik_chain[self.yawIn_index]

        self.yawOut = self.ik_chain[self.yawOut_index]

    def _create_ik_handle(self, name, start_joint, end_joint):

        name = self._get_name(name)

        ik_handle = space.IkHandle(name)
        ik_handle.set_solver(ik_handle.solver_sc)
        ik_handle.set_start_joint(start_joint)
        ik_handle.set_end_joint(end_joint)
        return ik_handle.create()

    def _create_ik(self):

        self.ankle_handle = self._create_ik_handle('ankle', self.ankle, self.ball)
        self.ball_handle = self._create_ik_handle('ball', self.ball, self.toe)

        cmds.parent(self.ankle_handle, self.setup_group)
        cmds.parent(self.ball_handle, self.setup_group)

    def _create_toe_rotate_control(self):
        if not self.toe_rotate_as_locator:
            control = self._create_control('TOE_ROTATE', True, curve_type='circle')
            control.hide_translate_attributes()
            control.hide_scale_attributes()
            control.hide_visibility_attribute()
            xform_group = control.create_xform()
            control = control.get()

        if self.toe_rotate_as_locator:
            control = cmds.spaceLocator(n=core.inc_name(self._get_name('locator', 'toe_rotate')))[0]
            xform_group = space.create_xform_group(control)
            attribute_control = self._get_attribute_control()
            attr.create_title(attribute_control, 'TOE_ROTATE')
            cmds.addAttr(attribute_control, ln='toeRotate', at='double', k=True)
            cmds.connectAttr('%s.toeRotate' % attribute_control, '%s.rotate%s' % (control, self.forward_roll_axis))

        match_space = space.MatchSpace(self.ball, xform_group)
        match_space.translation_rotation()

        return control, xform_group

    def _create_toe_fk_rotate_control(self):
        control = self._create_control('TOE_FK_ROTATE')
        control.hide_translate_attributes()
        control.hide_scale_attributes()
        control.hide_visibility_attribute()

        xform_group = control.create_xform()

        match_space = space.MatchSpace(self.ball, xform_group)
        match_space.translation_rotation()

        cmds.parentConstraint(control.get(), self.fk_chain[self.ball_index])

        return control, xform_group

    def _create_roll_attributes(self):

        attribute_control = self._get_attribute_control()

        cmds.addAttr(attribute_control, ln='ballRoll', at='double', k=True)
        cmds.addAttr(attribute_control, ln='toeRoll', at='double', k=True)
        cmds.addAttr(attribute_control, ln='heelRoll', at='double', k=True)
        cmds.addAttr(attribute_control, ln='yawRoll', at='double', k=True)

    def _create_yawout_roll(self, parent):

        control, xform, driver = self._create_pivot_control(self.yawOut, 'yawOut')

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        final_value = 10
        if self.mirror_yaw:
            final_value = -10

        final_other_value = -45
        if self.mirror_yaw:
            final_other_value = 45

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.side_roll_axis), cd='%s.yawRoll' % attribute_control,
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.side_roll_axis), cd='%s.yawRoll' % attribute_control,
                               driverValue=final_value, value=final_other_value, itt='spline', ott='spline')

        if self.mirror_yaw:
            cmds.setInfinity('%s.rotate%s' % (driver, self.side_roll_axis), preInfinite='linear')
        else:
            cmds.setInfinity('%s.rotate%s' % (driver, self.side_roll_axis), postInfinite='linear')

        return control

    def _create_yawin_roll(self, parent):

        control, xform, driver = self._create_pivot_control(self.yawIn, 'yawIn')

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        final_value = -10
        if self.mirror_yaw and self.side == 'R':
            final_value = 10

        final_other_value = 45
        if self.mirror_yaw and self.side == 'R':
            final_other_value = -45

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.side_roll_axis), cd='%s.yawRoll' % attribute_control,
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.side_roll_axis), cd='%s.yawRoll' % attribute_control,
                               driverValue=final_value, value=final_other_value, itt='spline', ott='spline')

        if self.mirror_yaw and self.side == 'R':
            cmds.setInfinity('%s.rotate%s' % (driver, self.side_roll_axis), postInfinite='linear')
        else:
            cmds.setInfinity('%s.rotate%s' % (driver, self.side_roll_axis), preInfinite='linear')

        return control

    def _create_ball_roll(self, parent):

        control, xform, driver = self._create_pivot_control(self.ball, 'ball')
        control = rigs_util.Control(control)
        control.scale_shape(2, 2, 2)
        control = control.get()

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.ballRoll' % attribute_control,
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.ballRoll' % attribute_control,
                               driverValue=10, value=45, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.ballRoll' % attribute_control,
                               driverValue=-10, value=-45, itt='spline', ott='spline')
        # cmds.setDrivenKeyframe('%s.rotateX' % driver,cd = '%s.ballRoll' % attribute_control, driverValue = 20, value = 0, itt = 'spline', ott = 'spline')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), postInfinite='linear')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), preInfinite='linear')

        return control

    def _create_toe_roll(self, parent):

        control, xform, driver = self._create_pivot_control(self.toe, 'toe')

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.toeRoll' % attribute_control,
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.toeRoll' % attribute_control,
                               driverValue=10, value=45, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.toeRoll' % attribute_control,
                               driverValue=-10, value=-45, itt='spline', ott='spline')

        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), postInfinite='linear')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), preInfinite='linear')

        return control

    def _create_heel_roll(self, parent):
        control, xform, driver = self._create_pivot_control(self.heel, 'heel')

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.heelRoll' % attribute_control,
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.heelRoll' % attribute_control,
                               driverValue=-10, value=-45, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.heelRoll' % attribute_control,
                               driverValue=10, value=45, itt='spline', ott='spline')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), preInfinite='linear')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), postInfinite='linear')

        return control

    def _create_pivot(self, name, transform, parent):

        pivot_group, pivot_xform = self._create_pivot_group(transform, name)
        cmds.parent(pivot_xform, parent)

        return pivot_group

    def _create_pivot_groups(self):

        toe_control, toe_control_xform = self._create_toe_rotate_control()
        toe_fk_control, toe_fk_control_xform = self._create_toe_fk_rotate_control()

        ball_pivot = self._create_pivot('ball', self.ball, self.control_group)
        toe_pivot = self._create_pivot('toe', self.toe, ball_pivot)
        heel_pivot = self._create_pivot('heel', self.heel, toe_pivot)

        toe_roll = self._create_toe_roll(heel_pivot)
        heel_roll = self._create_heel_roll(toe_roll)
        yawout_roll = self._create_yawout_roll(heel_roll)
        yawin_roll = self._create_yawin_roll(yawout_roll)

        ball_roll = self._create_ball_roll(yawin_roll)

        self._create_ik()

        cmds.parent(toe_control_xform, yawout_roll)

        if not self.main_control_follow:
            space.create_follow_group(ball_roll, self.roll_control_xform)
        if self.main_control_follow:
            space.create_follow_group(self.main_control_follow, self.roll_control_xform)

        cmds.parentConstraint(toe_control, self.ball_handle, mo=True)
        cmds.parentConstraint(ball_roll, self.ankle_handle, mo=True)

        return [ball_pivot, toe_fk_control_xform]

    def set_toe_rotate_as_locator(self, bool_value):
        """
        Whether the toe rotate should be a locator instead of a control.
        An attribute will be created on the main control to rotate the toe.
        """
        self.toe_rotate_as_locator = bool_value

    def set_mirror_yaw(self, bool_value):
        self.mirror_yaw = bool_value

    def set_main_control_follow(self, transform):
        self.main_control_follow = transform

    def create(self):
        super(FootRollRig, self).create()

        self._define_joints()

        self._create_roll_attributes()

        ball_pivot, toe_fk_control_xform = self._create_pivot_groups()

        attr.connect_equal_condition('%s.%s' % (self.roll_control.get(), self.ik_attribute),
                                     '%s.visibility' % toe_fk_control_xform, 1)
        # cmds.connectAttr('%s.%s' % (self.roll_control.get(), self.ik_attribute), '%s.visibility' % toe_fk_control_xform)
        attr.connect_equal_condition('%s.%s' % (self.roll_control.get(), self.ik_attribute),
                                     '%s.visibility' % ball_pivot, 0)
        # connect_reverse('%s.%s' % (self.roll_control.get(), self.ik_attribute), '%s.visibility' % ball_pivot)


class BaseFootRig(BufferRig):

    def __init__(self, description, side=None):
        super(BaseFootRig, self).__init__(description, side)

        self.create_roll_controls = True
        self.attribute_control = None

        self.control_shape = 'circle'

        self.forward_roll_axis = 'X'
        self.side_roll_axis = 'Z'
        self.top_roll_axis = 'Y'

        self.attribute_control_shape = 'square'

        self.locators = []

        self.main_control_follow = None

    def _get_attribute_control(self):
        if not self.attribute_control:
            return self.roll_control.get()

        if self.attribute_control:
            return self.attribute_control

    def _create_pivot_group(self, source_transform, description):

        name = core.inc_name(self._get_name('pivot', description))

        group = cmds.group(em=True, n=name)

        space.MatchSpace(source_transform, group).translation()
        space.MatchSpace(self.joints[-1], group).rotation()

        xform_group = space.create_xform_group(group)

        attribute_control = self._get_attribute_control()

        cmds.addAttr(attribute_control, ln='%sPivot' % description, at='double', k=True)

        if cmds.upAxis(q=True, ax=True) == 'z':
            cmds.connectAttr('%s.%sPivot' % (attribute_control, description), '%s.rotateZ' % group)
        else:
            cmds.connectAttr('%s.%sPivot' % (attribute_control, description), '%s.rotateY' % group)

        return group, xform_group

    def _create_pivot_control(self, source_transform, description, sub=False, no_control=False, scale=1):

        if self.create_roll_controls:
            control = self._create_control(description, sub)

            control_object = control

            # if sub:
            #    if self.sub_control_shape:
            #        control.set_curve_type(self.sub_control_shape)

            control.scale_shape(scale, scale, scale)
            control = control.get()

        if not self.create_roll_controls or no_control:
            name = self._get_name('ctrl', description)
            control = cmds.group(em=True, n=core.inc_name(name))

        xform_group = space.create_xform_group(control)
        driver_group = space.create_xform_group(control, 'driver')

        space.MatchSpace(source_transform, xform_group).translation()
        space.MatchSpace(self.joints[-1], xform_group).rotation()

        if self.create_roll_controls:
            control_object.hide_scale_attributes()
            control_object.hide_translate_attributes()
            control_object.hide_visibility_attribute()

        if self.create_roll_controls and cmds.objExists('%s.controlVisibility' % self._get_attribute_control()):
            cmds.connectAttr('%s.controlVisibility' % self._get_attribute_control(), '%sShape.visibility' % control)

        return control, xform_group, driver_group

    def _create_roll_control(self, transform):

        roll_control = self._create_control('roll', curve_type=self.attribute_control_shape)

        self.roll_control = roll_control

        roll_control.scale_shape(.8, .8, .8)

        xform_group = space.create_xform_group(roll_control.get())

        roll_control.hide_keyable_attributes()

        match_space = space.MatchSpace(transform, xform_group)
        match_space.translation_rotation()

        self.roll_control_xform = xform_group

        return roll_control

    def _create_ik_handle(self, name, start_joint, end_joint):

        name = self._get_name(name)

        ik_handle = space.IkHandle(name)
        ik_handle.set_solver(ik_handle.solver_sc)
        ik_handle.set_start_joint(start_joint)
        ik_handle.set_end_joint(end_joint)
        return ik_handle.create()

    def set_main_control_follow(self, transform):
        self.main_control_follow = transform

    def set_create_roll_controls(self, bool_value):

        self.create_roll_controls = bool_value

    def set_attribute_control(self, control_name):
        self.attribute_control = control_name

    def set_control_shape(self, shape_name):
        self.control_shape = shape_name

    def set_attribute_control_shape(self, shape_name):
        self.attribute_control_shape = shape_name

    def set_forward_roll_axis(self, axis_letter):
        self.forward_roll_axis = axis_letter

    def set_side_roll_axis(self, axis_letter):
        self.side_roll_axis = axis_letter

    def set_top_roll_axis(self, axis_letter):
        self.top_roll_axis = axis_letter

    def create(self):
        super(BaseFootRig, self).create()

        if not self.main_control_follow:
            self._create_roll_control(self.joints[0])
        if self.main_control_follow:
            self._create_roll_control(self.main_control_follow)

        attr.create_title(self._get_attribute_control(), 'FOOT_PIVOTS')

        if self.create_roll_controls:
            bool_var = attr.MayaNumberVariable('controlVisibility')
            bool_var.set_variable_type(bool_var.TYPE_BOOL)
            bool_var.create(self._get_attribute_control())
            bool_var.set_value(self.sub_visibility)


class FootRig(BaseFootRig):

    def __init__(self, description, side=None):
        super(FootRig, self).__init__(description, side)

        self.toe = None
        self.ball = None
        self.ankle = None
        self.build_hierarchy = True

        self.toe_rotate_as_locator = False
        self.mirror_yaw = False
        self.main_control_follow = None
        self.ik_parent = None
        self.ik_leg = None
        self._do_create_foot_roll = False
        self._do_create_ankle_roll = False
        self._ankle_roll_axis = 'Z'
        self._toe_rotate_axis = None
        self._toe_control_sub = True

        self.heel = None
        self.yawIn = None
        self.yawOut = None

        self._ball_roll = None
        self._toe_roll = None
        self._heel_roll = None

        self._duplicate_chain_replace = ['joint', 'guide']
        self.locator_replace = 'locator'

        self._create_ball_control = False
        self._has_ball = True

    def _duplicate_joints(self):

        super(FootRig, self)._duplicate_joints()

        ankle = self.buffer_joints[0]

        ankle_base = core.get_basename(ankle)
        ankle_name = ankle_base

        if self.create_buffer_joints:
            ankle_name = ankle_base.replace(self.locator_replace, self._buffer_replace[1])

        if not self.create_buffer_joints:
            ankle_name = ankle_base.replace(self.locator_replace, self._duplicate_chain_replace[1])

        joint = cmds.rename(ankle, ankle_name)

        self.buffer_joints[0] = joint

        if not self.create_buffer_joints:
            self.joints[0] = joint

    def _create_ik_chain(self):

        duplicate = space.DuplicateHierarchy(self.buffer_joints[0])
        duplicate.only_these(self.buffer_joints)

        if not self.create_buffer_joints:
            duplicate.replace(self._duplicate_chain_replace[0], self._duplicate_chain_replace[1])
        if self.create_buffer_joints:
            duplicate.replace(self._buffer_replace[1], self._duplicate_chain_replace[1])

        joints = duplicate.create()

        parent = cmds.listRelatives(joints[0], p=True)

        if parent:
            if parent[0] != self.setup_group:
                cmds.parent(joints[0], self.setup_group)

        self.ik_joints = joints

        return joints

    def _attach_ik_chain(self):

        for inc in range(0, len(self.ik_joints)):
            cmds.parentConstraint(self.ik_joints[inc], self.buffer_joints[inc])

    def _create_ik(self):

        if self.ball:
            self.ankle_handle = self._create_ik_handle('ankle', self.ankle, self.ball)
        elif not self._has_ball:
            self.ankle_handle = self._create_ik_handle('ankle', self.ankle, self.toe)

        cmds.parent(self.ankle_handle, self.setup_group)

        if self.toe:
            if self._has_ball:
                self.ball_handle = self._create_ik_handle('ball', self.ball, self.toe)
                cmds.parent(self.ball_handle, self.setup_group)

        if self.ik_parent:
            cmds.pointConstraint(self.ik_parent, self.ik_joints[0])

    def _create_toe_rotate_control(self):

        attribute_control = self._get_attribute_control()

        cmds.addAttr(attribute_control, ln='toeRotate', at='double', k=True)

        if not self.toe_rotate_as_locator:

            control = self._create_control('TOE_ROTATE', self._toe_control_sub, curve_type='circle')
            control.hide_translate_attributes()
            control.hide_scale_attributes()
            control.hide_visibility_attribute()
            control.rotate_shape(90, 0, 0)
            xform_group = control.create_xform()
            driver = space.create_xform_group(control.get(), 'driver')
            control = control.get()

            axis = self.forward_roll_axis
            if self._toe_rotate_axis:
                axis = self._toe_rotate_axis

            cmds.connectAttr('%s.toeRotate' % attribute_control, '%s.rotate%s' % (driver, axis))

        if self.toe_rotate_as_locator:
            control = cmds.spaceLocator(n=core.inc_name(self._get_name('locator', 'toe_rotate')))[0]
            xform_group = space.create_xform_group(control)

            cmds.connectAttr('%s.toeRotate' % attribute_control, '%s.rotate%s' % (control, self.forward_roll_axis))

        match_space = space.MatchSpace(self.ball, xform_group)
        match_space.translation_rotation()

        return control, xform_group

    def _create_roll_attributes(self):

        attribute_control = self._get_attribute_control()

        if self._do_create_foot_roll:
            cmds.addAttr(attribute_control, ln='footRoll', at='double', k=True)
            if self.ball:
                cmds.addAttr(attribute_control, ln='footRollAngle', at='double', k=True, dv=30)

        if self._do_create_ankle_roll:
            if self.toe and self._has_ball and self.ball:
                cmds.addAttr(attribute_control, ln='ankleRoll', at='double', k=True)

        if self.ball:
            cmds.addAttr(attribute_control, ln='ballRoll', at='double', k=True)
        if self.toe:
            cmds.addAttr(attribute_control, ln='toeRoll', at='double', k=True)
        if self.heel:
            cmds.addAttr(attribute_control, ln='heelRoll', at='double', k=True)
        if self.yawIn and self.yawOut:
            cmds.addAttr(attribute_control, ln='yawRoll', at='double', k=True)

    def _create_yawout_roll(self, parent):

        if not self.yawOut:
            return

        control, xform, driver = self._create_pivot_control(self.yawOut, 'yawOut')

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        final_value = 10
        if self.mirror_yaw:
            final_value = -10

        final_other_value = -45
        if self.mirror_yaw:
            final_other_value = 45

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.side_roll_axis), cd='%s.yawRoll' % attribute_control,
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.side_roll_axis), cd='%s.yawRoll' % attribute_control,
                               driverValue=final_value, value=final_other_value, itt='spline', ott='spline')

        if self.mirror_yaw:
            cmds.setInfinity('%s.rotate%s' % (driver, self.side_roll_axis), preInfinite='linear')
        else:
            cmds.setInfinity('%s.rotate%s' % (driver, self.side_roll_axis), postInfinite='linear')

        return control

    def _create_yawin_roll(self, parent):

        if not self.yawIn:
            return

        control, xform, driver = self._create_pivot_control(self.yawIn, 'yawIn')

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        final_value = -10
        if self.mirror_yaw:
            final_value = 10

        final_other_value = 45
        if self.mirror_yaw:
            final_other_value = -45

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.side_roll_axis), cd='%s.yawRoll' % attribute_control,
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.side_roll_axis), cd='%s.yawRoll' % attribute_control,
                               driverValue=final_value, value=final_other_value, itt='spline', ott='spline')

        if self.mirror_yaw:
            cmds.setInfinity('%s.rotate%s' % (driver, self.side_roll_axis), postInfinite='linear')
        else:
            cmds.setInfinity('%s.rotate%s' % (driver, self.side_roll_axis), preInfinite='linear')

        return control

    def _create_ball_roll(self, parent):

        control, xform, driver = self._create_pivot_control(self.ball, 'ball')
        control = rigs_util.Control(control)
        control.scale_shape(2, 2, 2)
        control = control.get()

        try:
            cmds.parent(xform, parent)
        except:
            pass

        if self.ik_leg:
            cmds.parent(self.ik_leg, control)

        attribute_control = self._get_attribute_control()

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.ballRoll' % attribute_control,
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.ballRoll' % attribute_control,
                               driverValue=10, value=45, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.ballRoll' % attribute_control,
                               driverValue=-10, value=-45, itt='spline', ott='spline')

        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), postInfinite='linear')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), preInfinite='linear')

        if self._do_create_ankle_roll:
            if cmds.objExists('%s.ankleRoll' % self.attribute_control):
                cmds.connectAttr('%s.ankleRoll' % self.attribute_control,
                                 '%s.rotate%s' % (driver, self._ankle_roll_axis))

        self._ball_roll = driver

        return control

    def _create_toe_roll(self, parent):

        if not self.toe:
            return self.control_group

        control, xform, driver = self._create_pivot_control(self.toe, 'toe')

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.toeRoll' % attribute_control,
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.toeRoll' % attribute_control,
                               driverValue=10, value=45, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.toeRoll' % attribute_control,
                               driverValue=-10, value=-45, itt='spline', ott='spline')

        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), postInfinite='linear')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), preInfinite='linear')

        self._toe_roll = driver

        return control

    def _create_foot_roll(self):

        if self.ball:
            ball_driver = space.create_xform_group(self._ball_roll, 'driver2')

        if self.toe:
            toe_driver = space.create_xform_group(self._toe_roll, 'driver2')
        if self.heel:
            heel_driver = space.create_xform_group(self._heel_roll, 'driver2')

        attribute_control = self._get_attribute_control()

        multiply = None
        if self.ball:
            cmds.setDrivenKeyframe('%s.rotate%s' % (ball_driver, self.forward_roll_axis),
                                   cd='%s.footRoll' % attribute_control, driverValue=0, value=0, itt='spline',
                                   ott='spline')
            cmds.setDrivenKeyframe('%s.rotate%s' % (ball_driver, self.forward_roll_axis),
                                   cd='%s.footRoll' % attribute_control, driverValue=5, value=30, itt='spline',
                                   ott='spline')
            cmds.setDrivenKeyframe('%s.rotate%s' % (ball_driver, self.forward_roll_axis),
                                   cd='%s.footRoll' % attribute_control, driverValue=10, value=0, itt='spline',
                                   ott='spline')

            multiply = attr.insert_multiply('%s.rotate%s' % (ball_driver, self.forward_roll_axis), 1)

        set_range = cmds.createNode('setRange', n=core.inc_name(self._get_name(prefix='setRange')))

        cmds.setAttr('%s.oldMaxX' % set_range, 360)
        cmds.setAttr('%s.oldMaxY' % set_range, 360)
        cmds.setAttr('%s.oldMaxZ' % set_range, 360)

        cmds.setAttr('%s.maxX' % set_range, 12)
        cmds.setAttr('%s.maxY' % set_range, 12)
        cmds.setAttr('%s.maxZ' % set_range, 12)

        if self._has_ball and self.ball:
            cmds.connectAttr('%s.footRollAngle' % attribute_control, '%s.valueX' % set_range)
        if multiply:
            cmds.connectAttr('%s.outValueX' % set_range, '%s.input2X' % multiply)

        if self.toe:
            if self._has_ball and self.ball:
                cmds.setDrivenKeyframe('%s.rotate%s' % (toe_driver, self.forward_roll_axis),
                                       cd='%s.footRoll' % attribute_control, driverValue=5, value=0, itt='spline',
                                       ott='spline')
            else:
                cmds.setDrivenKeyframe('%s.rotate%s' % (toe_driver, self.forward_roll_axis),
                                       cd='%s.footRoll' % attribute_control, driverValue=0, value=0, itt='spline',
                                       ott='spline')
            cmds.setDrivenKeyframe('%s.rotate%s' % (toe_driver, self.forward_roll_axis),
                                   cd='%s.footRoll' % attribute_control, driverValue=10, value=45, itt='spline',
                                   ott='spline')

            cmds.setInfinity('%s.rotate%s' % (toe_driver, self.forward_roll_axis), postInfinite='linear')

        if self.heel:
            cmds.setDrivenKeyframe('%s.rotate%s' % (heel_driver, self.forward_roll_axis),
                                   cd='%s.footRoll' % attribute_control, driverValue=0, value=0, itt='spline',
                                   ott='spline')
            cmds.setDrivenKeyframe('%s.rotate%s' % (heel_driver, self.forward_roll_axis),
                                   cd='%s.footRoll' % attribute_control, driverValue=-10, value=-45, itt='spline',
                                   ott='spline')
            cmds.setInfinity('%s.rotate%s' % (heel_driver, self.forward_roll_axis), preInfinite='linear')

    def _create_heel_roll(self, parent):
        if not self.heel:
            return

        control, xform, driver = self._create_pivot_control(self.heel, 'heel')

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.heelRoll' % attribute_control,
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.heelRoll' % attribute_control,
                               driverValue=-10, value=-45, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.heelRoll' % attribute_control,
                               driverValue=10, value=45, itt='spline', ott='spline')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), preInfinite='linear')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), postInfinite='linear')

        self._heel_roll = driver

        return control

    def _create_pivot(self, name, transform, parent):

        pivot_group, pivot_xform = self._create_pivot_group(transform, name)
        cmds.parent(pivot_xform, parent)

        return pivot_group

    def _create_pivot_groups(self):

        toe_control = None
        if self.toe and self.ball and self._has_ball:
            toe_control, toe_control_xform = self._create_toe_rotate_control()

        if self.ball:
            ball_pivot = self._create_pivot('ball', self.ball, self.control_group)
        else:
            ball_pivot = self.control_group

        toe_pivot = None
        if self.toe:
            toe_pivot = self._create_pivot('toe', self.toe, ball_pivot)

        else:
            toe_pivot = self.control_group

        heel_pivot = None
        if self.heel:
            heel_pivot = self._create_pivot('heel', self.heel, toe_pivot)

        toe_roll = self._create_toe_roll(heel_pivot)
        heel_roll = self._create_heel_roll(toe_roll)
        yawout_roll = self._create_yawout_roll(heel_roll)
        yawin_roll = self._create_yawin_roll(yawout_roll)

        orig_setting = self.create_roll_controls

        if self._create_ball_control:
            self.create_roll_controls = True

        parent = self.control_group

        if toe_pivot:
            parent = toe_pivot

        if heel_pivot:
            parent = heel_pivot

        if toe_roll:
            parent = toe_roll

        if heel_roll:
            parent = heel_roll

        if yawout_roll:
            parent = yawout_roll

        if yawin_roll:
            parent = yawin_roll

        if self.ball:
            ball_roll = self._create_ball_roll(parent)

        else:
            cmds.parent(self.ik_leg, parent)

        self.create_roll_controls = orig_setting

        self._create_ik()

        if toe_control:
            cmds.parent(toe_control_xform, parent)

        if not self.main_control_follow:
            if self.ball:
                space.create_follow_group(ball_roll, self.roll_control_xform)
        if self.main_control_follow:
            space.create_follow_group(self.main_control_follow, self.roll_control_xform)

        if self.toe:
            if self._has_ball and self.ball:
                cmds.parentConstraint(toe_control, self.ball_handle, mo=True)

        if self.ball:
            cmds.parentConstraint(ball_roll, self.ankle_handle, mo=True)
        elif self.toe:
            cmds.parentConstraint(parent, self.ankle_handle, mo=True)

        return ball_pivot

    def set_build_hierarchy(self, bool_value):

        if not bool_value:
            vtool.util.warning('Foot Roll rig needs to build hierarchy. Setting it True.')

        self.build_hierarchy = True

    def set_duplicate_chain_replace(self, replace_this, with_this):

        self._duplicate_chain_replace = [replace_this, with_this]

    def set_create_ball_control(self, bool_value):

        self._create_ball_control = bool_value

    def set_toe_rotate_as_locator(self, bool_value):
        self.toe_rotate_as_locator = bool_value

    def set_mirror_yaw(self, bool_value):
        self.mirror_yaw = bool_value

    def set_pivot_locator(self, locator_name):
        pass

    def set_pivot_locators(self, heel, yaw_in, yaw_out):
        """
        Set the pivots for the foot roll.
        These must be transforms.

        Args:
            heel (str): Name of a transform.
            yaw_in (str): Name of a transform.
            yaw_out (str): Name of a transform.
        """

        self.heel = heel
        self.yawIn = yaw_in
        self.yawOut = yaw_out

    def set_create_foot_roll(self, bool_value):

        self._do_create_foot_roll = bool_value

    def set_create_ankle_roll(self, bool_value, axis='Z'):

        self._do_create_ankle_roll = bool_value
        self._ankle_roll_axis = axis.upper()

    def set_toe_rotate_axis(self, axis='X'):
        self._toe_rotate_axis = axis

    def set_ik_parent(self, parent_name):
        self.ik_parent = parent_name

    def set_ik_leg(self, ik_group_name):

        self.ik_leg = ik_group_name

    def set_no_ball(self, bool_value):
        if bool_value:
            self._has_ball = False
        else:
            self._has_ball = True

    def set_toe_control_as_sub_control(self, bool_value):
        self._toe_control_sub = bool_value

    def create(self):

        super(FootRig, self).create()

        if len(self.joints) < 3:
            vtool.util.warning('Please set three joints. set_joints([joint_ankle, joint_ball, joint_toe])')

        if not self.heel or not self.yawIn or not self.yawOut:
            vtool.util.warning('Please set_pivot_locators(heel, yaw_in, yaw_out)')

        self._create_ik_chain()

        self._attach_ik_chain()

        self.ankle = self.ik_joints[0]

        if len(self.ik_joints) > 1 and self._has_ball:
            self.ball = self.ik_joints[1]
        else:
            self.ball = None

        if len(self.ik_joints) == 3:
            self.toe = self.ik_joints[2]
        else:
            self.toe = None

        if len(self.ik_joints) == 2 and self._has_ball == False:
            self.toe = self.ik_joints[1]

        self._create_roll_attributes()

        self._create_pivot_groups()

        if self._do_create_foot_roll:
            self._create_foot_roll()


class QuadSpineRig(BufferRig):

    def _create_surface(self):

        surface = geo.transforms_to_nurb_surface(self.joints, self.description, 2, 'Z', 1)
        self.surface = surface
        cmds.parent(surface, self.setup_group)

    def _create_clusters(self):

        cluster_surface = deform.ClusterSurface(self.surface, self.description)
        cluster_surface.create()

        self.clusters = cluster_surface.handles

        cluster_group = self._create_setup_group('clusters')

        cmds.parent(self.clusters, cluster_group)

    def _attach_to_surface(self):

        rivet_group = self._create_setup_group('rivets')

        for joint in self.buffer_joints:
            rivet = geo.attach_to_surface(joint, self.surface)
            cmds.parent(rivet, rivet_group)

    def _create_btm_control(self):

        btm_control = self._create_control('btm')
        btm_control.hide_scale_attributes()
        sub_control = self._create_control('btm', sub=True)
        sub_control.hide_scale_attributes()

        btm_control = btm_control.get()
        sub_control = sub_control.get()

        space.MatchSpace(self.clusters[0], btm_control).translation_to_rotate_pivot()
        space.create_xform_group(btm_control)

        space.create_follow_group(btm_control, self.clusters[0])

        space.MatchSpace(self.clusters[1], sub_control).translation_to_rotate_pivot()
        xform = space.create_xform_group(sub_control)

        space.create_follow_group(sub_control, self.clusters[1])
        cmds.parent(xform, btm_control)

        self.btm_control = btm_control

    def _create_top_control(self):

        top_control = self._create_control('top')
        top_control.hide_scale_attributes()
        sub_control = self._create_control('top', sub=True)
        sub_control.hide_scale_attributes()

        top_control = top_control.get()
        sub_control = sub_control.get()

        space.MatchSpace(self.clusters[-1], top_control).translation_to_rotate_pivot()
        space.create_xform_group(top_control)

        space.create_follow_group(top_control, self.clusters[-1])

        space.MatchSpace(self.clusters[-2], sub_control).translation_to_rotate_pivot()
        xform = space.create_xform_group(sub_control)

        space.create_follow_group(sub_control, self.clusters[-2])
        cmds.parent(xform, top_control)

        self.top_control = top_control

    def _create_mid_control(self):

        mid_control = self._create_control('mid', True)
        mid_control.hide_scale_attributes()

        mid_control = mid_control.get()

        space.MatchSpace(self.clusters[2], mid_control).translation_to_rotate_pivot()
        xform = space.create_xform_group(mid_control)

        space.create_follow_group(mid_control, self.clusters[2])

        space.create_multi_follow([self.top_control, self.btm_control], xform, mid_control, value=.5)

    def _create_controls(self):

        cluster_count = len(self.clusters)

        for inc in range(0, cluster_count):

            if inc == 0:
                self._create_top_control()

            if inc == cluster_count - 1:
                self._create_btm_control()

        self._create_mid_control()

    def create(self):
        super(QuadSpineRig, self).create()

        self._create_surface()
        self._create_clusters()
        self._attach_to_surface()

        self._create_controls()


class QuadFootRig(FootRig):

    def __init__(self, description, side=None):
        super(QuadFootRig, self).__init__(description, side)

        self.ball = None
        self.toe = None
        self.ball_attribute = None
        self.add_bank = True
        self.add_back_bank = False
        self.extra_ball = None

    def _create_yawout_roll(self, parent, name, scale=1.0):

        control, xform, driver = self._create_pivot_control(self.yawOut, name, scale=scale)

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.side_roll_axis), cd='%s.%s' % (attribute_control, name),
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.side_roll_axis), cd='%s.%s' % (attribute_control, name),
                               driverValue=10, value=-45, itt='spline', ott='spline')

        cmds.setInfinity('%s.rotate%s' % (driver, self.side_roll_axis), preInfinite='linear')
        cmds.setInfinity('%s.rotate%s' % (driver, self.side_roll_axis), postInfinite='linear')

        return control

    def _create_yawin_roll(self, parent, name, scale=1.0):

        control, xform, driver = self._create_pivot_control(self.yawIn, name, scale=scale)

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.side_roll_axis), cd='%s.%s' % (attribute_control, name),
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.side_roll_axis), cd='%s.%s' % (attribute_control, name),
                               driverValue=-10, value=-45, itt='spline', ott='spline')

        cmds.setInfinity('%s.rotate%s' % (driver, self.side_roll_axis), preInfinite='linear')
        cmds.setInfinity('%s.rotate%s' % (driver, self.side_roll_axis), postInfinite='linear')

        return control

    def _create_toe_roll(self, parent, name='toeRoll', scale=1):

        control, xform, driver = self._create_pivot_control(self.toe, name, scale=scale)

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.%s' % (attribute_control, name),
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.%s' % (attribute_control, name),
                               driverValue=10, value=45, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.%s' % (attribute_control, name),
                               driverValue=-10, value=-45, itt='spline', ott='spline')

        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), postInfinite='linear')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), preInfinite='linear')

        return control

    def _create_heel_roll(self, parent, name='heelRoll', scale=1.0):
        control, xform, driver = self._create_pivot_control(self.heel, name, scale=scale)

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.%s' % (attribute_control, name),
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.%s' % (attribute_control, name),
                               driverValue=10, value=45, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.%s' % (attribute_control, name),
                               driverValue=-10, value=-45, itt='spline', ott='spline')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), preInfinite='linear')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), postInfinite='linear')

        return control

    def _create_ball_roll(self, parent):

        control, xform, driver = self._create_pivot_control(self.ball, 'ball')

        attr.disconnect_attribute('%sShape.visibility' % control)
        cmds.setAttr('%sShape.visibility' % control, 1)

        # attr.connect_reverse('%s.ikFk' % self.roll_control.get(), '%sShape.visibility' % control)

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.ballRoll' % attribute_control,
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.ballRoll' % attribute_control,
                               driverValue=10, value=45, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.ballRoll' % attribute_control,
                               driverValue=-10, value=-45, itt='spline', ott='spline')
        # cmds.setDrivenKeyframe('%s.rotateX' % driver,cd = '%s.ballRoll' % attribute_control, driverValue = 20, value = 0, itt = 'spline', ott = 'spline')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), postInfinite='linear')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), preInfinite='linear')

        return control

    def _create_extra_roll(self, parent):

        control, xform, driver = self._create_pivot_control(self.extra_ball, 'extra')

        attr.disconnect_attribute('%sShape.visibility' % control)
        cmds.setAttr('%sShape.visibility' % control, 1)

        attr.connect_reverse('%s.ikFk' % self.roll_control.get(), '%sShape.visibility' % control)

        cmds.parent(xform, parent)

        attribute_control = self._get_attribute_control()

        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.extraRoll' % attribute_control,
                               driverValue=0, value=0, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.extraRoll' % attribute_control,
                               driverValue=10, value=45, itt='spline', ott='spline')
        cmds.setDrivenKeyframe('%s.rotate%s' % (driver, self.forward_roll_axis), cd='%s.extraRoll' % attribute_control,
                               driverValue=-10, value=-45, itt='spline', ott='spline')
        # cmds.setDrivenKeyframe('%s.rotateX' % driver,cd = '%s.ballRoll' % attribute_control, driverValue = 20, value = 0, itt = 'spline', ott = 'spline')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), postInfinite='linear')
        cmds.setInfinity('%s.rotate%s' % (driver, self.forward_roll_axis), preInfinite='linear')

        if self.extra_ball:
            if self.ik_leg:
                cmds.parent(self.ik_leg, control)

        return control

    def _create_roll_control(self, transform):

        roll_control = self._create_control('roll', curve_type=self.attribute_control_shape)

        self.roll_control = roll_control

        roll_control.scale_shape(.8, .8, .8)

        xform_group = space.create_xform_group(roll_control.get())

        roll_control.hide_scale_and_visibility_attributes()
        roll_control.hide_rotate_attributes()

        match_space = space.MatchSpace(transform, xform_group)
        match_space.translation_rotation()

        self.roll_control_xform = xform_group

        return roll_control

    def _create_roll_attributes(self):

        attribute_control = self._get_attribute_control()

        attr.create_title(attribute_control, 'roll')

        cmds.addAttr(attribute_control, ln='ballRoll', at='double', k=True)

        if self.extra_ball:
            cmds.addAttr(attribute_control, ln='extraRoll', at='double', k=True)

        cmds.addAttr(attribute_control, ln='toeRoll', at='double', k=True)
        cmds.addAttr(attribute_control, ln='heelRoll', at='double', k=True)

        cmds.addAttr(attribute_control, ln='yawIn', at='double', k=True)
        cmds.addAttr(attribute_control, ln='yawOut', at='double', k=True)

        if self.add_bank:

            attr.create_title(attribute_control, 'bank')

            cmds.addAttr(attribute_control, ln='bankIn', at='double', k=True)
            cmds.addAttr(attribute_control, ln='bankOut', at='double', k=True)

            if self.add_back_bank:
                cmds.addAttr(attribute_control, ln='bankBack', at='double', k=True)

    def _create_ik(self):
        if not self.extra_ball:
            self.ankle_handle = self._create_ik_handle('ankle', self.ankle, self.ball)
            cmds.parent(self.ankle_handle, self.setup_group)

            self.ball_handle = self._create_ik_handle('ball', self.ball, self.toe)
            cmds.parent(self.ball_handle, self.setup_group)

        if self.extra_ball:
            self.ankle_handle = self._create_ik_handle('ankle', self.ankle, self.extra_ball)
            self.extra_handle = self._create_ik_handle('ball', self.extra_ball, self.ball)
            self.ball_handle = self._create_ik_handle('ball', self.ball, self.toe)

            cmds.parent(self.ankle_handle, self.setup_group)
            cmds.parent(self.extra_handle, self.setup_group)
            cmds.parent(self.ball_handle, self.setup_group)

        if self.ik_parent:
            cmds.pointConstraint(self.ik_parent, self.ik_joints[0])

    def _create_pivot_groups(self):

        toe_control, toe_control_xform = self._create_toe_rotate_control()

        attribute_control = self._get_attribute_control()

        self._create_ik()

        attr.create_title(attribute_control, 'pivot')

        ankle_pivot = self._create_pivot('ankle', self.ankle, self.control_group)
        heel_pivot = self._create_pivot('heel', self.heel, ankle_pivot)
        ball_pivot = self._create_pivot('ball', self.ball, heel_pivot)
        toe_pivot = self._create_pivot('toe', self.toe, ball_pivot)

        toe_roll = self._create_toe_roll(toe_pivot)
        heel_roll = self._create_heel_roll(toe_roll)
        yawin_roll = self._create_yawin_roll(heel_roll, 'yawIn')
        yawout_roll = self._create_yawout_roll(yawin_roll, 'yawOut')

        next_roll = yawout_roll

        if not self.extra_ball:
            ball_roll = self._create_ball_roll(yawout_roll)
            next_roll = ball_roll

        if not self.add_bank:
            cmds.parent(toe_control_xform, yawout_roll)

        if self.add_bank:

            bankin_roll = self._create_yawin_roll(next_roll, 'bankIn', scale=.5)
            bankout_roll = self._create_yawout_roll(bankin_roll, 'bankOut', scale=.5)

            next_roll = bankout_roll

            if self.add_back_bank:
                bankback_roll = self._create_heel_roll(bankout_roll, 'bankBack', scale=.5)
                next_roll = bankback_roll

        if not self.add_bank:
            if not self.extra_ball:
                next_roll = yawout_roll

        if self.extra_ball:
            ball_roll = self._create_ball_roll(next_roll)
            extra_roll = self._create_extra_roll(ball_roll)

            cmds.parentConstraint(ball_roll, self.extra_handle, mo=True)
            cmds.parentConstraint(ball_roll, self.ball_handle, mo=True)
            cmds.parentConstraint(extra_roll, self.ankle_handle, mo=True)

        if not self.extra_ball:

            cmds.parentConstraint(toe_control, self.ball_handle, mo=True)

            if not self.add_bank:
                cmds.parentConstraint(ball_roll, self.ankle_handle, mo=True)

                cmds.parent(self.ik_leg, ball_roll)
            if self.add_bank:
                cmds.parentConstraint(bankout_roll, self.ankle_handle, mo=True)
                cmds.parent(self.ik_leg, bankout_roll)

                space.create_follow_group(yawout_roll, toe_control_xform)

        cmds.parentConstraint(ball_roll, self.roll_control_xform, mo=True)

    def set_add_bank(self, bool_value, add_back_bank=False):
        self.add_bank = bool_value
        if add_back_bank:
            self.add_back_bank = True

    def set_extra_ball(self, joint_name):

        self.extra_ball = joint_name

    def create(self):

        if self.extra_ball:
            self.joints.insert(2, self.extra_ball)

        super(FootRig, self).create()

        if len(self.joints) < 3:
            vtool.util.warning('Please set three joints. set_joints([joint_ankle, joint_ball, joint_toe])')

        if not self.joints[0] or not self.joints[1] or not self.joints[2]:
            vtool.util.warning('Please set_pivot_locators(heel, yaw_in, yaw_out)')
            return

        self._create_ik_chain()

        self._attach_ik_chain()

        self.ankle = self.ik_joints[0]
        self.ball = self.ik_joints[1]
        self.toe = self.ik_joints[2]

        self._create_roll_attributes()

        self._create_pivot_groups()

# ---Face Rig


class EyeLidCurveRig(JointRig):
    """
    Very slow.
    """

    def __init__(self, description, side=None):

        super(EyeLidCurveRig, self).__init__(description, side)

        self.surface = None

        self.offset_group = None

        self.main_joint_dict = {}
        self.row_joint_dict = {}
        self.main_controls = []

        self.orient_transform = None
        self.orient_aim = False
        self.orient_aim_axis = 'Z'

        self.invert_y = False

        self.follow_multiply = 1

        self.control_offset = 0
        self.sub_control_size = 0.5

    def _create_curve(self):

        self.curve = geo.transforms_to_curve(self.joints, 4, self.description)

        self.sub_curve = geo.transforms_to_curve(self.joints, 4, 'sub_' + self.description)

        cmds.parent(self.curve, self.setup_group)
        cmds.parent(self.sub_curve, self.setup_group)

    def _cluster_curve(self):

        self.clusters = deform.cluster_curve(self.curve, self.description)

        self.sub_cluster = deform.cluster_curve(self.sub_curve, 'sub_' + self.description)

        cmds.parent(self.clusters, self.setup_group)
        cmds.parent(self.sub_cluster, self.setup_group)

    def _aim_constraint(self, center_transform, transform_to_aim):

        axis = [1, 0, 0]
        up_vector = [0, 1, 0]

        if self.orient_aim_axis == 'X':
            axis = [-1, 0, 0]
            up_vector = [0, 1, 0]
        if self.orient_aim_axis == 'Y':
            axis = [0, 1, 0]
            up_vector = [0, 0, -1]
        if self.orient_aim_axis == 'Z':
            axis = [0, 0, -1]
            up_vector = [0, 1, 0]

        cmds.aimConstraint(center_transform, transform_to_aim, aimVector=axis, upVector=up_vector,
                           wut='objectrotation',
                           wuo=center_transform)

    def _create_controls(self):
        for inc, cluster in enumerate(self.clusters):
            if self.orient_aim:
                parent = cmds.listRelatives(cluster, p=True)

                offset = cmds.group(em=True, n=core.inc_name('offset_%s' % cluster))

                if parent:
                    cmds.parent(offset, parent[0])

                space.MatchSpace(cluster, offset).translation_to_rotate_pivot()
                space.MatchSpace(self.orient_transform, offset).rotation()

                cluster_group = cmds.group(em=True, n=core.inc_name('buffer_%s' % cluster))
                space.MatchSpace(offset, cluster_group).translation_rotation()
                space.MatchSpace(self.orient_transform, cluster_group).rotation()

                cmds.parent(cluster_group, offset)
                cmds.parent(cluster, cluster_group)

                cmds.setAttr('%s.inheritsTransform' % offset, 0)

            if not self.orient_aim:
                cmds.setAttr('%s.inheritsTransform' % cluster, 0)

            control = self._create_control()
            control.hide_scale_attributes()
            control.rotate_shape(90, 0, 0)

            control.scale_shape(self.control_size, self.control_size, self.control_size)
            control.translate_shape(0, 0, self.control_offset)

            self.main_controls.append(control.get())

            if self.surface:
                sub_control = self._create_control(sub=True)
                sub_control.hide_scale_attributes()

                sub_size = self.sub_control_size * self.control_size

                sub_control.scale_shape(sub_size, sub_size, sub_size)
                sub_control.rotate_shape(90, 0, 0)
                sub_control.translate_shape(0, 0, self.control_offset)

                cmds.parent(sub_control.get(), control.get())

                space.create_xform_group(sub_control.get())
                sub_driver = space.create_xform_group(sub_control.get(), 'driver')

                attr.connect_translate(sub_control.get(), self.sub_cluster[inc])
                attr.connect_translate(sub_driver, self.sub_cluster[inc])

                cmds.setAttr('%s.inheritsTransform' % self.sub_cluster[inc], 0)

            space.MatchSpace(cluster, control.get()).translation_to_rotate_pivot()

            if self.orient_transform:
                space.MatchSpace(self.orient_transform, control.get()).rotation()

            space.create_xform_group(control.get())
            driver = space.create_xform_group(control.get(), 'driver')
            if not self.orient_aim:
                attr.connect_translate(control.get(), cluster)
                attr.connect_translate(driver, cluster)
            if self.orient_aim:
                attr.connect_translate(control.get(), cluster_group)
                attr.connect_translate(driver, cluster_group)

    def _attach_joints_to_curve(self):

        for joint in self.joints:

            parent = cmds.listRelatives(joint, p=True)[0]

            xform = cmds.group(em=True, n=core.inc_name('xform_%s' % joint))
            space.MatchSpace(joint, xform).translation()
            cmds.parent(xform, parent)

            offset = space.create_xform_group(joint, 'offset')
            driver = space.create_xform_group(joint, 'driver')

            if self.orient_aim:
                self._aim_constraint(self.orient_transform, joint)

            if joint not in self.main_joint_dict:
                self.main_joint_dict[joint] = {}

            self.main_joint_dict[joint]['xform'] = xform
            self.main_joint_dict[joint]['driver'] = driver

            geo.attach_to_curve(xform, self.curve)

            if self.surface:
                cmds.geometryConstraint(self.surface, xform)

            geo.attach_to_curve(driver, self.sub_curve)

            plus = cmds.createNode('plusMinusAverage', n=core.inc_name('subtract_%s' % driver))

            input_x = attr.get_attribute_input('%s.translateX' % driver)
            input_y = attr.get_attribute_input('%s.translateY' % driver)
            input_z = attr.get_attribute_input('%s.translateZ' % driver)

            value_x = cmds.getAttr('%s.translateX' % driver)
            value_y = cmds.getAttr('%s.translateY' % driver)
            value_z = cmds.getAttr('%s.translateZ' % driver)

            cmds.connectAttr(input_x, '%s.input3D[0].input3Dx' % plus)
            cmds.connectAttr(input_y, '%s.input3D[0].input3Dy' % plus)
            cmds.connectAttr(input_z, '%s.input3D[0].input3Dz' % plus)

            cmds.setAttr('%s.input3D[1].input3Dx' % plus, -1 * value_x)
            cmds.setAttr('%s.input3D[1].input3Dy' % plus, -1 * value_y)
            cmds.setAttr('%s.input3D[1].input3Dz' % plus, -1 * value_z)

            attr.disconnect_attribute('%s.translateX' % driver)
            attr.disconnect_attribute('%s.translateY' % driver)
            attr.disconnect_attribute('%s.translateZ' % driver)

            cmds.connectAttr('%s.output3Dx' % plus, '%s.translateX' % driver)
            cmds.connectAttr('%s.output3Dy' % plus, '%s.translateY' % driver)
            cmds.connectAttr('%s.output3Dz' % plus, '%s.translateZ' % driver)

            cmds.parent(offset, xform)

    def set_control_offset(self, value):

        self.control_offset = value

    def set_surface(self, surface_name):
        self.surface = surface_name

    def set_orient(self, transform):

        self.orient_transform = transform

    def set_orient_aim(self, bool_value, axis='Z'):

        self.orient_aim_axis = axis
        self.orient_aim = bool_value

    def set_follow_multiply(self, value):
        self.follow_multiply = value

    def set_invert_y_value(self, bool_value):

        self.invert_y = bool_value

    def create(self):
        super(EyeLidCurveRig, self).create()

        if self.orient_transform:
            self.orient_transform = cmds.duplicate(self.orient_transform,
                                                   n=core.inc_name(self._get_name('orient')),
                                                   po=True
                                                   )[0]

        self._create_curve()

        self._cluster_curve()

        self._create_controls()

        self._attach_joints_to_curve()

    def create_fade_row(self, joints, weight, ignore_surface=False):

        if len(joints) != len(self.joints):
            cmds.warning('Row joint count and rig joint count do not match.')

        for inc in range(0, len(self.joints)):
            """
            groups_created = False
            if joints[inc] in self.row_joint_dict:

                xform = self.row_joint_dict[joints[inc]]['xform']
                offset = self.row_joint_dict[joints[inc]]['offset']
                driver = self.row_joint_dict[joints[inc]]['driver']

            if not joints[inc] in self.row_joint_dict:

                xform = space.create_xform_group(joints[inc])
                offset = space.create_xform_group(joints[inc], 'offset')
                driver = space.create_xform_group(joints[inc], 'driver')

                self.row_joint_dict[joints[inc]] = {}
                self.row_joint_dict[joints[inc]]['xform'] = xform
                self.row_joint_dict[joints[inc]]['offset'] = offset
                self.row_joint_dict[joints[inc]]['driver'] = driver
                groups_created = True
            """

            driver = cmds.listRelatives(joints[inc], p=True)[0]
            offset = cmds.listRelatives(driver, p=True)
            xform = cmds.listRelatives(offset, p=True)

            if driver:
                driver = driver[0]
            if offset:
                offset = offset[0]
            if xform:
                xform = xform[0]

            if not xform == 'xform_%s' % joints[inc]:
                parent = cmds.listRelatives(joints[inc], parent=True)

                xform = cmds.group(em=True, n=core.inc_name('xform_%s' % joints[inc]))
                # xform = space.create_xform_group(joints[inc])

                space.MatchSpace(joints[inc], xform).translation()

                if parent:
                    cmds.parent(xform, parent[0])

                cmds.parent(joints[inc], xform)

            if not offset == 'offset_%s' % joints[inc]:
                offset = space.create_xform_group(joints[inc], 'offset')

            if not driver == 'driver_%s' % joints[inc]:
                driver = space.create_xform_group(joints[inc], 'driver')

                if self.orient_aim:
                    self._aim_constraint(self.orient_transform, driver)

            cmds.parent(driver, w=True)

            main_xform = self.main_joint_dict[self.joints[inc]]['xform']
            main_driver = self.main_joint_dict[self.joints[inc]]['driver']

            if not ignore_surface:
                attr.connect_translate_multiply(main_xform, offset, weight, respect_value=True)
                attr.connect_translate_multiply(main_driver, joints[inc], weight, respect_value=True)

            if ignore_surface:
                attr.connect_translate_multiply(main_xform, joints[inc], weight, respect_value=True)

            if self.surface:
                connection = attr.get_attribute_input('%s.geometry' % offset, node_only=True)

                if not cmds.nodeType(connection) == 'geometryConstraint':
                    cmds.geometryConstraint(self.surface, offset)

            cmds.parent(driver, offset)

    def create_control_follow(self, control, increment, weight):

        main_control = self.main_controls[increment]
        parent = cmds.listRelatives(main_control, p=True)[0]

        value = self.follow_multiply * weight

        multiply = attr.connect_translate_multiply(control, parent, value)

        if self.invert_y:
            value = cmds.getAttr('%s.input2Y' % multiply)
            value = value * -1
            cmds.setAttr('%s.input2Y' % multiply, value)

            control_parent = cmds.listRelatives(control, p=True)

            if control_parent:
                if control_parent[0] == 'driver_%s' % control:
                    cmds.setAttr('%s.scaleY' % control_parent[0], -1)


class EyeLidAimRig(JointRig):

    def __init__(self, description, side=None):
        super(EyeLidAimRig, self).__init__(description, side)

        self.orient_aim_axis = 'Z'
        self.center_locator = None
        self.control_offset = 0
        self.follow_multiply = 1

        self.scale_space = 1
        self.use_joint = True

    def _aim_constraint(self, transform_to_aim, aim_target):

        axis = [1, 0, 0]
        up_vector = [0, 1, 0]

        if self.orient_aim_axis == 'X':
            axis = [-1, 0, 0]
            up_vector = [0, 1, 0]
        if self.orient_aim_axis == 'Y':
            axis = [0, 1, 0]
            up_vector = [0, 0, -1]
        if self.orient_aim_axis == 'Z':
            axis = [0, 0, -1]
            up_vector = [0, 1, 0]

        cmds.aimConstraint(aim_target, transform_to_aim, aimVector=axis, upVector=up_vector,
                           wut='objectrotation',
                           wuo=self.center_locator)

    def _create_curve(self):

        self.curve = geo.transforms_to_curve(self.joints, 4, self.description)

        cmds.parent(self.curve, self.setup_group)

    def _attach_to_curve(self, transforms):

        for transform in transforms:
            geo.attach_to_curve(transform, self.curve)

    def _cluster_curve(self):

        self.clusters = deform.cluster_curve(self.curve, self.description)

        for cluster in self.clusters:
            cmds.setAttr('%s.inheritsTransform' % cluster, 0)

        cmds.parent(self.clusters, self.setup_group)

    def _create_controls(self):
        local_group = self._create_setup_group('local')
        cmds.setAttr('%s.inheritsTransform' % local_group, 0)

        for cluster in self.clusters:

            control = self._create_control()
            if self.use_joint:
                control.set_to_joint()

            control.rotate_shape(90, 0, 0)

            control.scale_shape(self.control_size, self.control_size, self.control_size)
            control.translate_shape(0, 0, self.control_offset)

            space.MatchSpace(cluster, control.get()).translation_to_rotate_pivot()

            xform = space.create_xform_group(control.get())
            driver = space.create_xform_group(control.get(), 'driver')

            if self.center_locator:
                space.MatchSpace(self.center_locator, xform).rotation()

                space.MatchSpace(self.center_locator, xform).scale()

            current_scale = cmds.getAttr('%s.scale' % xform)[0]

            if isinstance(self.scale_space, list):

                scale_value = [current_scale[0] * self.scale_space[0],
                               current_scale[1] * self.scale_space[1],
                               current_scale[2] * self.scale_space[2]]

                offset_scale = [1, 1, 1]

                if self.scale_space[0] < 0:
                    offset_scale[0] = -1

                if self.scale_space[1] < 0:
                    offset_scale[1] = -1

                if self.scale_space[2] < 0:
                    offset_scale[2] = -1

                cmds.scale(scale_value, scale_value, scale_value, xform)
                cmds.scale(offset_scale[0], offset_scale[1], offset_scale[2], control.control)

            if not isinstance(self.scale_space, list):
                if self.scale_space < 1 or self.scale_space > 1:
                    cmds.scale(self.scale_space * current_scale[0], self.scale_space * current_scale[1],
                               self.scale_space * current_scale[2], xform)
            if self.use_joint:
                cmds.connectAttr('%s.scale' % xform, '%s.inverseScale' % control.control)
            local, local_xform = space.constrain_local(control.get(), cluster)
            local_driver = space.create_xform_group(local, 'driver')
            attr.connect_scale(xform, local_xform)
            attr.connect_translate(driver, local_driver)
            cmds.parent(local_xform, local_group)

    def set_control_offset(self, value):
        self.control_offset = value

    def set_scale_space(self, value):
        self.scale_space = value

    def set_use_joint_controls(self, value):
        self.use_joint = value

    def set_center_locator(self, locator):
        self.center_locator = locator

    def set_follow_multiply(self, value):
        self.follow_multiply = value

    def create(self):
        super(EyeLidAimRig, self).create()

        if not self.center_locator:
            vtool.util.warning('Please provide a center locator.')
            return

        targets = []

        for joint in self.joints:
            locator_aim = cmds.spaceLocator(n=core.inc_name('locator_%s' % core.inc_name(self._get_name('aim'))))[0]
            cmds.parent(locator_aim, self.setup_group)

            locator_target = cmds.spaceLocator(n=core.inc_name('locator_%s' % self._get_name('target')))[0]
            targets.append(locator_target)
            cmds.parent(locator_target, self.setup_group)

            space.MatchSpace(self.center_locator, locator_aim).translation_rotation()
            space.MatchSpace(joint, locator_target).translation()
            space.MatchSpace(self.center_locator, locator_target).rotation()

            self._aim_constraint(locator_aim, locator_target)

            cmds.parentConstraint(locator_aim, joint, mo=True)

        self._create_curve()
        self._attach_to_curve(targets)
        self._cluster_curve()
        self._create_controls()

    def create_control_follow(self, main_control, increment, weight):

        control = self.controls[increment]
        driver = space.get_xform_group(control, 'driver')

        xform = space.get_xform_group(control)

        main_xform = space.get_xform_group(main_control)

        scale = cmds.getAttr('%s.scale' % xform)[0]
        main_scale = cmds.getAttr('%s.scale' % main_xform)[0]

        if main_scale[0] < 0:
            cmds.setAttr('%s.scaleX' % xform, (scale[0] * -1))
        if main_scale[1] < 0:
            cmds.setAttr('%s.scaleY' % xform, (scale[0] * -1))
        if main_scale[2] < 0:
            cmds.setAttr('%s.scaleZ' % xform, (scale[0] * -1))

        value = self.follow_multiply * weight

        attr.connect_translate_multiply(main_control, driver, value)


class StickyRig(JointRig):

    def __init__(self, description, side=None):
        super(StickyRig, self).__init__(description, side)

        self.top_stick_values = None
        self.btm_stick_values = None
        self.top_joints = []
        self.btm_joints = []
        self.respect_side = True
        self.respect_side_tolerance = 0.01
        self.straight_loop = False

        self.locators = []
        self.zip_controls = []

        self.follower_group = None

        self.first_side = side

        self.control_dict = {}

        self.follow_control_groups = {}

        self.top_controls = []
        self.btm_controls = []

        self.local = True

        self.sticky_control_group = self._create_control_group('sticky')

        self.tweaker_space = 1

        self.use_joint = True

        self._right_side_fix = True

        # self.sticky_control_group = cmds.group(em = True, n = core.inc_name(self._get_name('group', 'sticky_controls')))
        # cmds.parent(self.sticky_control_group, self.control_group)

    def _pre_create(self):
        super(JointRig, self)._pre_create()
        vtool.util.show('Using top joints:%s' % self.top_joints)
        vtool.util.show('Using btm joints:%s' % self.btm_joints)

        if not self.top_joints or not self.btm_joints:
            vtool.util.warning('No joints passed. Nothing to build')
            return False

    def _loop_joints(self):

        if self.local:
            self.sticky_setup_group = self._create_setup_group('sticky')

        self.top_joint_group = cmds.group(em=True, n=core.inc_name(self._get_name('group', 'joints_top')))
        self.btm_joint_group = cmds.group(em=True, n=core.inc_name(self._get_name('group', 'joints_btm')))

        self.top_locator_group = cmds.group(em=True, n=core.inc_name(self._get_name('group', 'locators_top')))
        self.mid_locator_group = cmds.group(em=True, n=core.inc_name(self._get_name('group', 'locators_mid')))
        self.btm_locator_group = cmds.group(em=True, n=core.inc_name(self._get_name('group', 'locators_btm')))

        cmds.parent(self.top_joint_group, self.btm_joint_group, self.setup_group)
        cmds.parent(self.top_locator_group, self.mid_locator_group, self.btm_locator_group, self.control_group)

        cmds.hide(self.top_locator_group, self.mid_locator_group, self.btm_locator_group)

        joint_count = len(self.top_joints)

        if self.straight_loop:
            for inc in range(0, joint_count):
                self._create_increment(inc)

        if not self.straight_loop:
            for inc in range(0, joint_count):

                negative_inc = joint_count - (inc + 1)

                self._create_increment(inc)

                locators1 = [self.top_locator, self.btm_locator]

                if not self.controls:
                    top_control1 = self.sub_controls[-1]
                    btm_control1 = self.sub_controls[-2]
                if self.controls:
                    top_control1 = self.controls[-1]
                    btm_control1 = self.controls[-2]

                if inc == negative_inc:
                    self.locators.append([locators1])
                    self.zip_controls.append([[top_control1, btm_control1]])
                    break

                self._create_increment(negative_inc)

                locators2 = [self.top_locator, self.btm_locator]

                if not self.controls:
                    top_control2 = self.sub_controls[-1]
                    btm_control2 = self.sub_controls[-2]
                if self.controls:
                    top_control2 = self.controls[-1]
                    btm_control2 = self.controls[-2]

                self.locators.append([locators1, locators2])
                self.zip_controls.append([[top_control1, btm_control1], [top_control2, btm_control2]])

        self.side = self.first_side

    def _create_increment(self, inc):
        top_joint = self.top_joints[inc]
        btm_joint = self.btm_joints[inc]

        if self.respect_side:
            side = space.get_side(top_joint, self.respect_side_tolerance)
            self.side = side

        control_top = self._create_sticky_control(top_joint, 'top')
        self.top_controls.append(control_top[0])
        control_btm = self._create_sticky_control(btm_joint, 'btm')
        self.btm_controls.append(control_btm[0])

        self.top_locator = self._create_locator('top')
        self.mid_top_locator = self._create_locator('mid_top')
        self.mid_btm_locator = self._create_locator('mid_btm')
        self.btm_locator = self._create_locator('btm')

        self.control_dict[control_top[0]] = [control_top[1], control_top[2]]
        self.control_dict[control_btm[0]] = [control_btm[1], control_btm[2]]

        # space.MatchSpace(top_joint, self.top_locator[1]).translation_rotation()
        # space.MatchSpace(btm_joint, self.btm_locator[1]).translation_rotation()
        space.MatchSpace(top_joint, self.top_locator[1]).translation()
        space.MatchSpace(btm_joint, self.btm_locator[1]).translation()

        midpoint = space.get_midpoint(top_joint, btm_joint)

        cmds.xform(self.mid_top_locator[1], t=midpoint, ws=True)
        cmds.xform(self.mid_btm_locator[1], t=midpoint, ws=True)

        cmds.parent(self.top_locator[1], self.top_locator_group)
        cmds.parent(self.mid_top_locator[1], self.mid_locator_group)
        cmds.parent(self.mid_btm_locator[1], self.mid_locator_group)
        cmds.parent(self.btm_locator[1], self.btm_locator_group)

        space.MatchSpace(self.top_locator[0], self.mid_top_locator[0]).translation()
        space.MatchSpace(self.btm_locator[0], self.mid_btm_locator[0]).translation()

        self._create_follow([self.top_locator[0], self.mid_top_locator[0]], control_top[1], top_joint)

        control_top_xform = space.get_xform_group(control_top[0])

        cmds.addAttr(control_top_xform, ln='stick', min=0, max=1, k=True)

        cmds.connectAttr('%s.stick' % control_top_xform, '%s.stick' % top_joint)

        control_btm_xform = space.get_xform_group(control_btm[0])

        self._create_follow([self.btm_locator[0], self.mid_btm_locator[0]], control_btm[1], control_btm_xform)

        self._create_follow([self.top_locator[0], self.btm_locator[0]], self.mid_top_locator[1],
                            self.mid_top_locator[0])
        self._create_follow([self.top_locator[0], self.btm_locator[0]], self.mid_btm_locator[1],
                            self.mid_btm_locator[0])

        cmds.setAttr('%s.stick' % self.mid_top_locator[0], 0.5)
        cmds.setAttr('%s.stick' % self.mid_btm_locator[0], 0.5)

    def _create_follow(self, source_list, target, target_control):

        constraint = cmds.parentConstraint(source_list, target, mo=True)[0]
        cmds.setAttr('%s.interpType' % constraint, 2)
        constraint_editor = space.ConstraintEditor()
        constraint_editor.create_switch(target_control, 'stick', constraint)

    def _create_sticky_xform(self, control):

        xform = space.create_xform_group(control)

        cmds.makeIdentity(control, apply=True, r=True)

        xform_driver = space.create_xform_group(control, 'xform_driver')

        driver = space.create_xform_group(control, 'driver')

        space.create_xform_group(control, 'xform_space')
        scale = space.create_xform_group(control, 'scale')

        pin = space.PinXform(driver)
        pin.pin()
        cmds.xform(xform_driver, ws=True, ro=[0, 0, 0])
        pin.unpin()

        pin = space.PinXform(driver)
        pin.pin()
        cmds.xform(driver, ws=True, ro=[0, 0, 0])
        pin.unpin()

        if self.side == 'R' and self._right_side_fix:
            cmds.setAttr('%s.rotateY' % scale, 180)
            cmds.setAttr('%s.scaleZ' % scale, -1)

        return xform, driver, scale

    def _create_sticky_control(self, transform, description):

        control = self._create_control(description)
        control.rotate_shape(90, 0, 0)
        control.scale_shape(.5, .5, .5)

        if self.use_joint:
            control.set_to_joint()

        control_name = control.get()

        space.MatchSpace(transform, control_name).translation_rotation()

        control = control_name

        xform, driver, scale = self._create_sticky_xform(control)
        cmds.parent(xform, self.sticky_control_group)

        if not self._right_side_fix:
            space.MatchSpace(transform, scale).scale()

        if not self.local:
            cmds.parentConstraint(control, transform)
            constraint = cmds.scaleConstraint(control, transform)[0]
            space.scale_constraint_to_local(constraint)

        if self.local:
            locator = cmds.spaceLocator(n=core.inc_name('locator_%s' % control))[0]
            space.MatchSpace(transform, locator).translation_rotation()

            local_xform, local_driver, local_scale = self._create_sticky_xform(locator)

            attr.connect_transforms(xform, local_xform)
            attr.connect_transforms(driver, local_driver)
            attr.connect_transforms(scale, local_scale)
            attr.connect_transforms(control, locator)

            cmds.parentConstraint(locator, transform)

            cmds.parent(local_xform, self.sticky_setup_group)

        if self.tweaker_space < 1 or self.tweaker_space > 1:

            if self.use_joint:
                space.connect_inverse_scale(scale, control)

            scale_x = cmds.getAttr('%s.scaleX' % scale)
            scale_y = cmds.getAttr('%s.scaleY' % scale)
            scale_z = cmds.getAttr('%s.scaleZ' % scale)

            scale_x = self.tweaker_space * (abs(scale_x) / scale_x)
            scale_y = self.tweaker_space * (abs(scale_y) / scale_y)
            scale_z = self.tweaker_space * (abs(scale_z) / scale_z)

            cmds.setAttr('%s.scaleX' % scale, scale_x)
            cmds.setAttr('%s.scaleY' % scale, scale_y)
            cmds.setAttr('%s.scaleZ' % scale, scale_z)

        return control, xform, driver

    def _create_locator(self, description):

        locator = cmds.spaceLocator(n=core.inc_name(self._get_name('locator', description)))[0]

        xform = space.create_xform_group(locator)
        driver = space.create_xform_group(locator, 'driver')

        return locator, xform, driver

    def _create_follow_control_group(self, follow_control):

        if follow_control not in self.follow_control_groups.keys():
            group = cmds.group(em=True, n=core.inc_name('follow_group_%s' % follow_control))
            space.MatchSpace(follow_control, group).translation_rotation()

            cmds.parent(group, self.follower_group)
            space.create_xform_group(group)

            attr.connect_translate_plus(follow_control, group)
            attr.connect_rotate(follow_control, group)
            attr.connect_scale(follow_control, group)

            self.follow_control_groups[follow_control] = group

        return self.follow_control_groups[follow_control]

    def _connect_bulge_scale(self, main_control, joint, joint_control):

        constraint = cmds.listRelatives(joint, type='scaleConstraint')
        if constraint:
            cmds.delete(constraint)

        multiply = attr.connect_multiply('%s.bulge' % main_control, '%s.scaleX' % joint)
        cmds.connectAttr('%s.outputY' % multiply, '%s.scaleY' % joint)
        cmds.connectAttr('%s.outputZ' % multiply, '%s.scaleZ' % joint)

        cmds.connectAttr('%s.bulge' % main_control, '%s.input1Y' % multiply)
        cmds.connectAttr('%s.bulge' % main_control, '%s.input1Z' % multiply)

        cmds.connectAttr('%s.scaleX' % joint_control, '%s.input2X' % multiply)
        cmds.connectAttr('%s.scaleY' % joint_control, '%s.input2Y' % multiply)
        cmds.connectAttr('%s.scaleZ' % joint_control, '%s.input2Z' % multiply)

    def set_respect_side(self, bool_value, tolerance=0.001):
        self.respect_side = bool_value
        self.respect_side_tolerance = tolerance

    def set_top_joints(self, joint_list):
        self.top_joints = joint_list

    def set_btm_joints(self, joint_list):
        self.btm_joints = joint_list

    def set_top_stick_values(self, float_list):
        self.top_stick_values = float_list

    def set_btm_stick_values(self, float_list):
        self.btm_stick_values = float_list

    def set_local(self, bool_value):

        self.local = bool_value

    def set_tweaker_space(self, value):

        self.tweaker_space = value

    def set_use_joint_controls(self, bool_value):
        self.use_joint = bool_value

    def set_right_side_fix(self, bool_value):
        self._right_side_fix = bool_value

    def create(self):
        super(StickyRig, self).create()

        self._loop_joints()

    def create_follow(self, follow_transform, increment, value):

        if not self.follower_group:
            self.follower_group = cmds.group(em=True, n=core.inc_name(self._get_name('group', 'follower')))
            cmds.parent(self.follower_group, self.control_group)

        follow_transform = self._create_follow_control_group(follow_transform)

        if increment >= 0:
            locators = self.locators[increment]

        top_locator1 = locators[0][0][1]
        btm_locator1 = locators[0][1][1]

        follow_top = space.create_multi_follow([self.follower_group, follow_transform], top_locator1, top_locator1,
                                               value=value)
        follow_btm = space.create_multi_follow([self.follower_group, follow_transform], btm_locator1, btm_locator1,
                                               value=1 - value)

        if len(locators) > 1:
            top_locator2 = locators[1][0][1]
            btm_locator2 = locators[1][1][1]

            space.create_multi_follow([self.follower_group, follow_transform], top_locator2, top_locator2, value=value)
            space.create_multi_follow([self.follower_group, follow_transform], btm_locator2, btm_locator2,
                                      value=1 - value)

    def create_zip(self, attribute_control, increment, start, end, end_value=1):

        left_over_value = 1.0 - end_value

        attr.create_title(attribute_control, 'ZIP')

        if not cmds.objExists('%s.zipL' % attribute_control):
            cmds.addAttr(attribute_control, ln='zipL', min=0, max=10, k=True)

        if not cmds.objExists('%s.zipR' % attribute_control):
            cmds.addAttr(attribute_control, ln='zipR', min=0, max=10, k=True)

        left_top_control = self.zip_controls[increment][0][0]
        left_btm_control = self.zip_controls[increment][0][1]

        xform_left_top_control = space.get_xform_group(left_top_control)
        xform_left_btm_control = space.get_xform_group(left_btm_control)

        anim.quick_driven_key('%s.zipL' % attribute_control, '%s.stick' % xform_left_top_control, [start, end],
                              [0, end_value])
        anim.quick_driven_key('%s.zipL' % attribute_control, '%s.stick' % xform_left_btm_control, [start, end],
                              [0, end_value])

        if left_over_value:
            xform_left_top_control = space.get_xform_group(left_top_control)
            xform_left_btm_control = space.get_xform_group(left_btm_control)

            anim.quick_driven_key('%s.zipR' % attribute_control, '%s.stick' % xform_left_top_control, [start, end],
                                  [0, left_over_value])
            anim.quick_driven_key('%s.zipR' % attribute_control, '%s.stick' % xform_left_btm_control, [start, end],
                                  [0, left_over_value])

        cmds.setAttr('%s.stick' % xform_left_top_control, lock=True, k=False, cb=True)
        cmds.setAttr('%s.stick' % xform_left_btm_control, lock=True, k=False, cb=True)

        right_increment = 1

        if len(self.zip_controls[increment]) == 1:
            right_increment = 0

        right_top_control = self.zip_controls[increment][right_increment][0]
        right_btm_control = self.zip_controls[increment][right_increment][1]

        xform_right_top_control = space.get_xform_group(right_top_control)
        xform_right_btm_control = space.get_xform_group(right_btm_control)

        anim.quick_driven_key('%s.zipR' % attribute_control, '%s.stick' % xform_right_top_control, [start, end],
                              [0, end_value])
        anim.quick_driven_key('%s.zipR' % attribute_control, '%s.stick' % xform_right_btm_control, [start, end],
                              [0, end_value])

        if left_over_value:
            xform_right_top_control = space.get_xform_group(right_top_control)
            xform_right_btm_control = space.get_xform_group(right_btm_control)

            anim.quick_driven_key('%s.zipL' % attribute_control, '%s.stick' % xform_right_top_control, [start, end],
                                  [0, left_over_value])
            anim.quick_driven_key('%s.zipL' % attribute_control, '%s.stick' % xform_right_btm_control, [start, end],
                                  [0, left_over_value])

        cmds.setAttr('%s.stick' % xform_right_top_control, lock=True, k=False, cb=True)
        cmds.setAttr('%s.stick' % xform_right_btm_control, lock=True, k=False, cb=True)

    def create_roll(self, control, increment, percent):

        control = vtool.util.convert_to_sequence(control)

        if len(control) == 1:
            top_center_control = control[0]
            btm_center_control = control[0]
        if len(control) > 1:
            top_center_control = control[0]
            btm_center_control = control[1]

        attr.create_title(top_center_control, 'LIP')

        if not cmds.objExists('%s.roll' % top_center_control):
            cmds.addAttr(top_center_control, ln='roll', k=True)

        if not cmds.objExists('%s.roll' % btm_center_control):
            cmds.addAttr(btm_center_control, ln='roll', k=True)

        if not cmds.objExists('%s.bulge' % top_center_control):
            cmds.addAttr(top_center_control, ln='bulge', k=True, dv=1, min=0.1)

        if not cmds.objExists('%s.bulge' % btm_center_control):
            cmds.addAttr(btm_center_control, ln='bulge', k=True, dv=1, min=0.1)

        top_left_control = self.zip_controls[increment][0][1]
        btm_left_control = self.zip_controls[increment][0][0]

        top_left_driver = self.control_dict[top_left_control][1]
        btm_left_driver = self.control_dict[btm_left_control][1]

        top_joint = self.top_joints[increment]
        btm_joint = self.btm_joints[increment]

        attr.connect_multiply('%s.roll' % top_center_control, '%s.rotateX' % top_left_driver, percent)
        attr.connect_multiply('%s.roll' % btm_center_control, '%s.rotateX' % btm_left_driver, -1 * percent)

        self._connect_bulge_scale(top_center_control, top_joint, top_left_control)
        self._connect_bulge_scale(btm_center_control, btm_joint, btm_left_control)

        cmds.connectAttr('%s.bulge' % top_center_control, '%s.scaleX' % top_left_driver)
        cmds.connectAttr('%s.bulge' % top_center_control, '%s.scaleY' % top_left_driver)
        cmds.connectAttr('%s.bulge' % top_center_control, '%s.scaleZ' % top_left_driver)

        cmds.connectAttr('%s.bulge' % btm_center_control, '%s.scaleX' % btm_left_driver)
        cmds.connectAttr('%s.bulge' % btm_center_control, '%s.scaleY' % btm_left_driver)
        cmds.connectAttr('%s.bulge' % btm_center_control, '%s.scaleZ' % btm_left_driver)

        if len(self.zip_controls[increment]) > 1:
            top_right_control = self.zip_controls[increment][1][1]
            btm_right_control = self.zip_controls[increment][1][0]

            top_right_driver = self.control_dict[top_right_control][1]
            btm_right_driver = self.control_dict[btm_right_control][1]

            attr.connect_multiply('%s.roll' % top_center_control, '%s.rotateX' % top_right_driver, percent)
            attr.connect_multiply('%s.roll' % btm_center_control, '%s.rotateX' % btm_right_driver, -1 * percent)

            top_joint = self.top_joints[(increment + 1) * -1]
            btm_joint = self.btm_joints[(increment + 1) * -1]

            self._connect_bulge_scale(top_center_control, top_joint, top_right_control)
            self._connect_bulge_scale(btm_center_control, btm_joint, btm_right_control)

            cmds.connectAttr('%s.bulge' % top_center_control, '%s.scaleX' % top_right_driver)
            cmds.connectAttr('%s.bulge' % top_center_control, '%s.scaleY' % top_right_driver)
            cmds.connectAttr('%s.bulge' % top_center_control, '%s.scaleZ' % top_right_driver)

            cmds.connectAttr('%s.bulge' % btm_center_control, '%s.scaleX' % btm_right_driver)
            cmds.connectAttr('%s.bulge' % btm_center_control, '%s.scaleY' % btm_right_driver)
            cmds.connectAttr('%s.bulge' % btm_center_control, '%s.scaleZ' % btm_right_driver)


class StickyFadeRig(StickyRig):

    def __init__(self, description, side=None):
        super(StickyFadeRig, self).__init__(description, side)

        self.corner_offsets = []
        self.sub_corner_offsets = []

        self.corner_control_shape = 'square'

        self.corner_match = []
        self.corner_xforms = []
        self.corner_controls = []

        self.corner_x_space = []
        self.corner_y_space = []
        self.corner_z_space = []

    def _set_corner_space(self, source, target):

        space_scale = space.TranslateSpaceScale()

        space_scale.set_source_translate(source)
        space_scale.set_target_scale(target)

        if self.corner_x_space:
            space_scale.set_x_space(self.corner_x_space[0], self.corner_x_space[1])

        if self.corner_y_space:
            space_scale.set_y_space(self.corner_y_space[0], self.corner_y_space[1])

        if self.corner_z_space:
            space_scale.set_z_space(self.corner_z_space[0], self.corner_z_space[1])

        space_scale.create()

    def _create_corner_fades(self):

        orig_side = self.side

        for side in ['L', 'R']:

            self.side = side

            corner_offset = cmds.group(em=True, n=core.inc_name(self._get_name('offset', 'corner')))
            # corner_offset_xform = space.create_xform_group(corner_offset)

            sub_corner_offset = cmds.duplicate(corner_offset, n=core.inc_name(self._get_name('subOffset', 'corner')))[0]
            # cmds.parent(sub_corner_offset, corner_offset_xform)

            if side == 'L':
                joint = self.top_joints[0]
            if side == 'R':
                joint = self.top_joints[-1]

            control = self._create_control('corner', curve_type=self.corner_control_shape)
            # control.set_curve_type(self.corner_control_shape)
            control.rotate_shape(90, 0, 0)
            control.hide_rotate_attributes()
            control.hide_scale_attributes()

            if self.use_joint:
                control.set_to_joint()

            sub_control = self._create_control('corner', sub=True, curve_type=self.corner_control_shape)
            # sub_control.set_curve_type(self.corner_control_shape)
            sub_control.rotate_shape(90, 0, 0)
            sub_control.scale_shape(.8, .8, .8)
            sub_control.hide_rotate_attributes()
            sub_control.hide_scale_attributes()

            if self.use_joint:
                sub_control.set_to_joint()

            cmds.parent(sub_control.get(), control.get())

            xform = space.create_xform_group(control.get())

            space.create_xform_group(control.get(), 'driver')

            self.corner_xforms.append(xform)
            self.corner_controls.append(control.get())

            # space.MatchSpace(joint, corner_offset_xform).translation()
            if not self.corner_match:
                space.MatchSpace(joint, xform).translation_rotation()
            if self.corner_match:

                if side == 'L':
                    corner_match = self.corner_match[0]
                if side == 'R':
                    corner_match = self.corner_match[1]

                match_space = space.MatchSpace(corner_match, xform)
                match_space.translation_rotation()

                const = cmds.scaleConstraint(corner_match, xform)
                cmds.delete(const)

            if self.use_joint:
                space.connect_inverse_scale(xform, control.control)

            self.corner_offsets.append(corner_offset)
            self.sub_corner_offsets.append(sub_corner_offset)

            corner_offset_xform = space.create_xform_group(corner_offset)

            if not self.local:
                cmds.pointConstraint(control.get(), corner_offset)
                cmds.pointConstraint(sub_control.get(), sub_corner_offset)

                cmds.pointConstraint(xform, corner_offset_xform)

            if self.local:
                space.MatchSpace(control.get(), corner_offset_xform).translation()
                space.MatchSpace(sub_control.get(), sub_corner_offset).translation()

                local, local_xform = space.constrain_local(control.get(), corner_offset)

                sub_local, sub_local_xform = space.constrain_local(sub_control.get(), sub_corner_offset)

                cmds.parent(sub_local_xform, local)
                attr.connect_scale(xform, local_xform)

                cmds.parent(local_xform, self.setup_group)

                buffer_joint = rigs_util.create_joint_buffer(sub_local, connect_inverse=False)

                space.MatchSpace(xform, sub_local_xform).scale()

                cmds.connectAttr('%s.scale' % local_xform, '%s.inverseScale' % buffer_joint)

            cmds.parent(corner_offset_xform, self.setup_group)
            cmds.parent(sub_corner_offset, corner_offset_xform)

            self._set_corner_space(control.control, xform)

        self.side = orig_side

    def _rename_followers(self, follow, description):

        const = space.ConstraintEditor()
        constraint = const.get_constraint(follow, 'parentConstraint')
        names = const.get_weight_names(constraint)

        follower1 = names[0][:-2]
        follower2 = names[1][:-2]

        cmds.rename(follower1, core.inc_name('%s_%s' % (description, follower1)))
        cmds.rename(follower2, core.inc_name('%s_%s' % (description, follower2)))

    def set_corner_match(self, left_transform, right_transform):
        self.corner_match = [left_transform, right_transform]

    def set_corner_control_shape(self, shape_name):
        self.corner_control_shape = shape_name

    def set_corner_x_space(self, positive, negative):
        self.corner_x_space = [positive, negative]

    def set_corner_y_space(self, positive, negative):
        self.corner_y_space = [positive, negative]

    def set_corner_z_space(self, positive, negative):
        self.corner_z_space = [positive, negative]

    def create(self):
        super(StickyFadeRig, self).create()

        self._create_corner_fades()

    def create_follow(self, follow_transform, increment, value, top_follow_transform=None):

        value = vtool.util.convert_to_sequence(value)

        value1 = value[0]

        if len(value) > 1:
            value2 = value[1]
        if len(value) == 1:
            value2 = 1.0 - value[0]

        if not self.follower_group:
            self.follower_group = cmds.group(em=True, n=core.inc_name(self._get_name('group', 'follower')))
            cmds.parent(self.follower_group, self.control_group)

        follow_transform = self._create_follow_control_group(follow_transform)
        follow_group = self.follower_group

        if top_follow_transform:
            top_follow_transform = self._create_follow_control_group(top_follow_transform)

            follow_group = top_follow_transform

        if increment != 'corner':
            if self.locators:
                locators = self.locators[increment]

                top_locator1 = locators[0][0][1]
                btm_locator1 = locators[0][1][1]

                follow_top = space.create_multi_follow([follow_group, follow_transform], top_locator1, top_locator1,
                                                       value=value1)
                follow_btm = space.create_multi_follow([follow_group, follow_transform], btm_locator1, btm_locator1,
                                                       value=value2)

                self._rename_followers(follow_top, 'top')
                self._rename_followers(follow_btm, 'btm')

                if len(locators) > 1:
                    top_locator2 = locators[1][0][1]
                    btm_locator2 = locators[1][1][1]

                    follow_top = space.create_multi_follow([follow_group, follow_transform], top_locator2, top_locator2,
                                                           value=value1)
                    follow_btm = space.create_multi_follow([follow_group, follow_transform], btm_locator2, btm_locator2,
                                                           value=value2)

                    self._rename_followers(follow_top, 'top')
                    self._rename_followers(follow_btm, 'btm')

        if increment == 'corner':
            space.create_multi_follow([follow_group, follow_transform], self.corner_xforms[0], self.corner_xforms[0],
                                      value=value1)
            space.create_multi_follow([follow_group, follow_transform], self.corner_xforms[1], self.corner_xforms[1],
                                      value=value1)

    def create_corner_falloff(self, inc, value):

        for side in ['L', 'R']:

            self.side = side

            if side == 'L':

                corner_control = self.corner_offsets[0]

                if inc > 0:
                    corner_control = self.corner_offsets[0]
                if inc == 0:
                    corner_control = self.sub_corner_offsets[0]

                top_control = self.zip_controls[inc][0][1]
                btm_control = self.zip_controls[inc][0][0]

                top_control_driver = self.control_dict[top_control][1]
                btm_control_driver = self.control_dict[btm_control][1]

            if side == 'R':

                corner_control = self.corner_offsets[1]

                if inc > 0:
                    corner_control = self.corner_offsets[1]
                if inc == 0:
                    corner_control = self.sub_corner_offsets[1]

                # minus 4 and 3 to skip the corner controls
                top_control = self.zip_controls[inc][1][1]
                btm_control = self.zip_controls[inc][1][0]

                top_control_driver = self.control_dict[top_control][1]
                btm_control_driver = self.control_dict[btm_control][1]

            attr.connect_translate_multiply(corner_control, top_control_driver, value)
            attr.connect_translate_multiply(corner_control, btm_control_driver, value)

    """
    def create_corner_locator(self, positive_scale_vector = None, negative_scale_vector = None):

        for control in self.corner_controls:

            top_xform = space.get_xform_group(control)
            parent = cmds.listRelatives(top_xform, p = True)
            if parent:
                parent = parent

            cmds.select(cl = True)
            locator = cmds.joint(n = 'locatorJoint_%s' % control)
            #locator = cmds.spaceLocator(n = 'locator_%s' % control)[0]
            xform = space.create_xform_group(locator)
            cmds.connectAttr('%s.scale' % xform, '%s.inverseScale' % locator)

            cmds.delete( cmds.parentConstraint(control, xform) )

            if parent:
                cmds.parent(xform, parent)

            self.set_corner_x_space(positive_scale_vector[0], negative_scale_vector[0])
            self.set_corner_y_space(positive_scale_vector[1], negative_scale_vector[1])
            self.set_corner_z_space(positive_scale_vector[2], negative_scale_vector[2])

            self._set_corner_space(locator, xform)

            cmds.parentConstraint(control, locator)
    """


class EyeRig(JointRig):

    def __init__(self, description, side=None):
        super(EyeRig, self).__init__(description, side)
        self._fk_control_shape = None
        self.local_parent = None
        self.parent = None

        self.eye_control_move = ['Z', 1]
        self.extra_control = False
        self.rotate_value = 25
        self.limit = 1
        self.skip_ik = False
        self._create_fk = False
        self._fk_control_shape_offset = 1
        self._constrain_local = True

    def _create_ik(self):

        duplicate_hierarchy = space.DuplicateHierarchy(self.joints[0])

        duplicate_hierarchy.stop_at(self.joints[-1])
        duplicate_hierarchy.replace('joint', 'ik')

        self.ik_chain = duplicate_hierarchy.create()

        cmds.parent(self.ik_chain[0], self.setup_group)

        if not self.skip_ik:
            ik = space.IkHandle(self.description)
            ik.set_start_joint(self.ik_chain[0])
            ik.set_end_joint(self.ik_chain[1])
            ik.set_solver(ik.solver_rp)
            handle = ik.create()

            cmds.parent(handle, self.setup_group)

            return handle

    def _create_eye_control(self, handle=None):

        control = None

        if not self.skip_ik:
            group1 = cmds.group(em=True, n=core.inc_name(self._get_name('group', 'aim')))
            group2 = cmds.group(em=True, n=core.inc_name(self._get_name('group', 'aim')))

            cmds.parent(group2, group1)
            cmds.parent(group1, self.setup_group)

            space.MatchSpace(self.joints[0], group1).translation_rotation()

            xform = space.create_xform_group(group1)
            # xform = space.create_xform_group(group2)

            attr.connect_rotate(self.ik_chain[0], group1)

            if not self.extra_control:
                cmds.orientConstraint(group2, self.joints[0], mo=True)

            control = self._create_control()
            control.hide_scale_attributes()
            control = control.get()

            match_space = space.MatchSpace(self.joints[1], control)
            match_space.translation_rotation()

            xform = space.create_xform_group(control)
            if self._constrain_local:
                local_group, local_xform = space.constrain_local(control, handle)
                cmds.parent(local_xform, self.setup_group)
                if self.local_parent:
                    cmds.parent(local_xform, self.local_parent)

            if not self._constrain_local:
                cmds.parentConstraint(control, handle, mo=True)
                cmds.parentConstraint(self.control_group, self.setup_group, mo=True)

            if self.parent:
                cmds.parent(xform, self.parent)

        if self.skip_ik:
            group1 = cmds.group(em=True, n=core.inc_name(self._get_name('group', 'aim')))

            cmds.parent(group1, self.setup_group)

            space.MatchSpace(self.joints[0], group1).translation_rotation()

            xform = space.create_xform_group(group1)

            cmds.orientConstraint(group1, self.joints[0], mo=True)

        if self.extra_control:
            self._rig_extra_control(group1)

        if self._create_fk:
            self._rig_fk(group1, group2)

        return control

    def _rig_fk(self, aim_transform, transform):

        control = self._create_control(sub=True)

        control.hide_translate_attributes()
        control.hide_scale_and_visibility_attributes()

        cmds.controller(control.control, self.controls[0], e=True, p=True)

        if self._fk_control_shape:
            control.set_curve_type(self._fk_control_shape)

        xform = space.create_xform_group(control.control)
        drive = space.create_xform_group(control.control, 'driver')

        space.MatchSpace(transform, xform).translation_rotation()

        letter = space.get_axis_letter_aimed_at_child(self.joints[0])

        offset = self._fk_control_shape_offset

        if letter.find('-') > -1:
            offset = self._fk_control_shape_offset * -1

        if letter.find('X') > -1:
            control.translate_shape(offset, 0, 0)
        if letter.find('Y') > -1:
            control.translate_shape(0, offset, 0)
        if letter.find('Z') > -1:
            control.translate_shape(0, 0, offset)

        attr.connect_rotate(control.control, transform)

        attr.connect_rotate(aim_transform, drive)

    def _rig_extra_control(self, group1):

        parent_group = cmds.group(em=True, n=core.inc_name(self._get_name('group', 'extra')))
        aim_group = cmds.group(em=True, n=core.inc_name(self._get_name('group', 'aim_extra')))

        space.MatchSpace(self.joints[0], aim_group).translation_rotation()
        space.MatchSpace(self.joints[0], parent_group).translation_rotation()

        xform_parent_group = space.create_xform_group(parent_group)
        xform_aim_group = space.create_xform_group(aim_group)

        cmds.parent(xform_aim_group, group1)

        attr.connect_rotate(group1, parent_group)

        # cmds.parent(xform_parent_group, self.setup_group)

        cmds.orientConstraint(aim_group, self.joints[0], mo=True)

        control2 = self._create_control(sub=True)
        control2.hide_scale_and_visibility_attributes()
        control2 = control2.get()

        cmds.controller(control2, self.controls[0], e=True, p=True)

        match_space = space.MatchSpace(self.joints[0], control2)
        match_space.translation_rotation()

        axis = self.eye_control_move[0]
        axis_value = self.eye_control_move[1]

        if axis == 'X':
            cmds.move(axis_value, 0, 0, control2, os=True, relative=True)
            attr.connect_multiply('%s.translateZ' % control2, '%s.rotateY' % aim_group, -self.rotate_value)
            attr.connect_multiply('%s.translateY' % control2, '%s.rotateZ' % aim_group, self.rotate_value)
        if axis == 'Y':
            cmds.move(0, axis_value, 0, control2, os=True, relative=True)
            attr.connect_multiply('%s.translateZ' % control2, '%s.rotateX' % aim_group, -self.rotate_value)
            attr.connect_multiply('%s.translateY' % control2, '%s.rotateZ' % aim_group, self.rotate_value)
        if axis == 'Z':
            cmds.move(0, 0, axis_value, control2, os=True, relative=True)
            attr.connect_multiply('%s.translateX' % control2, '%s.rotateY' % aim_group, self.rotate_value)
            attr.connect_multiply('%s.translateY' % control2, '%s.rotateX' % aim_group, -self.rotate_value)

        xform2 = space.create_xform_group(control2)
        cmds.parent(xform2, parent_group)
        cmds.parent(xform_parent_group, self.control_group)

        if axis == 'X':
            cmds.transformLimits(control2, tx=(0, 0), etx=(1, 1))
        if axis == 'Y':
            cmds.transformLimits(control2, ty=(0, 0), ety=(1, 1))
        if axis == 'Z':
            cmds.transformLimits(control2, tz=(0, 0), etz=(1, 1))

    def set_parent(self, parent):
        self.parent = parent

    def set_local_parent(self, local_parent):
        self.local_parent = local_parent

    def set_extra_control(self, axis, value, rotate_value=25, limit=1):

        self.eye_control_move = [axis, value]
        self.extra_control = True
        self.rotate_value = rotate_value

    def set_create_fk_control(self, bool_value, offset_control_shape=1, control_shape=None):
        self._fk_control_shape = control_shape
        self._fk_control_shape_offset = offset_control_shape
        self._create_fk = bool_value

    def set_skip_ik_control(self, bool_value):
        self.skip_ik = bool_value

    def set_constrain_local(self, bool_value):

        self._constrain_local = bool_value

    def create(self):

        handle = None

        if not self.skip_ik:
            handle = self._create_ik()

        control = self._create_eye_control(handle)

        if self.skip_ik:
            return

        locator = cmds.spaceLocator(n=core.inc_name('locator_%s' % self._get_name()))[0]

        match_space = space.MatchSpace(self.joints[0], locator)
        match_space.translation_rotation()

        cmds.parent(locator, self.control_group)

        line = rigs_util.RiggedLine(locator, control, self._get_name())
        cmds.parent(line.create(), self.control_group)

        cmds.setAttr('%s.translateX' % locator, l=True)
        cmds.setAttr('%s.translateY' % locator, l=True)
        cmds.setAttr('%s.translateZ' % locator, l=True)
        cmds.setAttr('%s.rotateX' % locator, l=True)
        cmds.setAttr('%s.rotateY' % locator, l=True)
        cmds.setAttr('%s.rotateZ' % locator, l=True)
        cmds.hide(locator)


class JawRig(FkLocalRig):

    def __init__(self, description, side=None):
        super(JawRig, self).__init__(description, side)
        self.jaw_slide_offset = .1
        self.jaw_slide_attribute = True
        self.jaw_slide_rotate_axis = 'X'
        self.jaw_slide_translate_axis = 'Z'
        self.follow_world = False

    def _attach(self, source_transform, target_transform):

        if not self.follow_world:
            local_group, local_xform = super(JawRig, self)._attach(source_transform, target_transform)
        if self.follow_world:
            cmds.parentConstraint(source_transform, target_transform)

        control = self.controls[-1]

        live_control = rigs_util.Control(control)
        live_control.rotate_shape(0, 0, 90)

        var = attr.MayaNumberVariable('autoSlide')
        var.set_variable_type(var.TYPE_DOUBLE)
        var.set_value(self.jaw_slide_offset)
        var.set_keyable(self.jaw_slide_attribute)
        var.create(control)

        driver = space.create_xform_group(control, 'driver')
        if not self.follow_world:
            driver_local = space.create_xform_group(local_group, 'driver')
            attr.connect_translate(driver, driver_local)

        multi = attr.connect_multiply('%s.rotate%s' % (control, self.jaw_slide_rotate_axis),
                                      '%s.translate%s' % (driver, self.jaw_slide_translate_axis))

        # cmds.connectAttr('%s.outputX' % multi, '%s.translate%s' % (driver_local, self.jaw_slide_translate_axis))
        var.connect_out('%s.input2X' % multi)

        if not self.follow_world:
            return local_group, local_xform

    def set_jaw_slide_offset(self, value):
        self.jaw_slide_offset = value

    def set_create_jaw_slide_attribute(self, bool_value):
        self.jaw_slide_attribute = bool_value

    def set_jaw_slide_rotate_axis(self, axis_letter):

        self.jaw_slide_rotate_axis = axis_letter.capitalize()

    def set_jaw_slide_translate_axis(self, axis_letter):

        self.jaw_slide_translate_axis = axis_letter.capitalize()

    def set_follow_world(self, bool_value):
        """
        If you need the rig to not stay at the origin but move with the rig.
        """
        self.follow_world = bool_value


class LipRig(JointRig):

    def __init__(self, description, side=None):
        super(LipRig, self).__init__(description, side)
        self.parameters = None
        self.param_control_dict = None

    def _create_curve(self):

        setup_curve_group = self._create_setup_group('curve')

        curve = geo.transforms_to_curve(self.joints, spans=None, description='from_transforms')
        cmds.parent(curve, setup_curve_group)

        geo.rebuild_curve(curve, spans=5, degree=2)
        self.temp_curve = cmds.duplicate(curve)[0]

        curve = cmds.rename(curve, self._get_name('curve'))
        self.curve = curve

        self._position_curve()
        self._create_locators()

        self._create_clusters(setup_curve_group)
        self.drivers = []

    def _position_curve(self):

        curve = self.curve

        cvs = cmds.ls('%s.cv[*]' % curve, flatten=True)

        center_position = geo.get_curve_position_from_parameter(curve, self.parameters[2])
        mid_position_left = geo.get_curve_position_from_parameter(curve, self.parameters[1])
        mid_position_right = geo.get_curve_position_from_parameter(curve, self.parameters[3])

        corner_pos_left = cmds.xform(cvs[0], q=True, ws=True, t=True)
        corner_pos_right = cmds.xform(cvs[-1], q=True, ws=True, t=True)

        cmds.xform(cvs[1], ws=True, t=corner_pos_left)
        cmds.xform(cvs[-2], ws=True, t=corner_pos_right)

        cmds.xform(cvs[2], ws=True, t=mid_position_left)
        cmds.xform(cvs[-3], ws=True, t=mid_position_right)

        start_center = geo.get_closest_parameter_on_curve(curve, center_position)
        start_center = geo.get_curve_position_from_parameter(curve, start_center)
        end_center = geo.get_closest_parameter_on_curve(self.temp_curve, center_position)
        end_center = geo.get_curve_position_from_parameter(self.temp_curve, end_center)

        start_left = geo.get_closest_parameter_on_curve(curve, mid_position_left)
        start_left = geo.get_curve_position_from_parameter(curve, start_left)
        end_left = geo.get_closest_parameter_on_curve(self.temp_curve, mid_position_left)
        end_left = geo.get_curve_position_from_parameter(self.temp_curve, end_left)

        start_right = geo.get_closest_parameter_on_curve(curve, mid_position_right)
        start_right = geo.get_curve_position_from_parameter(curve, start_right)
        end_right = geo.get_closest_parameter_on_curve(self.temp_curve, mid_position_right)
        end_right = geo.get_curve_position_from_parameter(self.temp_curve, end_right)

        import operator

        center_offset = map(operator.sub, end_center, start_center)
        left_offset = map(operator.sub, end_left, start_left)
        right_offset = map(operator.sub, start_right, end_right)

        cmds.move(center_offset[0], center_offset[1], center_offset[2], cvs[3], r=True)
        cmds.move(left_offset[0], left_offset[1], left_offset[2], cvs[2], r=True)
        cmds.move(right_offset[0], right_offset[1], right_offset[2], cvs[-3], r=True)

    def _create_locators(self):

        setup_loc_group = self._create_setup_group('locators')

        locators = []
        sub_locators = []
        joint_locators = []

        for joint in self.joints:
            joint_position = cmds.xform(joint, q=True, ws=True, t=True)
            parameter = geo.get_closest_parameter_on_curve(self.curve, joint_position)

            loc = cmds.spaceLocator(n='locPivot_%s' % joint)[0]
            loc2 = cmds.spaceLocator(n='locPivot2_%s' % joint)[0]
            loc3 = cmds.spaceLocator(n='loc_%s' % joint)[0]

            locators.append(loc)
            sub_locators.append(loc2)
            joint_locators.append(loc3)

            cmds.parent(loc3, loc2)
            cmds.parent(loc2, loc)
            cmds.parent(loc, setup_loc_group)

            # cmds.hide(loc2)
            geo.attach_to_motion_path(loc, self.curve, constrain=False, u_value=parameter, direct=True,
                                      translate_only=True)
            # geo.attach_to_curve(loc,self.curve,maintain_offset=False,parameter=parameter)

        self.locators = locators
        self.sub_locators = sub_locators
        self.joint_locators = joint_locators

    def _create_clusters(self, parent):

        clusters = deform.cluster_curve(self.curve, description=self._get_name(), join_ends=False, join_start_end=False,
                                        last_pivot_end=False)
        cmds.parent(clusters, parent)

        cluster_name = self._get_name()

        for inc in range(0, 3):
            clusters[inc] = cmds.rename(clusters[inc], core.inc_name('clusterHandle_%s_L' % cluster_name))

        clusters[3] = cmds.rename(clusters[3], 'clusterHandle_%s_C' % cluster_name)
        right_clusters = clusters[4:]
        right_clusters.reverse()

        for inc in range(len(clusters) - 1, 3, -1):
            clusters[inc] = cmds.rename(clusters[inc], core.inc_name('clusterHandle_%s_R' % cluster_name))

        self.clusters = clusters

    def _create_controls(self):

        orig_side = self.side

        left_clusters = self.clusters[:2]
        right_clusters = self.clusters[-2:]
        right_clusters.reverse()

        edge_clusters = left_clusters + right_clusters

        self.clusters = self.clusters[:-2] + right_clusters

        for cluster in self.clusters:

            self.side = 'C'
            description = ''
            if cluster.endswith('_L'):
                self.side = 'L'
            if cluster.endswith('_R'):
                self.side = 'R'

            if cluster in edge_clusters:
                description = 'corner'

            control_inst = self._create_control(description)

            control_inst.rotate_shape(90, 0, 0)

            space.MatchSpace(cluster, control_inst.control).translation_to_rotate_pivot()

            space.create_xform_group(control_inst.control)
            driver = space.create_xform_group(control_inst.control, 'driver')
            self.drivers.append(driver)

            local, local_xform = space.constrain_local(control_inst.control, cluster, parent=True)
            attr.zero_xform_channels(local_xform)
            attr.zero_xform_channels(cluster)
            local_driver = space.create_xform_group(local, 'driver')
            attr.connect_transforms(driver, local_driver)
            cmds.parent(local_xform, self.setup_group)

        control1 = self.controls[-2]
        control2 = self.controls[-1]
        self.controls[-1] = control1
        self.controls[-2] = control2

        driver1 = self.drivers[-2]
        driver2 = self.drivers[-1]
        self.drivers[-1] = driver1
        self.drivers[-2] = driver2

        attr.connect_multiply('%s.translateY' % self.controls[2], '%s.translateY' % self.drivers[1], value=0.5,
                              skip_attach=False, plus=True)
        attr.connect_multiply('%s.translateY' % self.controls[4], '%s.translateY' % self.drivers[5], value=0.5,
                              skip_attach=False, plus=True)

        self.side = orig_side

    def _setup_locator_pivots(self):

        params = self.parameters

        for locator, sub_locator in zip(self.locators, self.sub_locators):

            param_node = attr.get_attribute_input('%s.translateX' % locator, node_only=True)
            # parameter = cmds.getAttr('%s.parameter' % param_node)

            position = cmds.getAttr('%s.allCoordinates' % param_node)[0]
            # position = cmds.getAttr('%s.position' % param_node)[0]

            test_param = geo.get_closest_parameter_on_curve(self.temp_curve, position)

            control_start = None
            control_end = None
            info_start = None
            info_end = None

            # if test_param == params[0]:
            # if test_param == params[-1]:

            weight = 1.0

            if test_param > params[0] and test_param < params[1]:
                weight = util_math.remap_value(test_param, params[0], params[1], 0, 1)
                info_start = self.info_dict[params[0]]
                info_end = self.info_dict[params[1]]
                control_start = self.param_control_dict[params[0]]
                control_end = self.param_control_dict[params[1]]
            if test_param > params[1] and test_param < params[2]:
                info_start = self.info_dict[params[1]]
                info_end = self.info_dict[params[2]]
                control_start = self.param_control_dict[params[1]]
                control_end = self.param_control_dict[params[2]]
                weight = util_math.remap_value(test_param, params[1], params[2], 0, 1)
            if test_param > params[2] and test_param < params[3]:
                info_start = self.info_dict[params[2]]
                info_end = self.info_dict[params[3]]
                control_start = self.param_control_dict[params[2]]
                control_end = self.param_control_dict[params[3]]
                weight = util_math.remap_value(test_param, params[2], params[3], 0, 1)
            if test_param > params[3] and test_param < params[4]:
                info_start = self.info_dict[params[3]]
                info_end = self.info_dict[params[4]]
                control_start = self.param_control_dict[params[3]]
                control_end = self.param_control_dict[params[4]]
                weight = util_math.remap_value(test_param, params[3], params[4], 0, 1)

            alt_weight = 1.0 - weight

            if control_start is not None and control_end is not None:
                blend = cmds.createNode('pairBlend')
                sub_blend = cmds.createNode('pairBlend')

                cmds.connectAttr('%s.rotateX' % control_start, '%s.inRotateX1' % blend)
                cmds.connectAttr('%s.rotateY' % control_start, '%s.inRotateY1' % blend)
                cmds.connectAttr('%s.rotateZ' % control_start, '%s.inRotateZ1' % blend)

                cmds.connectAttr('%s.outRotateX' % blend, '%s.rotateX' % locator)
                cmds.connectAttr('%s.outRotateY' % blend, '%s.rotateY' % locator)
                cmds.connectAttr('%s.outRotateZ' % blend, '%s.rotateZ' % locator)

                cmds.setAttr('%s.weight' % blend, weight)

                cmds.connectAttr('%s.rotateX' % control_end, '%s.inRotateX1' % sub_blend)
                cmds.connectAttr('%s.rotateY' % control_end, '%s.inRotateY1' % sub_blend)
                cmds.connectAttr('%s.rotateZ' % control_end, '%s.inRotateZ1' % sub_blend)

                cmds.connectAttr('%s.outRotateX' % sub_blend, '%s.rotateX' % sub_locator)
                cmds.connectAttr('%s.outRotateY' % sub_blend, '%s.rotateY' % sub_locator)
                cmds.connectAttr('%s.outRotateZ' % sub_blend, '%s.rotateZ' % sub_locator)

                cmds.setAttr('%s.weight' % sub_blend, alt_weight)

            if info_start is not None and info_end is not None:
                subtract = cmds.createNode('plusMinusAverage', n='subtract_pivot_%s' % locator)
                subtract2 = cmds.createNode('plusMinusAverage', n='subtract_pivot2_%s' % sub_locator)
                cmds.setAttr('%s.operation' % subtract, 2)
                cmds.setAttr('%s.operation' % subtract2, 2)

                # cmds.connectAttr('%s.positionX' % param_node, '%s.input3D[1].input3Dx' % subtract)
                # cmds.connectAttr('%s.positionY' % param_node, '%s.input3D[1].input3Dy' % subtract)
                # cmds.connectAttr('%s.positionZ' % param_node, '%s.input3D[1].input3Dz' % subtract)
                cmds.connectAttr('%s.xCoordinate' % param_node, '%s.input3D[1].input3Dx' % subtract)
                cmds.connectAttr('%s.yCoordinate' % param_node, '%s.input3D[1].input3Dy' % subtract)
                cmds.connectAttr('%s.zCoordinate' % param_node, '%s.input3D[1].input3Dz' % subtract)

                cmds.connectAttr('%s.positionX' % info_start, '%s.input3D[0].input3Dx' % subtract)
                cmds.connectAttr('%s.positionY' % info_start, '%s.input3D[0].input3Dy' % subtract)
                cmds.connectAttr('%s.positionZ' % info_start, '%s.input3D[0].input3Dz' % subtract)

                cmds.connectAttr('%s.output3Dx' % subtract, '%s.rotatePivotX' % locator)
                cmds.connectAttr('%s.output3Dy' % subtract, '%s.rotatePivotY' % locator)
                cmds.connectAttr('%s.output3Dz' % subtract, '%s.rotatePivotZ' % locator)

                # cmds.connectAttr('%s.positionX' % param_node, '%s.input3D[1].input3Dx' % subtract2)
                # cmds.connectAttr('%s.positionY' % param_node, '%s.input3D[1].input3Dy' % subtract2)
                # cmds.connectAttr('%s.positionZ' % param_node, '%s.input3D[1].input3Dz' % subtract2)
                cmds.connectAttr('%s.xCoordinate' % param_node, '%s.input3D[1].input3Dx' % subtract2)
                cmds.connectAttr('%s.yCoordinate' % param_node, '%s.input3D[1].input3Dy' % subtract2)
                cmds.connectAttr('%s.zCoordinate' % param_node, '%s.input3D[1].input3Dz' % subtract2)

                cmds.connectAttr('%s.positionX' % info_end, '%s.input3D[0].input3Dx' % subtract2)
                cmds.connectAttr('%s.positionY' % info_end, '%s.input3D[0].input3Dy' % subtract2)
                cmds.connectAttr('%s.positionZ' % info_end, '%s.input3D[0].input3Dz' % subtract2)
                # cmds.connectAttr('%s.xCoordinate' % param_node, '%s.input3D[0].input3Dx' % subtract2)
                # cmds.connectAttr('%s.yCoordinate' % param_node, '%s.input3D[0].input3Dy' % subtract2)
                # cmds.connectAttr('%s.zCoordinate' % param_node, '%s.input3D[0].input3Dz' % subtract2)

                cmds.connectAttr('%s.output3Dx' % subtract2, '%s.rotatePivotX' % sub_locator)
                cmds.connectAttr('%s.output3Dy' % subtract2, '%s.rotatePivotY' % sub_locator)
                cmds.connectAttr('%s.output3Dz' % subtract2, '%s.rotatePivotZ' % sub_locator)

    def _setup_main_info_nodes(self):

        self.info_dict = {}
        self._rel_param = {}

        for param in self.parameters:
            info = cmds.createNode('pointOnCurveInfo', n=core.inc_name('pointOnCurveInfo_%s_1' % curve))
            cmds.connectAttr('%s.worldSpace' % self.curve, '%s.inputCurve' % info)

            position = geo.get_point_from_curve_parameter(self.temp_curve, param)

            rel_param = geo.get_closest_parameter_on_curve(self.curve, position)

            cmds.setAttr('%s.parameter' % info, rel_param)
            self.info_dict[param] = info
            self._rel_param[param] = rel_param

    def _attach_joints_to_locators(self):

        for locator, joint in zip(self.joint_locators, self.joints):
            cmds.parentConstraint(locator, joint, mo=True)

    def create(self):
        super(LipRig, self).create()

        self.parameters = [0.0, 0.2, 0.5, 0.8, 1.0]

        self._create_curve()

        self._setup_main_info_nodes()

        self._create_controls()

        corner_left = cmds.spaceLocator()[0]
        corner_right = cmds.spaceLocator()[0]

        control_dict = {self.parameters[0]: corner_left,
                        self.parameters[1]: self.controls[2],
                        self.parameters[2]: self.controls[3],
                        self.parameters[3]: self.controls[4],
                        self.parameters[4]: corner_right}

        self.param_control_dict = control_dict

        self._setup_locator_pivots()

        self._attach_joints_to_locators()

        cmds.delete(self.temp_curve)


class FaceSliders(JointRig):
    """
    This requires a joint with a locator under it.
    if locator is:
    localPositionX = 0
    localPositionY = 0.5
    localPositionZ = 0
    localScaleX = 0
    localScaleY = 0.5
    localScaleZ = 0
    then slider works in one direction

    if locator is:
    localPositionX = 0
    localPositionY = 0
    localPositionZ = 0
    localScaleX = 0
    localScaleY = 1
    localScaleZ = 0
    then slider works in both directions

    if no locator or settings not detected, then default slider works in one direction
    """

    def __init__(self, description, side):

        super(FaceSliders, self).__init__(description, side)

        self.control_shape = 'triangle'
        self.negative_control_shape = 'diamond'
        self._delete_setup = True
        self._overdrive = False

    def _post_connect_controller(self):

        if not self._pick_walk_parent:
            parent = cmds.listRelatives(self.control_group, p=True)

            if parent:
                parent = parent[0]
                if not cmds.controller(parent, q=True, isController=True):
                    return
        else:
            parent = self._pick_walk_parent

        for control in self.controls:

            if cmds.controller(control, q=True, isController=True):
                cmds.controller(control, parent, e=True, p=True)

    def set_overdrive(self, overdrive_amount=1.5):
        """
        Value that the slider is allowed to go to
        """
        self._overdrive = overdrive_amount

    def set_positive_negative_shape(self, curve_type):

        self.negative_control_shape = curve_type

    def create(self):
        super(FaceSliders, self).create()

        for joint in self.joints:

            split_name = joint.split('_')

            description = split_name[1:-1]
            description = description[0]

            rel = cmds.listRelatives(joint, type='locator')

            negative = False

            orig_control_shape = self.control_shape

            if rel:
                rel = rel[0]
                position = cmds.getAttr('%s.localPosition' % rel)[0]
                scale = cmds.getAttr('%s.localScale' % rel)[0]

                pass_test = False

                if position[0] < 0.01 and position[1] < 0.01 and position[2] < 0.01:
                    pass_test = True
                else:
                    pass_test = False

                if pass_test:
                    if scale[0] < 0.01 and scale[1] >= 0.6 and scale[2] < 0.01:
                        pass_test = True
                    else:
                        pass_test = False

                if pass_test:
                    negative = True

            if negative:
                self.control_shape = self.negative_control_shape

            orig_description = description
            description = vtool.util.camel_to_underscore(description)

            control = self._create_control(description)

            self.control_shape = orig_control_shape

            cmds.addAttr(control.control, ln='shape', dt='string')
            cmds.setAttr('%s.shape' % control.control, orig_description, type='string')

            scale = cmds.getAttr('%s.scaleY' % joint)

            if not negative:
                curve = cmds.curve(d=1, p=((0, 0, 0), (0, 1, 0)))
                control.rotate_shape(-90, 0, 0)
                # control.translate_shape(0,.715,0)
                control.scale_shape(0.25, 0.25, 0.25)
            if negative:
                curve = cmds.curve(d=1, p=((0, -1, 0), (0, 1, 0)))
                control.rotate_shape(-90, 0, 0)
                # control.translate_shape(0,.715,0)
                control.scale_shape(0.4, 0.4, 0.4)
            curve = cmds.rename(curve, self._get_name('slider', description))

            # cmds.setAttr('%s.template' % curve, 1)
            cmds.setAttr('%s.overrideEnabled' % curve, 1)
            cmds.setAttr('%s.overrideDisplayType' % curve, 2)

            xform = control.create_xform()
            cmds.parent(curve, xform)

            space.MatchSpace(joint, xform).translation_rotation()

            control.hide_rotate_attributes()
            control.hide_scale_and_visibility_attributes()

            attr.hide_attributes(control.control, ['translateX', 'translateZ'])

            if not self._overdrive:
                if not negative:
                    cmds.transformLimits(control.control, ty=[0, 1], ety=[1, 1])
                if negative:
                    cmds.transformLimits(control.control, ty=[-1, 1], ety=[1, 1])
            if self._overdrive:
                if not negative:
                    cmds.transformLimits(control.control, ty=[0, self._overdrive], ety=[1, 1])
                if negative:
                    cmds.transformLimits(control.control, ty=[self._overdrive * -1, self._overdrive], ety=[1, 1])

            space.MatchSpace(joint, xform).scale()

            offset_scale = 1.0 / scale
            control.scale_shape(offset_scale, offset_scale, offset_scale)

            remap = cmds.createNode('remapColor', n=core.inc_name('remapColor_%s' % control.control))

            cmds.connectAttr('%s.translateY' % control.control, '%s.colorR' % remap)
            cmds.connectAttr('%s.translateY' % control.control, '%s.colorG' % remap)
            cmds.connectAttr('%s.translateY' % control.control, '%s.colorB' % remap)

            color = attr.get_color(control.control + 'Shape')

            color_rgb = attr.color_to_rgb(color)

            cmds.setAttr('%s.red[0].red_FloatValue' % remap, color_rgb[0])
            cmds.setAttr('%s.green[0].green_FloatValue' % remap, color_rgb[1])
            cmds.setAttr('%s.blue[0].blue_FloatValue' % remap, color_rgb[2])

            cmds.setAttr('%s.red[1].red_FloatValue' % remap, 1)
            cmds.setAttr('%s.green[1].green_FloatValue' % remap, .3)
            cmds.setAttr('%s.blue[1].blue_FloatValue' % remap, 0)

            cmds.setAttr('%s.red[1].red_Position' % remap, 1)
            cmds.setAttr('%s.green[1].green_Position' % remap, 1)
            cmds.setAttr('%s.blue[1].blue_Position' % remap, 1)

            if negative:
                cmds.setAttr('%s.inputMin' % remap, -1)

                cmds.setAttr('%s.red[0].red_FloatValue' % remap, 1)
                cmds.setAttr('%s.green[0].green_FloatValue' % remap, .3)
                cmds.setAttr('%s.blue[0].blue_FloatValue' % remap, 0)

                cmds.setAttr('%s.red[1].red_FloatValue' % remap, color_rgb[0])
                cmds.setAttr('%s.green[1].green_FloatValue' % remap, color_rgb[1])
                cmds.setAttr('%s.blue[1].blue_FloatValue' % remap, color_rgb[2])

                cmds.setAttr('%s.red[1].red_Position' % remap, 0.5)
                cmds.setAttr('%s.green[1].green_Position' % remap, 0.5)
                cmds.setAttr('%s.blue[1].blue_Position' % remap, 0.5)

                cmds.setAttr('%s.red[2].red_FloatValue' % remap, 1)
                cmds.setAttr('%s.green[2].green_FloatValue' % remap, .3)
                cmds.setAttr('%s.blue[2].blue_FloatValue' % remap, 0)

                cmds.setAttr('%s.red[2].red_Position' % remap, 1)
                cmds.setAttr('%s.green[2].green_Position' % remap, 1)
                cmds.setAttr('%s.blue[2].blue_Position' % remap, 1)

            if self._overdrive:

                offset = vtool.util_math.remap_value(1, 0, self._overdrive, 0, 1)

                cmds.setAttr('%s.inputMax' % remap, self._overdrive)
                cmds.setAttr('%s.outputMax' % remap, self._overdrive)

                if not negative:
                    cmds.setAttr('%s.red[1].red_Position' % remap, offset)
                    cmds.setAttr('%s.green[1].green_Position' % remap, offset)
                    cmds.setAttr('%s.blue[1].blue_Position' % remap, offset)

                    cmds.setAttr('%s.red[2].red_FloatValue' % remap, 1)
                    cmds.setAttr('%s.green[2].green_FloatValue' % remap, 0)
                    cmds.setAttr('%s.blue[2].blue_FloatValue' % remap, 1)

                    cmds.setAttr('%s.red[2].red_Position' % remap, 1)
                    cmds.setAttr('%s.green[2].green_Position' % remap, 1)
                    cmds.setAttr('%s.blue[2].blue_Position' % remap, 1)

                if negative:
                    offset = vtool.util_math.remap_value(1, -1 * self._overdrive, self._overdrive, 0, 1)

                    cmds.setAttr('%s.inputMin' % remap, -1 * self._overdrive)

                    cmds.setAttr('%s.red[0].red_FloatValue' % remap, 1)
                    cmds.setAttr('%s.green[0].green_FloatValue' % remap, 0)
                    cmds.setAttr('%s.blue[0].blue_FloatValue' % remap, 1)

                    invert_offset = 1.0 - offset
                    cmds.setAttr('%s.red[1].red_FloatValue' % remap, 1)
                    cmds.setAttr('%s.green[1].green_FloatValue' % remap, 0.3)
                    cmds.setAttr('%s.blue[1].blue_FloatValue' % remap, 0)

                    cmds.setAttr('%s.red[1].red_Position' % remap, invert_offset)
                    cmds.setAttr('%s.green[1].green_Position' % remap, invert_offset)
                    cmds.setAttr('%s.blue[1].blue_Position' % remap, invert_offset)

                    cmds.setAttr('%s.red[2].red_FloatValue' % remap, color_rgb[0])
                    cmds.setAttr('%s.green[2].green_FloatValue' % remap, color_rgb[1])
                    cmds.setAttr('%s.blue[2].blue_FloatValue' % remap, color_rgb[2])

                    cmds.setAttr('%s.red[2].red_Interp' % remap, 1)
                    cmds.setAttr('%s.green[2].green_Interp' % remap, 1)
                    cmds.setAttr('%s.blue[2].blue_Interp' % remap, 1)

                    cmds.setAttr('%s.red[2].red_Position' % remap, .5)
                    cmds.setAttr('%s.green[2].green_Position' % remap, .5)
                    cmds.setAttr('%s.blue[2].blue_Position' % remap, .5)

                    cmds.setAttr('%s.red[3].red_FloatValue' % remap, 1)
                    cmds.setAttr('%s.green[3].green_FloatValue' % remap, 0.3)
                    cmds.setAttr('%s.blue[3].blue_FloatValue' % remap, 0)

                    cmds.setAttr('%s.red[3].red_Interp' % remap, 1)
                    cmds.setAttr('%s.green[3].green_Interp' % remap, 1)
                    cmds.setAttr('%s.blue[3].blue_Interp' % remap, 1)

                    cmds.setAttr('%s.red[3].red_Position' % remap, offset)
                    cmds.setAttr('%s.green[3].green_Position' % remap, offset)
                    cmds.setAttr('%s.blue[3].blue_Position' % remap, offset)

                    cmds.setAttr('%s.red[4].red_FloatValue' % remap, 1)
                    cmds.setAttr('%s.green[4].green_FloatValue' % remap, 0)
                    cmds.setAttr('%s.blue[4].blue_FloatValue' % remap, 1)

                    cmds.setAttr('%s.red[4].red_Position' % remap, 1)
                    cmds.setAttr('%s.green[4].green_Position' % remap, 1)
                    cmds.setAttr('%s.blue[4].blue_Position' % remap, 1)

            cmds.connectAttr('%s.outColor' % remap, '%sShape.overrideColorRGB' % control.control)

            cmds.setAttr('%sShape.overrideRGBColors' % control.control, 1)


class FeatherStripRig(CurveRig):
    """
    New feather building class.
    Try giving it two curves using set_curve(['curve1', 'curve2']) and see what happens.
    This will need an example rig to show how it works.
    """

    def __init__(self, description, side=''):

        super(FeatherStripRig, self).__init__(description, side)

        self.geo_group = None
        self.curve_controls = []

        self.feather_count = 10
        self.feather_joint_sections = 3

        self.feather_tilt = 1
        self._feather_lift = 0

        self.object_rotation_up = None

        self.top_broad_joint = None
        self.btm_broad_joint = None

        self.u_spans = 6
        self.v_spans = 3

        self.up_parent = None

        self.skin_mesh = None
        self.wrap_mesh = None

        self.attribute_control = None

        self._top_feather_mesh = None
        self._btm_feather_mesh = None
        self._feather_mesh = None

        self._feather_width_scale = 1
        self._feather_length_scale = 1
        self._feather_length_random = None

        self._distance_falloff = 3

        self.curve_skin_joints = []
        self._skin_joint_create = []
        self.skin_joints = []

        self.tweak_controls = []
        self.tweak_joints = []

        self._internal_skin_curve_joints = True

        self._attribute_description = ''

        self.color = None
        self.color_flip = False

        self._feather_tangent_first_curve = False

    def _add_attributes(self):

        attribute_control = self._get_attribute_control()

        if not cmds.objExists('%s.featherVisibility' % attribute_control):
            cmds.addAttr(attribute_control, ln='featherVisibility', at='bool', dv=1, k=True)
        if not cmds.objExists('%s.subVisibility' % attribute_control):
            cmds.addAttr(attribute_control, ln='subVisibility', at='bool', dv=0, k=True)

        if self._attribute_description:
            attr.create_title(attribute_control, 'FEATHER_%s' % self._attribute_description.upper())
        if not self._attribute_description:
            attr.create_title(attribute_control, 'FEATHER')

        # self._add_attribute('featherVisibility', bool = True)
        # self._add_attribute('subVisibility', bool = True)
        self._add_attribute('liftTop')
        self._add_attribute('liftBtm')
        self._add_attribute('tiltTop')
        self._add_attribute('tiltBtm')
        self._add_attribute('xCurl')
        self._add_attribute('yCurl')
        self._add_attribute('zCurl')

    def _get_attribute_name(self, name):

        description = self._attribute_description
        if description:
            description = str(description)
            description = description[0].upper() + description[1:]

        return name + description

    def _get_attribute(self, name):
        """
        returns attribute_control.attribute
        """
        attribute = self._get_attribute_name(name)

        control = self._get_attribute_control()

        full_name = control + '.' + attribute

        return full_name

    def _add_attribute(self, name, attribute_control=None, bool_value=False):

        if not attribute_control:
            attribute_control = self._get_attribute_control()

        attribute = self._get_attribute_name(name)

        if not cmds.objExists('%s.%s' % (attribute_control, attribute)):
            if not bool_value:
                cmds.addAttr(attribute_control, ln=attribute, k=True, at='float')
            if bool_value:
                cmds.addAttr(attribute_control, ln=attribute, k=True, at='bool', dv=1)

    def _get_attribute_control(self,):

        control = self.control_group

        if self.tweak_controls:
            control = self.tweak_controls[0]

        if self.attribute_control:
            control = self.attribute_control

        return control

    def _create_joint_strips(self):

        strip1_name = self._get_name(description='strip')
        strip2_name = self._get_name(description='stripEnd')

        joints1 = rigs_util.create_joints_on_curve(self.curves[0], self.feather_count, strip1_name)
        joints2 = rigs_util.create_joints_on_curve(self.curves[1], self.feather_count, strip2_name)

        joints1_group = joints1[1]
        joints1 = joints1[0]

        joints2_group = joints2[1]
        joints2 = joints2[0]

        cmds.parent(joints1_group, self.setup_group)
        cmds.parent(joints2_group, self.setup_group)

        return joints1, joints2

    def _skin_curves(self):

        if self.curve_skin_joints and not self._internal_skin_curve_joints:
            skin = cmds.skinCluster(self.curve_skin_joints, self.curves[1], tsb=True, dr=self._distance_falloff,
                                    n='skin_%s' % self.curves[1], rui=True)[0]
            cmds.setAttr('%s.skinningMethod' % skin, 1)

        if self.curve_skin_joints and self._internal_skin_curve_joints:
            tweak_ends = self.get_tweak_joint_ends()
            skin_ends = self.get_skin_joint_ends()

            ends = tweak_ends + skin_ends

            skin = cmds.skinCluster(ends,
                                    self.curves[1],
                                    tsb=True,
                                    dr=self._distance_falloff,
                                    n='skin_%s' % self.curves[1],
                                    rui=True
                                    )[0]
            cmds.setAttr('%s.skinningMethod' % skin, 1)
        if self.skin_mesh and not self.wrap_mesh:
            deform.skin_mesh_from_mesh(self.skin_mesh, self.curves[0])

        if self.wrap_mesh:
            deform.create_wrap(self.wrap_mesh, self.curves[0])

    def _create_inc_control(self, geo_name, sub, inc, joint):
        control_inst = self._create_control(description='%s' % (inc + 1), sub=sub)

        control = control_inst.control

        control_xform = space.create_xform_group(control)

        if inc == 0:
            control_inst.scale_shape(2, 2, 2)

        if self.side == 'R':
            control_inst.scale_shape(-1, -1, -1)

        space.MatchSpace(joint, control_xform).translation_rotation()

        cmds.parent(joint, control)
        cmds.hide(joint)
        # cmds.parentConstraint(control, joint)

        driver_tilt = None
        driver3 = None
        if inc == 0:
            driver_tilt = space.create_xform_group(control, 'driver_tilt')
            driver3 = space.create_xform_group(control, 'driver3')
        driver2 = space.create_xform_group(control, 'driver2')
        space.create_xform_group(control, 'driver')

        if inc == 0:
            cmds.setAttr('%s.rotateX' % driver_tilt, self.feather_tilt)
            if self._feather_lift:
                cmds.setAttr('%s.rotateZ' % driver_tilt, self._feather_lift)

        return control, control_xform, driver3, driver2

    def _create_curve_joint(self, curve_percent1, curve_percent2, description, invert):

        pos1 = cmds.pointOnCurve(self.curves[0], pr=curve_percent1, p=True, top=True)
        pos2 = cmds.pointOnCurve(self.curves[1], pr=curve_percent2, p=True, top=True)

        cmds.select(cl=True)
        joint1 = cmds.joint(n=core.inc_name(self._get_name('joint', description)), p=pos1)
        joint2 = cmds.joint(n=core.inc_name(self._get_name('joint', description)), p=pos2)

        space.orient_x_to_child(joint1, invert=invert)

        return joint1, joint2

    def _create_skin_joint(self):

        inc = 1

        for joint in self._skin_joint_create:
            invert = False
            if self.side == 'R':
                invert = True

            joint1, joint2 = self._create_curve_joint(joint[0], joint[1], 'skin%s' % inc, invert)

            self.curve_skin_joints.append(joint2)

            if joint[2] and cmds.objExists(joint[2]):
                cmds.parentConstraint(joint[2], joint1, mo=True)

            self.skin_joints.append([joint1, joint2])

            cmds.parent(joint1, self.setup_group)

    def _create_curve_control(self):

        inc = 1

        for curve_control in self.curve_controls:

            invert = False
            if self.side == 'R':
                invert = True

            joint1, joint2 = self._create_curve_joint(curve_control[0], curve_control[1], 'tweak%s' % inc, invert)

            control = self._create_control('tweak', sub=False)

            control.scale_shape(15, 15, 15)
            control.rotate_shape(0, 0, -90)

            inc += 1

            if invert:
                control.scale_shape(-1, -1, -1)

            control.hide_scale_and_visibility_attributes()

            control = control.control
            xform = space.create_xform_group(control)
            space.create_xform_group(control, 'driver')

            space.MatchSpace(joint1, xform).translation_rotation()
            cmds.parentConstraint(control, joint1)
            self.tweak_controls.append(control)
            self.curve_skin_joints.append(joint2)
            self.tweak_joints.append([joint1, joint2])

            cmds.parent(joint1, self.setup_group)

    def _create_geo(self, joint1, joint2, invert):
        loc1 = cmds.spaceLocator(n=core.inc_name(self._get_name('temp')))[0]
        loc2 = cmds.spaceLocator(n=core.inc_name(self._get_name('temp')))[0]

        distance = space.get_distance(joint1, joint2)

        if not invert:
            cmds.move(distance, 0, 0, loc2)
        if invert:
            cmds.move((distance * -1), 0, 0, loc2)

        geo_name = geo.create_two_transforms_mesh_strip(loc1, loc2, offset_axis='Z', u_spans=self.u_spans,
                                                        v_spans=self.v_spans)
        nice_geo_name = self._get_name(description='geo')
        geo_name = cmds.rename(geo_name, core.inc_name(nice_geo_name))

        cmds.polyNormal(geo_name, normalMode=0, userNormalMode=0, ch=False)

        cmds.delete(loc1, loc2)

        return geo_name

    def set_attribute_control(self, transform):
        self.attribute_control = transform

    def set_attribute_description(self, description):
        self._attribute_description = description

    def set_feather_up_parent(self, parent):
        self.up_parent = parent

    def set_feather_u_v_spans(self, u_spans, v_spans):

        self.u_spans = u_spans
        self.v_spans = v_spans

    def set_feather_count(self, value):
        self.feather_count = value

    def set_feather_joint_sections(self, value):
        self.feather_joint_sections = value

    def set_feather_tilt(self, value):

        self.feather_tilt = value

    def set_feather_lift(self, value):
        self._feather_lift = value

    def set_feather_tangent_first_curve(self, bool_value):
        self._feather_tangent_first_curve = bool_value

    def set_curve_skin_joints(self, joints, distance_falloff=2):

        joints = vtool.util.convert_to_sequence(joints)

        self.curve_skin_joints = joints

        self._internal_skin_curve_joints = False

        self._distance_falloff = distance_falloff

    def set_curve_skin_falloff(self, value):
        self._distance_falloff = value

    def set_first_curve_skin_mesh(self, mesh):

        self.skin_mesh = mesh

    def set_first_curve_wrap_mesh(self, mesh):
        self.wrap_mesh = mesh

    def set_feather_blend(self, feather_mesh):
        self._feather_mesh = feather_mesh

    def set_feather_blend_top_btm(self, top_feather_mesh, btm_feather_mesh):
        self._top_feather_mesh = top_feather_mesh
        self._btm_feather_mesh = btm_feather_mesh

    def set_feather_width_scale(self, value):
        self._feather_width_scale = value

    def set_feather_length_scale(self, value):
        self._feather_length_scale = value

    def set_feather_length_random(self, min_value, max_value):
        self._feather_length_random = [min_value, max_value]

    def set_color(self, r, g, b):
        self.color = [r, g, b]

    def add_curve_control(self, percent_curve1, percent_curve2):
        self.curve_controls.append([percent_curve1, percent_curve2])

    def add_skin_joint(self, percent_curve1, percent_curve2, parent=None):
        self._skin_joint_create.append([percent_curve1, percent_curve2, parent])

    def get_tweak_joints(self):
        found = []

        for tweak_joint in self.tweak_joints:
            found.append(tweak_joint[0])

        return found

    def get_tweak_joint_ends(self):
        found = []

        for tweak_joint in self.tweak_joints:
            found.append(tweak_joint[1])

        return found

    def get_skin_joint_ends(self):

        found = []

        for skin_joint in self.skin_joints:
            found.append(skin_joint[1])

        return found

    def create(self):
        super(FeatherStripRig, self).create()

        self._create_skin_joint()
        self._create_curve_control()

        attribute_control = self._get_attribute_control()
        self._add_attributes()

        self._skin_curves()

        if not len(self.curves) == 2:
            vtool.util.warning('Feather rig must have exactly two curves')
            return

        joints1, joints2 = self._create_joint_strips()

        joint_section_name = self._get_name('section')

        geo_group = self._create_group('geo')
        self.geo_group = geo_group

        cmds.connectAttr('%s.featherVisibility' % attribute_control, '%s.visibility' % geo_group)

        offset_amount = (1.0 / (self.feather_count - 1))
        offset_accum = 0

        color_dict = {}

        previous_point_node = None

        curve_group = self._create_group(description='guide')

        cmds.parent(curve_group, self.setup_group)

        invert = False

        if self.side == 'R':
            invert = True

        for inc in range(0, len(joints1)):

            cmds.setAttr('%s.inheritsTransform' % joints1[inc], 0)

            geo_name = self._create_geo(joints1[inc], joints2[inc], invert)

            color = None
            if self.color:
                color = geo.set_geo_color(geo_name, self.color, self.color_flip)

            if self.color_flip == True:
                self.color_flip = False
            else:
                self.color_flip = True

            color_dict[geo_name] = color

            aim_group = cmds.group(em=True, n='aim_%s' % geo_name)

            joints = space.transforms_to_joint_chain([joints1[inc], joints2[inc]], joint_section_name)

            space.MatchSpace(joints1[inc], aim_group).translation_rotation()
            cmds.parent(aim_group, joints1[inc])

            world_up_vector = [0, 1, 0]
            point_node = None

            if not self._feather_tangent_first_curve:
                point_node = attr.get_attribute_input('%s.translateX' % joints2[inc], node_only=True)
            if self._feather_tangent_first_curve:
                point_node = attr.get_attribute_input('%s.translateX' % joints1[inc], node_only=True)

            if self.up_parent:
                world_up_vector = [0, 0, 0]
                point_node = None

            aim_const = None
            if not self.up_parent:
                aim_const = cmds.aimConstraint(joints2[inc], aim_group, wu=world_up_vector)[0]
            if self.up_parent:
                object_up = cmds.group(n=core.inc_name(self._get_name('up')), em=True)
                cmds.parent(object_up, self.up_parent)
                aim_const = cmds.aimConstraint(joints2[inc],
                                               aim_group,
                                               wu=world_up_vector,
                                               worldUpObject=self.up_parent,
                                               worldUpType='objectrotation'
                                               )[0]

            if previous_point_node:
                cmds.connectAttr('%s.position' % point_node, '%s.worldUpVector' % aim_const)

            previous_point_node = point_node

            space.create_xform_group(aim_group)

            cmds.parent(joints[0], aim_group)

            space.orient_x_to_child(joints[0], invert=invert)
            cmds.makeIdentity(joints[1], jo=True, apply=True)

            scale_offset = self._feather_length_scale

            if self._feather_length_random:
                scale_random = self._feather_length_scale * random.uniform(self._feather_length_random[0],
                                                                           self._feather_length_random[1])
                scale_offset = scale_offset * scale_random

            distance = cmds.getAttr('%s.translateX' % joints[1])
            scale_amount = distance

            if scale_offset != 1:
                # cmds.setAttr('%s.scaleX' % joints[0], scale_offset)

                scale_amount = distance * scale_offset
                cmds.setAttr('%s.translateX' % joints[1], scale_amount)

            sub_joints = space.subdivide_joint(joints[0], joints[-1], self.feather_joint_sections)

            for sub_joint in sub_joints:
                space.orient_x_to_child(sub_joint, invert=invert)

            cmds.parent(joints[0], self.setup_group)

            cmds.parent(joints1[inc], self.control_group)
            cmds.setAttr('%s.drawStyle' % joints1[inc], 2)

            control_joints = [joints[0]]
            control_joints += sub_joints
            control_joints.append(joints[1])

            last_control = None

            normal_offset_accum = offset_accum

            if normal_offset_accum > 1:
                normal_offset_accum = 1

            offset_accum += offset_amount

            controls = []
            control_xforms = []

            feather_top_btm_blends = []

            for inc2 in range(0, (len(control_joints) - 1)):

                sub = True

                if inc2 == 0:
                    sub = False

                joint = control_joints[inc2]

                control, control_xform, driver3, driver2 = self._create_inc_control(geo_name, sub, inc2, joint)
                controls.append(control)
                control_xforms.append(control_xform)

                if inc2 == 0:
                    cmds.connectAttr('%s.featherVisibility' % attribute_control, '%s.visibility' % control_xform)

                    attr.create_title(control, 'FEATHER')

                    cmds.addAttr(control, ln='xCurl', k=True, at='float')
                    cmds.addAttr(control, ln='yCurl', k=True, at='float')
                    cmds.addAttr(control, ln='zCurl', k=True, at='float')

                    cmds.parent(control_xform, aim_group)

                    attr.connect_blend(self._get_attribute('liftBtm'),
                                       self._get_attribute('liftTop'),
                                       '%s.rotateZ' % driver3, normal_offset_accum)

                    attr.connect_blend(self._get_attribute('tiltBtm'),
                                       self._get_attribute('tiltTop'),
                                       '%s.rotateX' % driver3, normal_offset_accum)

                if inc2 == 1:
                    cmds.connectAttr('%s.subVisibility' % attribute_control, '%s.visibility' % control_xform)

                if inc2 != 0:
                    cmds.connectAttr(self._get_attribute('xCurl'), '%s.rotateX' % control_xform)
                    cmds.connectAttr(self._get_attribute('yCurl'), '%s.rotateY' % control_xform)
                    cmds.connectAttr(self._get_attribute('zCurl'), '%s.rotateZ' % control_xform)

                    cmds.connectAttr('%s.xCurl' % controls[0], '%s.rotateX' % driver2)
                    cmds.connectAttr('%s.yCurl' % controls[0], '%s.rotateY' % driver2)
                    cmds.connectAttr('%s.zCurl' % controls[0], '%s.rotateZ' % driver2)

                if last_control:
                    cmds.parent(control_xform, last_control)

                if self._top_feather_mesh and self._btm_feather_mesh and inc2 == 0:
                    other_offset_accum = 1 - normal_offset_accum

                    feather_top_btm_blends.append(
                        [[self._top_feather_mesh, other_offset_accum], [self._btm_feather_mesh, normal_offset_accum]])

                last_control = control

            cmds.parent(geo_name, joints[0])
            space.zero_out_transform_channels(geo_name)

            cmds.parent(geo_name, w=True)

            cmds.setAttr('%s.scaleX' % joints[0], scale_amount)
            cmds.setAttr('%s.scaleZ' % joints[0], self._feather_width_scale)
            cmds.setAttr('%s.scaleX' % geo_name, scale_offset)

            cmds.parent(geo_name, joints[0])
            cmds.makeIdentity(geo_name, apply=True, t=True, r=True, s=True)

            cmds.parent(geo_name, geo_group)

            cmds.setAttr('%s.scaleX' % joints[0], 1)
            cmds.setAttr('%s.scaleZ' % joints[0], 1)
            # cmds.setAttr(joints[0], apply = True, t = True, r = True, s = True)

            if self.side == 'R':
                cmds.setAttr('%s.scaleY' % geo_name, -1)
                # cmds.setAttr('%s.scaleZ' % geo_name, 1)

            curve = geo.transforms_to_curve(control_joints, description=self._get_name(prefix='guide'))

            cmds.skinCluster(control_joints, geo_name, tsb=True, dr=4, rui=True, n='skin_%s' % geo_name)
            cmds.skinCluster(control_joints, curve, tsb=True, dr=4, rui=True, n='skin_%s' % curve)

            cmds.parent(curve, curve_group)

            if self._feather_mesh and not self._btm_feather_mesh and not self._top_feather_mesh:
                deform.quick_blendshape(self._feather_mesh, geo_name)

            if feather_top_btm_blends:
                for blend in feather_top_btm_blends:
                    deform.quick_blendshape(blend[0][0], geo_name, blend[0][1])
                    deform.quick_blendshape(blend[1][0], geo_name, blend[1][1])

            new_curve = geo.create_curve_from_mesh_border(geo_name, .25)
            control_inst = rigs_util.Control(controls[0])
            control_inst.copy_shapes(new_curve)

            r, g, b = color_dict[geo_name]
            r = r * 1.3
            g = g * 1.3
            b = b * 1.3
            if r > 1:
                r = 1
            if g > 1:
                g = 1
            if b > 1:
                b = 1
            control_inst.color_rgb(r, g, b)

            cmds.delete(new_curve)


class FeatherOnPlaneRig(PolyPlaneRig):

    def __init__(self, description, side):
        super(FeatherOnPlaneRig, self).__init__(description, side)

        self.smooth_surface = None
        self.smooth_center = None
        self._quill_radius = 0.5
        self._follow_u = True
        self._feather_count = 5

        self._nucleus_name = ''
        self._hair_system_name = ''
        self._guide_geo = None
        self._quill_geo_group = None

        self._combine_quills = False

        self._tilt = 10

        self.color = None
        self.flip_color = False

        self._color_dict = {}

        self._guide_feather = None
        self._feather_curve_group = None
        self._feather_curve_quill = None

        self._main_control_offset = .25

        self._rig_info = []

    def _convert_plane_to_curves(self, plane, count, u):

        model_group = self._create_group('model')
        curve_group = self._create_group('curve')
        dynamic_curve_group = self._create_group('dynamicCurves')
        feather_curve_group = self._create_group('featherCurves')
        self._model_group = model_group
        guide_group = self._create_group('guides')
        cmds.parent(guide_group, model_group)

        curves = geo.polygon_plane_to_curves(plane, count=count, u=u)

        quill_group = self._create_group('quill')
        quill_geo_group = self._create_group('quill_geo')
        cmds.parent(quill_geo_group, model_group)
        quill_dynamic_group = self._create_group('quill_dynamic')
        cmds.parent(quill_group, self.setup_group)
        cmds.parent(quill_dynamic_group, self.setup_group)
        cmds.parent(curves, quill_group)
        cmds.parent(curve_group, model_group)
        cmds.parent(feather_curve_group, curve_group)
        cmds.parent(dynamic_curve_group, curve_group)

        quill_ik_group = cmds.group(em=True, n='quill_ik_%s' % plane)
        cmds.parent(quill_ik_group, self.setup_group)

        for inc, curve in enumerate(curves, 1):

            if vtool.util.is_stopped():
                return

            dynamic_curves = self._create_group('dynamicCurves', inc)
            cmds.parent(dynamic_curves, dynamic_curve_group)

            cmds.reverseCurve(curve, ch=False, rpo=1)
            cmds.smoothCurve('%s.cv[*]' % curve, ch=False, rpo=1, s=1)
            geo.rebuild_curve(curve, 10, degree=3)

            quill_geo = geo.create_quill(curve, self._quill_radius, spans=20)

            feather_group = self._create_group('featherCurves', inc)
            cmds.parent(feather_group, feather_curve_group)

            feather_curves = geo.get_of_type_in_hierarchy(self._feather_curve_group, 'nurbsCurve')

            guide_geo = cmds.duplicate(self._guide_feather, n='guideGeo_%s' % curve)[0]
            self._guide_geo = guide_geo

            if self.color:
                color = geo.set_geo_color(guide_geo, self.color, flip_color=self.flip_color)
                geo.set_geo_color(quill_geo, self.color, flip_color=self.flip_color)

                self._color_dict[self._guide_geo] = color

                if self.flip_color:
                    self.flip_color = False
                else:
                    self.flip_color = True

            guide_geo_cvs = cmds.ls('%s.vtx[*]' % guide_geo, flatten=True)
            cmds.parent(guide_geo, guide_group)

            feather_curves = geo.transfer_from_curve_to_curve(self._feather_curve_quill, curve, feather_curves, plane,
                                                              twist=self._tilt)
            geo.transfer_from_curve_to_curve(self._feather_curve_quill, curve, guide_geo_cvs, plane, twist=self._tilt)

            temp_curves = []

            for sub_curve in feather_curves:
                new_name = cmds.rename(sub_curve, core.inc_name(self._get_name('sub_curve', inc)))
                temp_curves.append(new_name)

            feather_curves = temp_curves

            cmds.makeIdentity(feather_curves, apply=True, t=True, r=True)
            cmds.parent(feather_curves, feather_group)
            dynamic_quill = self._follicle(quill_geo, curve, feather_curves, dynamic_curves, quill_ik_group, inc)
            cmds.parent(dynamic_quill, quill_dynamic_group)
            cmds.parent(quill_geo, quill_geo_group)

        self._quill_geo_group = quill_geo_group

    def _follicle(self, mesh, quill_curve, curves, dynamic_curve_group, ik_group, inc):

        nucleus_quill = 'nucleus_quill'
        nucleus_strand = 'nucleus_strand'
        nucleus_quill_name = 'quill'
        nucleus_strand_name = 'strand'

        if self._nucleus_name:
            nucleus_quill = 'nucleus_%s_quill' % self._nucleus_name
            nucleus_strand = 'nucleus_%s_strand' % self._nucleus_name
            nucleus_quill_name = '%s_quill' % self._nucleus_name
            nucleus_strand_name = '%s_strand' % self._nucleus_name

        quill_hair_system = 'hairSystem_quill'
        strand_hair_system = 'hairSystem_strands'
        hair_system_quill_name = 'quill'
        hair_system_strand_name = 'strands'

        if self._hair_system_name:
            quill_hair_system = 'hairSystem_%s_quill' % self._hair_system_name
            strand_hair_system = 'hairSystem_%s_strands' % self._hair_system_name
            hair_system_quill_name = '%s_quill' % self._hair_system_name
            hair_system_strand_name = '%s_strands' % self._hair_system_name

        if not cmds.objExists(nucleus_quill):
            nucleus_quill = fx.create_nucleus(name=nucleus_quill_name)
        if not cmds.objExists(nucleus_strand):
            nucleus_strand = fx.create_nucleus(name=nucleus_strand_name)

        if not cmds.objExists(quill_hair_system):
            quill_hair_system = fx.create_hair_system(hair_system_quill_name, nucleus_quill)[0]
        if not cmds.objExists(strand_hair_system):
            strand_hair_system = fx.create_hair_system(hair_system_strand_name, nucleus_strand)[0]

        follicle = fx.make_curve_dynamic(quill_curve, quill_hair_system)

        joints = geo.create_oriented_joints_on_curve(quill_curve, 25, description='quill', attach=True)

        ik = space.get_ik_from_joint(joints[0])[0]

        cmds.parent(joints[0], ik_group)
        cmds.parent(ik, ik_group)

        quill_output = fx.get_follicle_output_curve(follicle)
        input_curve = fx.get_follicle_input_curve(follicle)

        self._rig_curve(input_curve, inc, ik)

        cmds.skinCluster(mesh, joints, tsb=True)

        quill_output = cmds.rename(quill_output, 'dynamic_%s' % quill_curve)

        for curve in curves:

            follicle = fx.make_curve_dynamic(curve, hair_system=strand_hair_system, mesh=mesh, curve_closest_samples=5)

            outputs = fx.get_follicle_output_curve(follicle)

            cmds.parent(outputs, dynamic_curve_group)

            for output in outputs:
                cmds.rename(output, 'dynamic_%s' % curve)

        return quill_output

    def _rig_curve(self, curve, inc, ik):

        joints = geo.create_joints_on_curve(curve, 4, '%s_%s_1_%s' % (self.description, inc, self.side), attach=False)

        invert = False
        if self.side == 'R':
            invert = True

        for joint in joints:
            space.orient_x_to_child_up_to_surface(joint, invert, self.smooth_surface)

        last_control = None
        controls = []
        first_control = None
        for joint in joints:
            if joint == joints[-1]:
                continue

            control = self._create_control(description=inc)
            control.set_curve_type('square')
            control.scale_shape(self.control_size, self.control_size, self.control_size)
            control.rotate_shape(0, 0, 90)

            xform = space.create_xform_group(control.control)

            space.MatchSpace(joint, xform).translation_rotation()

            controls.append(control.control)

            cmds.parentConstraint(control.control, joint, mo=True)

            if joint == joints[0]:
                new_curve = geo.create_curve_from_mesh_border(self._guide_geo, self._main_control_offset)
                control.copy_shapes(new_curve)
                cmds.delete(new_curve)

            color = self._color_dict[self._guide_geo]

            color_r = None
            color_g = None
            color_b = None
            if joint == joints[0]:
                if self.flip_color:
                    color_r = color[0] * 1.5 + .15
                    color_g = color[1] * 1.5 + .15
                    color_b = color[2] * 1.5 + .15

                if not self.flip_color:
                    color_r = color[0] * (1 - color[0] * 0.5) * 1.5 + .15
                    color_g = color[1] * (1 - color[1] * 0.5) * 1.5 + .15
                    color_b = color[2] * (1 - color[2] * 0.5) * 1.5 + .15
            if joint != joints[0]:
                color_r = color[0] * 1.5 + .15
                color_g = color[1] * 1.5 + .15
                color_b = color[2] * 1.5 + .15

            control.color_rgb(color_r, color_g, color_b)

            if not last_control:
                first_control = control.control

                cmds.addAttr(control.control, ln='subVisibility', at='bool', k=True)

                attr.create_title(control.control, 'curl')
                cmds.addAttr(control.control, ln='curlX', at='double', k=True)
                cmds.addAttr(control.control, ln='curlY', at='double', k=True)
                cmds.addAttr(control.control, ln='curlZ', at='double', k=True)

            if last_control:
                cmds.parent(xform, last_control)

                driver = space.create_xform_group(control.control, 'driver')

                cmds.connectAttr('%s.curlX' % first_control, '%s.rotateX' % driver)
                cmds.connectAttr('%s.curlY' % first_control, '%s.rotateY' % driver)
                cmds.connectAttr('%s.curlZ' % first_control, '%s.rotateZ' % driver)

                cmds.connectAttr('%s.subVisibility' % first_control, '%sShape.visibility' % control.control)

            last_control = control.control

        cmds.setAttr('%s.dTwistControlEnable' % ik, 1)
        cmds.setAttr('%s.dWorldUpType' % ik, 4)
        cmds.connectAttr('%s.worldMatrix' % controls[0], '%s.dWorldUpMatrix' % ik)
        cmds.connectAttr('%s.worldMatrix' % controls[-1], '%s.dWorldUpMatrixEnd' % ik)

        self._rig_info.append([controls[0], joints[-1]])

        cmds.skinCluster(curve, joints, tsb=True)
        cmds.skinCluster(self._guide_geo, joints, tsb=True)

        cmds.parent(joints[0], self.setup_group)

    def _rig_curve_aim(self):

        joints = []
        controls = []

        for info in self._rig_info:
            controls.append(info[0])
            joints.append(info[1])

        curve = geo.transforms_to_curve(joints, 1, '%s_%s' % (self.description, self.side))
        cmds.setAttr('%s.inheritsTransform' % curve, 0)
        cmds.parent(curve, self.setup_group)
        geo.rebuild_curve(curve, 1, 1)

        base_curve = geo.transforms_to_curve(controls, 1, '%s_%s' % (self.description, self.side))
        geo.rebuild_curve(curve, 1, 1)

        joints = geo.create_joints_on_curve(curve, self._feather_count, '%s_%s' % (self.description, self.side),
                                            attach=True)

        joints_move = geo.create_joints_on_curve(curve, 2, 'move_%s_%s' % (self.description, self.side), attach=False)
        locators_base_move = geo.create_locators_on_curve(base_curve, 2, 'move_%s_%s' % (self.description, self.side),
                                                          attach=False)

        cmds.parent(joints_move, self.setup_group)
        cmds.parent(joints, self.setup_group)

        cmds.skinCluster(curve, joints_move, tsb=True)

        control_group = cmds.group(em=True, n=core.inc_name(self._get_name('controls', 'tweak')))
        cmds.parent(control_group, self.control_group)

        up_locator = cmds.spaceLocator(n=core.inc_name(self._get_name('locator', 'orientUp')))[0]
        cmds.parent(up_locator, self.setup_group)

        up_vector = geo.get_closest_normal_on_mesh(self.smooth_surface, self.smooth_center)

        aim_vector = [1, 0, 0]
        custom_up_vector = [0, 1, 0]

        if self.side == 'R':
            aim_vector = [-1, 0, 0]
            custom_up_vector = [0, -1, 0]

        top_controls = []
        for inc in range(0, len(joints_move)):

            joint = joints_move[inc]
            locator = locators_base_move[inc]

            distance = space.get_distance(joint, locator)

            cmds.delete(
                cmds.aimConstraint(joint, locator, wu=up_vector, aimVector=aim_vector, upVector=custom_up_vector))

            control = self._create_control(sub=True)

            control.set_curve_type('pin_round')
            control.rotate_shape(0, 0, 90)
            # control.rotate_shape(90,0,0)
            # control.scale_shape(-10,-10,-10)
            if self.side == 'L':
                control.scale_shape(-2 * distance, -2 * distance, -2 * distance)
            if self.side == 'R':
                control.scale_shape(2 * distance, 2 * distance, 2 * distance)

            xform = space.create_xform_group(control.control)
            space.MatchSpace(locator, xform).translation_rotation()
            cmds.delete(locator)

            cmds.parent(joint, control.control)
            cmds.hide(joint)

            cmds.parent(xform, control_group)

            top_controls.append(control)

            control.hide_scale_and_visibility_attributes()

            if self.color:
                control.color_rgb(self.color[0] * 2, self.color[1] * 2, self.color[2] * 2)

        for inc in range(0, len(joints)):
            # aim_group = cmds.group(em = True, n = core.inc_name(self._get_name('aim')))

            aim_vector = [1, 0, 0]
            up_vector = [0, 1, 0]

            if self.side == 'R':
                aim_vector = [-1, 0, 0]
                up_vector = [0, -1, 0]

            xform = space.get_xform_group(controls[inc])

            joint1, joint2, ik_pole = space.create_pole_chain(xform, joints[inc], self._get_name('aim'),
                                                              space.IkHandle.solver_rp)

            pole = cmds.group(em=True, n=core.inc_name(self._get_name('pole')))

            space.MatchSpace(joint1, pole).translation()

            joint_xform = space.create_xform_group(joint1)

            cmds.parent(ik_pole, joints[inc])

            cmds.setAttr('%s.drawStyle' % joint1, 2)
            cmds.setAttr('%s.drawStyle' % joint2, 2)

            cmds.rename(joint2, core.inc_name(self._get_name('aimEnd')))

            up_vector = geo.get_closest_normal_on_mesh(self.smooth_surface, self.smooth_center)

            up_vector = util_math.vector_add(cmds.xform(xform, q=True, ws=True, t=True), up_vector)

            cmds.xform(pole, ws=True, t=up_vector)

            cmds.poleVectorConstraint(pole, ik_pole)
            cmds.parent(pole, joint_xform)

            cmds.parent(joint_xform, self.control_group)
            cmds.parent(xform, joint1)

            """
            space.MatchSpace(xform, aim_group).translation_rotation()

            cmds.parent(aim_group, self.control_group)
            cmds.parent(xform, aim_group)


            """

        offset_value = 1.0 / 5.0

        top_value = 1.0 - offset_value
        btm_value = 0

        attr.create_title(top_controls[0].control, 'twist')
        cmds.addAttr(top_controls[0].control, ln='twistTop', at='double', k=True)
        cmds.addAttr(top_controls[0].control, ln='twistBtm', at='double', k=True)

        for control in controls:
            driver = space.create_xform_group(control, 'driver')
            driver2 = space.create_xform_group(control, 'driver2')
            attr.connect_multiply('%s.twistTop' % top_controls[0].control, '%s.rotateX' % driver, top_value)
            attr.connect_multiply('%s.twistBtm' % top_controls[0].control, '%s.rotateX' % driver2, btm_value)

            top_value -= offset_value
            btm_value += offset_value

        cmds.delete(base_curve)

    def _combine_quill_geo(self):

        result = cmds.polyUnite(self._quill_geo_group, ch=True, mergeUVSets=1,
                                name=core.inc_name(self._get_name('quills')))
        cmds.parent(result, self._model_group)

        cmds.parent(self._quill_geo_group, self.setup_group)

    def set_guide_feather(self, guide_feather_geo_name):
        """
        polygon geo that represents the curve
        """
        self._guide_feather = guide_feather_geo_name

    def set_feather_curve_group(self, feather_curve_group_name):
        """
        Group with curves in it, that represents the feather
        """
        self._feather_curve_group = feather_curve_group_name

    def set_feather_curve_quill(self, feather_curve_quill):
        """
        Curve to be the quill for feathers created on the surface.
        """

        self._feather_curve_quill = feather_curve_quill

    def set_main_control_offset(self, offset_value):
        self._main_control_offset = offset_value

    def set_nucleus_name(self, name):
        self._nucleus_name = name

    def set_hair_system_name(self, name):
        self._hair_system_name = name

    def set_follow_u(self, bool_value):
        self._follow_u = bool_value

    def set_feather_count(self, int_value):
        self._feather_count = int_value

    def set_combine_quills(self, bool_value):
        self._combine_quills = bool_value

    def set_tilt(self, float_value):
        self._tilt = float_value

    def set_color(self, r, g, b):
        self.color = [r, g, b]

    def create(self):
        super(FeatherOnPlaneRig, self).create()

        surface = cmds.duplicate(self.poly_plane)[0]
        geo.add_poly_smooth(surface, divisions=2)
        center = space.get_center(self.poly_plane)

        self.smooth_surface = surface
        self.smooth_center = center

        self._convert_plane_to_curves(self.poly_plane, self._feather_count, self._follow_u)

        if self._combine_quills:
            self._combine_quill_geo()

        self._rig_curve_aim()

        cmds.delete(self.smooth_surface)
